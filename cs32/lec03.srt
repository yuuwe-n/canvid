1
00:00:04,129 --> 00:00:06,479
Today I want to look at a

2
00:00:06,479 --> 00:00:07,844
little bit more about

3
00:00:07,844 --> 00:00:10,349
separate compilation and some issues coming

4
00:00:10,349 --> 00:00:13,409
up that will be relevant for, for project 1.

5
00:00:13,409 --> 00:00:15,958
So what we looked at last time

6
00:00:15,958 --> 00:00:18,690
was issues of separate compilation.

7
00:00:18,690 --> 00:00:20,609
What happens is the compiler

8
00:00:20,609 --> 00:00:22,440
takes each of your source files,

9
00:00:22,440 --> 00:00:25,320
it compiles it producing an object file.

10
00:00:25,320 --> 00:00:27,193
And with the object file contains

11
00:00:27,193 --> 00:00:29,129
is the translation of

12
00:00:29,129 --> 00:00:30,644
the code in your source file.

13
00:00:30,644 --> 00:00:31,528
It's a translation of

14
00:00:31,528 --> 00:00:32,579
the code for all the functions.

15
00:00:32,579 --> 00:00:33,668
You've got.

16
00:00:33,668 --> 00:00:37,579
Any sort of global objects,

17
00:00:37,579 --> 00:00:39,198
not local variables,

18
00:00:39,198 --> 00:00:40,700
but the global objects

19
00:00:40,700 --> 00:00:42,409
predominantly for most people that will

20
00:00:42,409 --> 00:00:44,149
be things like Libre

21
00:00:44,149 --> 00:00:45,619
has global objects like std,

22
00:00:45,619 --> 00:00:47,253
colon, colon C out.

23
00:00:47,253 --> 00:00:49,070
We're not making much use of

24
00:00:49,070 --> 00:00:50,298
global variables except

25
00:00:50,298 --> 00:00:51,619
perhaps global constants.

26
00:00:51,619 --> 00:00:53,929
So, so our object files and we have

27
00:00:53,929 --> 00:00:55,219
a global constant that'll

28
00:00:55,219 --> 00:00:56,630
be, that'll be in there.

29
00:00:56,630 --> 00:00:58,219
And then there'll be two lists,

30
00:00:58,219 --> 00:01:01,249
a list of the names that we define.

31
00:01:01,249 --> 00:01:04,219
So functions we implement

32
00:01:04,219 --> 00:01:07,009
global variables we declare,

33
00:01:07,009 --> 00:01:08,840
and global names that we need.

34
00:01:08,840 --> 00:01:11,088
So if a source file

35
00:01:11,088 --> 00:01:13,084
calls a function and

36
00:01:13,084 --> 00:01:14,269
it needs to be defined somewhere,

37
00:01:14,269 --> 00:01:15,558
the implementation has to be somewhere

38
00:01:15,558 --> 00:01:17,150
that'll be in the list of needs.

39
00:01:17,150 --> 00:01:19,010
And so the linker brings everything together,

40
00:01:19,010 --> 00:01:20,808
tying it together along with the,

41
00:01:20,808 --> 00:01:23,030
the libraries and the

42
00:01:23,030 --> 00:01:25,009
rules for linking we talked about.

43
00:01:25,009 --> 00:01:26,480
You can't have more than

44
00:01:26,480 --> 00:01:28,144
one definition for something.

45
00:01:28,144 --> 00:01:29,599
So you can't implement

46
00:01:29,599 --> 00:01:31,819
the exact same function

47
00:01:31,819 --> 00:01:33,500
with the same number of arguments,

48
00:01:33,500 --> 00:01:35,450
same types of arguments, more than once.

49
00:01:35,450 --> 00:01:36,859
In particular, you can't have

50
00:01:36,859 --> 00:01:38,989
more than one main routine and

51
00:01:38,989 --> 00:01:39,829
every knee has to be

52
00:01:39,829 --> 00:01:41,254
satisfied by some definition.

53
00:01:41,254 --> 00:01:43,459
And so I and I noted the linker will give

54
00:01:43,459 --> 00:01:44,569
you error messages if

55
00:01:44,569 --> 00:01:46,069
you violate this, if you,

56
00:01:46,069 --> 00:01:48,228
if you call a function that you'd

57
00:01:48,228 --> 00:01:51,004
never implemented anywhere down,

58
00:01:51,004 --> 00:01:54,394
the compiler will give you some message about

59
00:01:54,394 --> 00:01:56,269
an unresolved external reference

60
00:01:56,269 --> 00:01:58,233
or an undefined reference,

61
00:01:58,233 --> 00:02:00,813
an undefined name, something like that.

62
00:02:00,813 --> 00:02:03,168
If you define something more than once,

63
00:02:03,168 --> 00:02:03,739
you'll get something

64
00:02:03,739 --> 00:02:05,149
about multiple definitions.

65
00:02:05,149 --> 00:02:07,879
So let me look at some issues

66
00:02:07,879 --> 00:02:09,020
involved with

67
00:02:09,020 --> 00:02:11,180
separate compilation that come up here.

68
00:02:11,180 --> 00:02:14,014
So let me bring up a,

69
00:02:14,014 --> 00:02:16,235
again, we have some graphics application.

70
00:02:16,235 --> 00:02:19,294
And so here's what I want to try to do.

71
00:02:19,294 --> 00:02:21,468
I have a dot h which defines

72
00:02:21,468 --> 00:02:24,139
a point class that was provided.

73
00:02:24,139 --> 00:02:26,179
We're providing for people.

74
00:02:26,179 --> 00:02:28,370
Circle dot h defines a circle type.

75
00:02:28,370 --> 00:02:30,723
In particular, circles are implemented

76
00:02:30,723 --> 00:02:32,960
using point in order

77
00:02:32,960 --> 00:02:35,179
to specify the center of the circle.

78
00:02:35,179 --> 00:02:37,085
So circle dot h

79
00:02:37,085 --> 00:02:38,824
is going to make use of quaint.

80
00:02:38,824 --> 00:02:42,993
Now, a client may try to do this.

81
00:02:42,993 --> 00:02:45,679
I want to use a circle.

82
00:02:45,679 --> 00:02:47,750
And so the simple rule

83
00:02:47,750 --> 00:02:49,609
for clients to remember,

84
00:02:49,609 --> 00:02:52,084
the one you want it to be implementing.

85
00:02:52,084 --> 00:02:53,810
Simple rule should be,

86
00:02:53,810 --> 00:02:55,264
if I want to use a tight,

87
00:02:55,264 --> 00:02:56,810
I'll include the appropriate header

88
00:02:56,810 --> 00:02:58,069
that defines that time.

89
00:02:58,069 --> 00:02:59,569
That's the simple rule.

90
00:02:59,569 --> 00:03:01,024
If I want to use a circle,

91
00:03:01,024 --> 00:03:02,240
I should just have to include

92
00:03:02,240 --> 00:03:04,414
circle dot h and that's good enough.

93
00:03:04,414 --> 00:03:05,914
Well, we try this, of course,

94
00:03:05,914 --> 00:03:07,354
it won't compile.

95
00:03:07,354 --> 00:03:10,128
When the compiler tries to process

96
00:03:10,128 --> 00:03:12,724
myapp dot CPP and comes to 0,

97
00:03:12,724 --> 00:03:14,344
you're including circle dot h.

98
00:03:14,344 --> 00:03:15,153
Okay?

99
00:03:15,153 --> 00:03:17,120
I will remember where

100
00:03:17,120 --> 00:03:18,305
I am and come back here.

101
00:03:18,305 --> 00:03:20,840
Let's go process circle dot h, circle.

102
00:03:20,840 --> 00:03:22,159
That says, okay, here's what it

103
00:03:22,159 --> 00:03:23,808
means to be a circle, okay?

104
00:03:23,808 --> 00:03:26,943
And at that point, what's a point?

105
00:03:26,943 --> 00:03:28,490
And so the compiler will give you

106
00:03:28,490 --> 00:03:30,455
a compilation error about this line.

107
00:03:30,455 --> 00:03:32,569
It doesn't know what a point is.

108
00:03:32,569 --> 00:03:34,189
Now, the wrong way to

109
00:03:34,189 --> 00:03:36,153
fix that would be to say,

110
00:03:36,153 --> 00:03:38,675
oh, hey, people who were using my,

111
00:03:38,675 --> 00:03:41,389
my, my graphics library.

112
00:03:41,389 --> 00:03:43,594
Want to use a circle,

113
00:03:43,594 --> 00:03:44,899
you need to include

114
00:03:44,899 --> 00:03:47,210
point dot h and circle dot

115
00:03:47,210 --> 00:03:49,098
h. And you have to include

116
00:03:49,098 --> 00:03:50,509
point dot h before you

117
00:03:50,509 --> 00:03:53,000
and you include circle dot h.

118
00:03:53,000 --> 00:03:56,300
So if that's my rule,

119
00:03:56,300 --> 00:03:57,469
I tell people and

120
00:03:57,469 --> 00:03:59,479
they do that, this will be fine.

121
00:03:59,479 --> 00:04:03,139
The compiler will first include point dot h,

122
00:04:03,139 --> 00:04:04,399
which provides a definition

123
00:04:04,399 --> 00:04:05,688
of what it means to be a point.

124
00:04:05,688 --> 00:04:07,550
Then when it gets to circle dot h,

125
00:04:07,550 --> 00:04:08,659
the compiler says, Okay,

126
00:04:08,659 --> 00:04:10,338
fine, you're defining a circle.

127
00:04:10,338 --> 00:04:11,689
I know what a point is.

128
00:04:11,689 --> 00:04:12,949
Everything's fine.

129
00:04:12,949 --> 00:04:15,139
And so now we have it, we have a circle here.

130
00:04:15,139 --> 00:04:16,939
But that's a terrible thing

131
00:04:16,939 --> 00:04:18,288
to do to your users.

132
00:04:18,288 --> 00:04:19,158
If you're the designer

133
00:04:19,158 --> 00:04:20,435
and the graphics library,

134
00:04:20,435 --> 00:04:23,689
you have a whole complicated set of rules.

135
00:04:23,689 --> 00:04:25,670
If I want to use, if you want to

136
00:04:25,670 --> 00:04:27,334
use appoint conclude point dot h.

137
00:04:27,334 --> 00:04:28,834
If you want to use a circle,

138
00:04:28,834 --> 00:04:31,338
you have to include point dotage and

139
00:04:31,338 --> 00:04:34,264
circle that h in that order.

140
00:04:34,264 --> 00:04:37,384
And that leads to a whole bunch of rules.

141
00:04:37,384 --> 00:04:39,918
If you want to use a blob object,

142
00:04:39,918 --> 00:04:41,538
you have to include these other

143
00:04:41,538 --> 00:04:44,360
three had header files in a certain order.

144
00:04:44,360 --> 00:04:46,218
That's, that's too much to remember.

145
00:04:46,218 --> 00:04:48,139
You want this simple rule.

146
00:04:48,139 --> 00:04:49,939
The simple rule is,

147
00:04:49,939 --> 00:04:52,324
if you want to use a circle,

148
00:04:52,324 --> 00:04:53,509
include circle dot h.

149
00:04:53,509 --> 00:04:54,783
If you want to use oblige,

150
00:04:54,783 --> 00:04:56,088
include blood RH, and

151
00:04:56,088 --> 00:04:57,543
you shouldn't have to know anything else.

152
00:04:57,543 --> 00:04:59,870
Because after all, if I'm a user,

153
00:04:59,870 --> 00:05:02,000
a circle, I would ask you,

154
00:05:02,000 --> 00:05:03,798
why do I have to include point dot h?

155
00:05:03,798 --> 00:05:05,029
I'm not talking about points,

156
00:05:05,029 --> 00:05:06,244
I'm talking about cerebral.

157
00:05:06,244 --> 00:05:07,910
And if your answer is a well,

158
00:05:07,910 --> 00:05:10,444
But circle is implemented using a point,

159
00:05:10,444 --> 00:05:12,319
then you say, well, why do I care?

160
00:05:12,319 --> 00:05:13,999
I'm using a circle, I should not

161
00:05:13,999 --> 00:05:15,874
care about how it's implemented.

162
00:05:15,874 --> 00:05:19,309
So, so the solution

163
00:05:19,309 --> 00:05:23,103
is if a header file

164
00:05:23,103 --> 00:05:25,413
in order to compile successfully,

165
00:05:25,413 --> 00:05:28,413
needs to know about some other,

166
00:05:28,413 --> 00:05:30,678
some other types, then

167
00:05:30,678 --> 00:05:31,788
the header file should be

168
00:05:31,788 --> 00:05:33,408
responsible for making sure

169
00:05:33,408 --> 00:05:35,329
that both those names are defined.

170
00:05:35,329 --> 00:05:37,040
So if circle at

171
00:05:37,040 --> 00:05:38,884
H is going to be talking about points,

172
00:05:38,884 --> 00:05:40,639
it should be on circle dot h to

173
00:05:40,639 --> 00:05:41,990
include point dot h

174
00:05:41,990 --> 00:05:44,069
to make sure that happens.

175
00:05:50,819 --> 00:05:54,713
Yeah, our clients is very simple rule,

176
00:05:54,713 --> 00:05:56,319
if you want to use a circle,

177
00:05:56,319 --> 00:05:57,879
include circle dot h.

178
00:05:57,879 --> 00:05:59,348
So what will happen of course is

179
00:05:59,348 --> 00:06:00,850
this will now work the compiler

180
00:06:00,850 --> 00:06:03,040
when compiling myapp dot cpp,

181
00:06:03,040 --> 00:06:04,569
we'll start by saying,

182
00:06:04,569 --> 00:06:06,488
okay, I'll, I'll include circle at H.

183
00:06:06,488 --> 00:06:08,288
Then I'll continue circle about

184
00:06:08,288 --> 00:06:10,209
age being included starts off

185
00:06:10,209 --> 00:06:12,504
by saying I'm going to include point dot h.

186
00:06:12,504 --> 00:06:14,110
So find the compiler

187
00:06:14,110 --> 00:06:15,788
processes the declaration of points.

188
00:06:15,788 --> 00:06:18,220
So now we know what a point is and now

189
00:06:18,220 --> 00:06:19,540
continues and processes

190
00:06:19,540 --> 00:06:20,754
the declaration of circle,

191
00:06:20,754 --> 00:06:22,254
knowing what a point is.

192
00:06:22,254 --> 00:06:24,324
So, so everything's fine.

193
00:06:24,324 --> 00:06:26,425
By the time we're done with circle dot h,

194
00:06:26,425 --> 00:06:27,939
We know what a surplus.

195
00:06:27,939 --> 00:06:29,348
We also happen to know what a point

196
00:06:29,348 --> 00:06:30,850
is that was incidental.

197
00:06:30,850 --> 00:06:32,649
But, but we know what a circle is,

198
00:06:32,649 --> 00:06:34,555
so, so we're happy.

199
00:06:34,555 --> 00:06:36,158
Okay.

200
00:06:36,158 --> 00:06:39,189
Well, that's not the whole story.

201
00:06:39,189 --> 00:06:45,139
What if the client also wants to use a point?

202
00:06:46,680 --> 00:06:49,149
So I want to have a

203
00:06:49,149 --> 00:06:51,939
pointed at some coordinate,

204
00:06:51,939 --> 00:06:53,410
say x-coordinate 2, y coordinate

205
00:06:53,410 --> 00:06:55,314
for whatever the point constructor uses.

206
00:06:55,314 --> 00:06:57,699
So as a client I say,

207
00:06:57,699 --> 00:06:59,439
well, let's see. If I want.

208
00:06:59,439 --> 00:07:00,579
The simple rule that I

209
00:07:00,579 --> 00:07:02,108
know is if I want to use a circle,

210
00:07:02,108 --> 00:07:03,158
I'll include circle dot

211
00:07:03,158 --> 00:07:04,478
h. If I want to use a point,

212
00:07:04,478 --> 00:07:05,529
I'll include point dot

213
00:07:05,529 --> 00:07:08,319
h. Because I should

214
00:07:08,319 --> 00:07:10,375
not have to know as a client of this type,

215
00:07:10,375 --> 00:07:12,490
I should not have to know that

216
00:07:12,490 --> 00:07:14,680
circle is implemented using point.

217
00:07:14,680 --> 00:07:15,593
Circle might be implemented

218
00:07:15,593 --> 00:07:16,810
not using point, maybe.

219
00:07:16,810 --> 00:07:18,309
The circle type doesn't use

220
00:07:18,309 --> 00:07:19,930
point at all. It just has two doubles.

221
00:07:19,930 --> 00:07:20,920
I don't have to know.

222
00:07:20,920 --> 00:07:22,360
I shouldn't have to know that.

223
00:07:22,360 --> 00:07:25,613
Well, unfortunately, if I

224
00:07:25,613 --> 00:07:27,009
if I tried to finding

225
00:07:27,009 --> 00:07:29,454
this, this won't compile.

226
00:07:29,454 --> 00:07:31,629
What happens when I process,

227
00:07:31,629 --> 00:07:33,338
when I compile myapp dot cpp,

228
00:07:33,338 --> 00:07:34,509
the compiler says, Okay,

229
00:07:34,509 --> 00:07:36,488
you want to include circle dot h, fine.

230
00:07:36,488 --> 00:07:40,358
So I'll start by including circle dot h,

231
00:07:40,358 --> 00:07:43,149
which starts by including point dot h. So

232
00:07:43,149 --> 00:07:46,494
we have a declaration of point, okay?

233
00:07:46,494 --> 00:07:49,569
And now we finish up circle dot h, Okay?

234
00:07:49,569 --> 00:07:51,654
We know what a point is all as well.

235
00:07:51,654 --> 00:07:52,959
And so when we come out

236
00:07:52,959 --> 00:07:54,399
of this declaration of

237
00:07:54,399 --> 00:07:55,600
this include a circle dot

238
00:07:55,600 --> 00:07:57,310
h. We know what a point is,

239
00:07:57,310 --> 00:07:59,449
we know what a circle is.

240
00:07:59,490 --> 00:08:05,259
But then we include point dot h here.

241
00:08:05,259 --> 00:08:08,649
So the compiler processes this declaration of

242
00:08:08,649 --> 00:08:10,194
the point type and

243
00:08:10,194 --> 00:08:12,473
that's going to lead to a compilation error.

244
00:08:12,473 --> 00:08:17,048
The reason being that if you're compiling

245
00:08:17,048 --> 00:08:19,120
a file and the file

246
00:08:19,120 --> 00:08:24,069
defines say, some class a.

247
00:08:24,069 --> 00:08:26,963
And later on in the file,

248
00:08:26,963 --> 00:08:30,730
we also define the name a again,

249
00:08:30,730 --> 00:08:32,619
even if it's identical,

250
00:08:32,619 --> 00:08:34,239
even if the deck with whatever

251
00:08:34,239 --> 00:08:36,219
the implementation of the type

252
00:08:36,219 --> 00:08:38,198
a or whatever the declaration

253
00:08:38,198 --> 00:08:39,924
the type a was here.

254
00:08:39,924 --> 00:08:40,899
And then it, even if

255
00:08:40,899 --> 00:08:42,720
it's identical down later,

256
00:08:42,720 --> 00:08:45,544
That's a compilation error in the same file.

257
00:08:45,544 --> 00:08:47,524
You can't when compiling the same file,

258
00:08:47,524 --> 00:08:49,249
you can't have more than one

259
00:08:49,249 --> 00:08:51,995
declaration of the full,

260
00:08:51,995 --> 00:08:54,634
the full, full declaration of the type a.

261
00:08:54,634 --> 00:08:57,424
And that's what's happening here.

262
00:08:57,424 --> 00:08:59,629
What's happening up here is when

263
00:08:59,629 --> 00:09:02,208
compiling myapp dot cpp,

264
00:09:02,208 --> 00:09:04,519
we see a declaration

265
00:09:04,519 --> 00:09:05,855
of the point class because

266
00:09:05,855 --> 00:09:07,490
circle dot h includes

267
00:09:07,490 --> 00:09:08,808
point DOD aids and

268
00:09:08,808 --> 00:09:10,038
therefore there's a declaration

269
00:09:10,038 --> 00:09:11,043
of the point type.

270
00:09:11,043 --> 00:09:14,009
And then later on we have it again.

271
00:09:14,019 --> 00:09:17,495
When we include point out a second time.

272
00:09:17,495 --> 00:09:20,720
Okay, Again, the wrong solution

273
00:09:20,720 --> 00:09:23,434
is to say, oh,

274
00:09:23,434 --> 00:09:25,460
your ear to the designer and

275
00:09:25,460 --> 00:09:26,570
the graphics class and your

276
00:09:26,570 --> 00:09:27,903
documentation says,

277
00:09:27,903 --> 00:09:29,269
if you want to use a circle

278
00:09:29,269 --> 00:09:30,440
includes circle dot h.

279
00:09:30,440 --> 00:09:31,489
If you want to use a point,

280
00:09:31,489 --> 00:09:33,500
use point dot h. But if you want to

281
00:09:33,500 --> 00:09:35,975
use both of them in the same file,

282
00:09:35,975 --> 00:09:37,804
don't include point dot h,

283
00:09:37,804 --> 00:09:39,455
just include circled audience.

284
00:09:39,455 --> 00:09:40,999
Again, that's getting too

285
00:09:40,999 --> 00:09:42,695
complicated for users to know.

286
00:09:42,695 --> 00:09:46,144
Users should not have to know what circle

287
00:09:46,144 --> 00:09:48,139
depends on and therefore whether or not

288
00:09:48,139 --> 00:09:50,239
you should also include point dot h to pay.

289
00:09:50,239 --> 00:09:51,139
It's a, it's a pain.

290
00:09:51,139 --> 00:09:53,104
You don't want to, don't want to do that.

291
00:09:53,104 --> 00:09:56,974
So what we need is a way to somehow say,

292
00:09:56,974 --> 00:09:58,984
for the second and

293
00:09:58,984 --> 00:10:02,825
any further input inclusions of point dot h,

294
00:10:02,825 --> 00:10:04,739
We don't really want to process the,

295
00:10:04,739 --> 00:10:06,679
the declaration of the points.

296
00:10:06,679 --> 00:10:09,080
So in other words, we need a way to

297
00:10:09,080 --> 00:10:10,984
say after the first time,

298
00:10:10,984 --> 00:10:12,409
we've included point dot h and

299
00:10:12,409 --> 00:10:14,239
we've seen this point declaration

300
00:10:14,239 --> 00:10:16,129
later on if we ever include

301
00:10:16,129 --> 00:10:17,210
point dot h Again in

302
00:10:17,210 --> 00:10:19,190
this compilation of this file,

303
00:10:19,190 --> 00:10:22,144
don't process this declaration.

304
00:10:22,144 --> 00:10:24,918
So this is where

305
00:10:24,918 --> 00:10:26,269
things get kind of strange

306
00:10:26,269 --> 00:10:27,695
as far as the standard goes.

307
00:10:27,695 --> 00:10:32,568
We, we don't have

308
00:10:32,568 --> 00:10:37,279
a way in standard C or C plus plus to say,

309
00:10:37,279 --> 00:10:40,428
don't process this more than once.

310
00:10:40,428 --> 00:10:41,599
Or we don't have a way to do

311
00:10:41,599 --> 00:10:42,933
that in a simple way.

312
00:10:42,933 --> 00:10:44,779
The way that was

313
00:10:44,779 --> 00:10:48,379
kind of a work around for the problem in C.

314
00:10:48,379 --> 00:10:50,433
Almost 50 years ago,

315
00:10:50,433 --> 00:10:52,879
is still the only way that will

316
00:10:52,879 --> 00:10:54,500
standardly guaranteed to work

317
00:10:54,500 --> 00:10:56,778
across all implementations of the compilers.

318
00:10:56,778 --> 00:10:58,039
So the way that,

319
00:10:58,039 --> 00:11:00,440
that's done is something like this.

320
00:11:00,440 --> 00:11:03,798
The first time we process point dot h,

321
00:11:03,798 --> 00:11:06,649
We essentially drop a marker.

322
00:11:06,649 --> 00:11:07,908
We'll see how that works.

323
00:11:07,908 --> 00:11:11,208
We somehow mark that we've been here before.

324
00:11:11,208 --> 00:11:13,850
And then in any implement

325
00:11:13,850 --> 00:11:15,649
to end anytime we include point dot h,

326
00:11:15,649 --> 00:11:18,379
We check, have we been here before?

327
00:11:18,379 --> 00:11:19,490
If we've been here

328
00:11:19,490 --> 00:11:21,575
before, then skip everything.

329
00:11:21,575 --> 00:11:26,254
So the way to do that is in point dot h,

330
00:11:26,254 --> 00:11:29,163
We will make use of the, the,

331
00:11:29,163 --> 00:11:32,509
the, the pound define

332
00:11:32,509 --> 00:11:37,700
syntax available to us to define some symbol.

333
00:11:37,700 --> 00:11:40,759
Now, what's that symbol?

334
00:11:40,759 --> 00:11:43,370
It doesn't matter. It could be any symbol.

335
00:11:43,370 --> 00:11:46,249
I will pick a symbol that somehow tied

336
00:11:46,249 --> 00:11:47,904
to the name of

337
00:11:47,904 --> 00:11:49,370
the class we're defining

338
00:11:49,370 --> 00:11:50,389
or the name of the file,

339
00:11:50,389 --> 00:11:52,714
I'll call it say point included.

340
00:11:52,714 --> 00:11:54,798
But I could pick any other name.

341
00:11:54,798 --> 00:11:56,553
So I pick a name.

342
00:11:56,553 --> 00:11:57,889
By convention,

343
00:11:57,889 --> 00:11:59,855
we put it in all capital letters.

344
00:11:59,855 --> 00:12:01,429
And now I'm defining it,

345
00:12:01,429 --> 00:12:03,424
this, defining it as what?

346
00:12:03,424 --> 00:12:06,230
Well, the general pound define lets you

347
00:12:06,230 --> 00:12:07,669
define a symbol to be replaced by

348
00:12:07,669 --> 00:12:09,303
other text that's not relevant here.

349
00:12:09,303 --> 00:12:10,594
I just want to mark it as

350
00:12:10,594 --> 00:12:14,224
your defined point included will be defined.

351
00:12:14,224 --> 00:12:17,479
So whenever I process point dot h,

352
00:12:17,479 --> 00:12:19,894
the first time we'll define that symbol.

353
00:12:19,894 --> 00:12:21,320
Now we want to make sure we don't

354
00:12:21,320 --> 00:12:23,075
process point that age more than once.

355
00:12:23,075 --> 00:12:24,394
So I surround

356
00:12:24,394 --> 00:12:27,215
all the significant code and point dot h,

357
00:12:27,215 --> 00:12:30,120
I surround it with,

358
00:12:31,389 --> 00:12:33,529
with this almost pointless.

359
00:12:33,529 --> 00:12:36,590
And second, an F and

360
00:12:36,590 --> 00:12:40,445
F on top and down at the end, an end.

361
00:12:40,445 --> 00:12:43,278
Now endif is not allowed to

362
00:12:43,278 --> 00:12:45,889
have anything significant after it.

363
00:12:45,889 --> 00:12:49,219
But I tend, but you can put a comment and

364
00:12:49,219 --> 00:12:54,335
so I tend to repeat what this is closing off.

365
00:12:54,335 --> 00:12:56,448
It's closing off B, B,

366
00:12:56,448 --> 00:13:00,080
B this if NDF up here for point included.

367
00:13:00,080 --> 00:13:01,548
So that's a mouthful.

368
00:13:01,548 --> 00:13:02,614
What's going on here?

369
00:13:02,614 --> 00:13:04,504
The pound in if, if,

370
00:13:04,504 --> 00:13:06,559
if n depth is asking,

371
00:13:06,559 --> 00:13:08,899
if it's not defined,

372
00:13:08,899 --> 00:13:10,683
the end is short for not,

373
00:13:10,683 --> 00:13:12,350
the depth is short for define.

374
00:13:12,350 --> 00:13:13,955
So if it's, if it's,

375
00:13:13,955 --> 00:13:15,455
if it's not defined,

376
00:13:15,455 --> 00:13:16,938
this symbol point included.

377
00:13:16,938 --> 00:13:18,559
Another words, if point included has

378
00:13:18,559 --> 00:13:20,568
not yet been defined,

379
00:13:20,568 --> 00:13:23,899
then we are going to process everything

380
00:13:23,899 --> 00:13:25,458
up to the corresponding end

381
00:13:25,458 --> 00:13:27,184
up for the if and death.

382
00:13:27,184 --> 00:13:29,658
So the offend f has a corresponding endif.

383
00:13:29,658 --> 00:13:30,860
Everything in here is

384
00:13:30,860 --> 00:13:32,884
controlled by that, that test.

385
00:13:32,884 --> 00:13:34,399
So the test is if

386
00:13:34,399 --> 00:13:36,408
the symbol has not yet been defined,

387
00:13:36,408 --> 00:13:37,744
then do all this,

388
00:13:37,744 --> 00:13:39,394
which is define it,

389
00:13:39,394 --> 00:13:41,360
and then go ahead and process the code here

390
00:13:41,360 --> 00:13:42,168
to just see what

391
00:13:42,168 --> 00:13:44,389
the point class is all about.

392
00:13:44,389 --> 00:13:47,705
So that solves the problem.

393
00:13:47,705 --> 00:13:49,325
Here's, here's what's going on.

394
00:13:49,325 --> 00:13:50,450
So here's what happens when we

395
00:13:50,450 --> 00:13:52,429
compile myapp dot cpp.

396
00:13:52,429 --> 00:13:54,919
We say, okay, let's include circle dot hhs,

397
00:13:54,919 --> 00:13:57,080
circled IDA set circle dot h says,

398
00:13:57,080 --> 00:14:00,245
Okay, let's include point dot h. We,

399
00:14:00,245 --> 00:14:01,610
so this is the very first time.

400
00:14:01,610 --> 00:14:03,575
Now when compiling this file,

401
00:14:03,575 --> 00:14:05,419
it's the very first time we've done this.

402
00:14:05,419 --> 00:14:06,889
We've included circle dot h.

403
00:14:06,889 --> 00:14:09,469
So include point dot h ad.

404
00:14:09,469 --> 00:14:11,134
That starts off by saying,

405
00:14:11,134 --> 00:14:12,379
has the symbol point

406
00:14:12,379 --> 00:14:14,089
included been defined yet?

407
00:14:14,089 --> 00:14:15,259
No, it hasn't.

408
00:14:15,259 --> 00:14:16,100
We have not.

409
00:14:16,100 --> 00:14:18,364
During compiling this file.

410
00:14:18,364 --> 00:14:20,538
We have not seen it defined yet.

411
00:14:20,538 --> 00:14:23,043
So it says, okay, it's not defined.

412
00:14:23,043 --> 00:14:24,109
Therefore, we're going to

413
00:14:24,109 --> 00:14:25,715
process all this text.

414
00:14:25,715 --> 00:14:28,158
So the compiler will say, Okay,

415
00:14:28,158 --> 00:14:31,803
I will mark quaint included as being defined.

416
00:14:31,803 --> 00:14:33,499
Defined as what? We don't

417
00:14:33,499 --> 00:14:35,450
care if it's marked as

418
00:14:35,450 --> 00:14:37,009
being defined and will

419
00:14:37,009 --> 00:14:39,004
process the declaration of the coin class.

420
00:14:39,004 --> 00:14:41,360
Okay, so now we know what a point is.

421
00:14:41,360 --> 00:14:44,269
Alright, So we come back from here,

422
00:14:44,269 --> 00:14:46,653
the symbol point included has been defined.

423
00:14:46,653 --> 00:14:47,945
We know what a point is.

424
00:14:47,945 --> 00:14:49,220
So now we can go ahead and

425
00:14:49,220 --> 00:14:51,019
process the declaration of circle.

426
00:14:51,019 --> 00:14:53,119
We know what a point is, everything's fine.

427
00:14:53,119 --> 00:14:54,528
And when we finish here,

428
00:14:54,528 --> 00:14:56,075
we come back out here.

429
00:14:56,075 --> 00:15:00,198
And having included a circle dot h,

430
00:15:00,198 --> 00:15:02,179
we have the symbol

431
00:15:02,179 --> 00:15:04,009
point included being defined.

432
00:15:04,009 --> 00:15:06,065
We know what a point, the point class is,

433
00:15:06,065 --> 00:15:08,073
we know what the circle classes.

434
00:15:08,073 --> 00:15:12,634
So now if we ever include point dot h again,

435
00:15:12,634 --> 00:15:14,208
during compiling this file

436
00:15:14,208 --> 00:15:15,828
which we're doing here.

437
00:15:15,828 --> 00:15:18,320
Let's see if the symbol point

438
00:15:18,320 --> 00:15:20,073
included is not defined.

439
00:15:20,073 --> 00:15:21,799
Oh wait, it is defined.

440
00:15:21,799 --> 00:15:24,333
All right, so we skip all this.

441
00:15:24,333 --> 00:15:26,553
In particular, we skip

442
00:15:26,553 --> 00:15:29,554
processing the point class declaration again.

443
00:15:29,554 --> 00:15:32,000
And so we come out of this immediately,

444
00:15:32,000 --> 00:15:33,739
having done nothing additional we make,

445
00:15:33,739 --> 00:15:34,955
we haven't done anything new.

446
00:15:34,955 --> 00:15:36,078
We still know that

447
00:15:36,078 --> 00:15:37,864
the symbol point include is defined.

448
00:15:37,864 --> 00:15:39,350
We still know what a point is,

449
00:15:39,350 --> 00:15:40,924
we still know what a circle is.

450
00:15:40,924 --> 00:15:42,919
And so now this code compiles fine.

451
00:15:42,919 --> 00:15:43,909
We know what a circle is,

452
00:15:43,909 --> 00:15:45,259
we know what appointed.

453
00:15:45,259 --> 00:15:49,070
So that's the solution

454
00:15:49,070 --> 00:15:51,440
from almost 50 years ago.

455
00:15:51,440 --> 00:15:52,970
That is still the only

456
00:15:52,970 --> 00:15:54,678
solution to this problem that

457
00:15:54,678 --> 00:15:55,999
is guaranteed to be

458
00:15:55,999 --> 00:15:58,249
portable across all compilers.

459
00:15:58,249 --> 00:16:00,919
I mean, there are other techniques

460
00:16:00,919 --> 00:16:03,889
that many compilers that introduced.

461
00:16:03,889 --> 00:16:05,539
So just one line you can say

462
00:16:05,539 --> 00:16:07,399
something pound pragma once at that,

463
00:16:07,399 --> 00:16:09,320
that solves the problem, but that's not

464
00:16:09,320 --> 00:16:11,330
portable across all compilers.

465
00:16:11,330 --> 00:16:13,399
So we're not going to be using

466
00:16:13,399 --> 00:16:14,825
that back project one

467
00:16:14,825 --> 00:16:17,254
forbids you from using pragma once.

468
00:16:17,254 --> 00:16:18,543
Some notes about this,

469
00:16:18,543 --> 00:16:19,549
first of all terminology.

470
00:16:19,549 --> 00:16:20,570
So this sort of thing is

471
00:16:20,570 --> 00:16:22,115
called an Include Guard.

472
00:16:22,115 --> 00:16:24,349
It's guarding against this file being

473
00:16:24,349 --> 00:16:26,705
included more than once in the same,

474
00:16:26,705 --> 00:16:28,339
in compiling the same file.

475
00:16:28,339 --> 00:16:30,783
So in compiling myapp dot cpp,

476
00:16:30,783 --> 00:16:32,764
the Include Guard for point dot h

477
00:16:32,764 --> 00:16:34,894
is protecting us from from

478
00:16:34,894 --> 00:16:36,469
including point dot h by

479
00:16:36,469 --> 00:16:37,639
a circle dot h and

480
00:16:37,639 --> 00:16:39,754
also directly including it ourselves.

481
00:16:39,754 --> 00:16:41,464
No problem there.

482
00:16:41,464 --> 00:16:43,698
Everything significant should be

483
00:16:43,698 --> 00:16:45,063
inside the Include Guard.

484
00:16:45,063 --> 00:16:45,874
Everything.

485
00:16:45,874 --> 00:16:48,394
Don't try to do little things like, oh,

486
00:16:48,394 --> 00:16:50,059
outside here I am and

487
00:16:50,059 --> 00:16:51,845
start doing something significant

488
00:16:51,845 --> 00:16:55,999
like declaring a class, foo and whatever.

489
00:16:55,999 --> 00:16:57,769
But it's not no, that's outside.

490
00:16:57,769 --> 00:16:58,595
Don't do it.

491
00:16:58,595 --> 00:16:59,989
Everything significant

492
00:16:59,989 --> 00:17:01,729
goes inside the Include Guard.

493
00:17:01,729 --> 00:17:03,979
The only thing you would possibly put outside

494
00:17:03,979 --> 00:17:05,420
the Include Guard would

495
00:17:05,420 --> 00:17:08,058
be whitespace or a comment.

496
00:17:08,058 --> 00:17:10,220
So maybe I want to

497
00:17:10,220 --> 00:17:11,990
put a note in my file that

498
00:17:11,990 --> 00:17:14,210
this is point Daddy's.

499
00:17:14,210 --> 00:17:16,535
A comment can go outside there,

500
00:17:16,535 --> 00:17:18,470
everything else signifigant should

501
00:17:18,470 --> 00:17:20,839
be inside the Include Guards.

502
00:17:20,839 --> 00:17:23,419
I emphasize that because I have seen

503
00:17:23,419 --> 00:17:24,648
people try to put things

504
00:17:24,648 --> 00:17:26,390
outside the Include Guards to,

505
00:17:26,390 --> 00:17:28,548
to solve some, to attempt

506
00:17:28,548 --> 00:17:29,660
to solve some problem they're

507
00:17:29,660 --> 00:17:30,829
having and compiling.

508
00:17:30,829 --> 00:17:32,579
And that's not the right way to do.

509
00:17:32,579 --> 00:17:34,960
Everything goes inside of the Include Guard.

510
00:17:34,960 --> 00:17:37,119
Also, because this could

511
00:17:37,119 --> 00:17:38,454
happen in other levels.

512
00:17:38,454 --> 00:17:40,119
This should be done with every

513
00:17:40,119 --> 00:17:41,513
header file you write.

514
00:17:41,513 --> 00:17:43,118
So for circle dot h,

515
00:17:43,118 --> 00:17:45,624
I should have an Include Guard.

516
00:17:45,624 --> 00:17:46,929
Why do I have an Include

517
00:17:46,929 --> 00:17:48,144
Guard on circle dot h?

518
00:17:48,144 --> 00:17:50,380
I'm certainly not including circle dot

519
00:17:50,380 --> 00:17:52,824
h more than once in this compilation.

520
00:17:52,824 --> 00:17:53,784
No, I'm not.

521
00:17:53,784 --> 00:17:55,660
But there might be some other header I

522
00:17:55,660 --> 00:17:57,430
include that itself includes

523
00:17:57,430 --> 00:17:59,528
circle dot h. So if I include

524
00:17:59,528 --> 00:18:01,990
that other header and I include circle dot h,

525
00:18:01,990 --> 00:18:03,700
I want to make sure that I'm guarded against

526
00:18:03,700 --> 00:18:06,039
the multiple definition of a circle type.

527
00:18:06,039 --> 00:18:08,079
Now, you want the symbol to be

528
00:18:08,079 --> 00:18:11,064
different from any other symbol you're using.

529
00:18:11,064 --> 00:18:12,683
For example, if I were to

530
00:18:12,683 --> 00:18:15,068
pick the symbol point included,

531
00:18:15,068 --> 00:18:17,440
which is wrong, I mean, I could do that,

532
00:18:17,440 --> 00:18:19,388
but look what happens if I happened to

533
00:18:19,388 --> 00:18:21,923
pick a symbol I've used in a different file,

534
00:18:21,923 --> 00:18:23,500
which can happen by

535
00:18:23,500 --> 00:18:25,463
accident if you copy and paste.

536
00:18:25,463 --> 00:18:26,934
So be careful.

537
00:18:26,934 --> 00:18:28,838
Well, this is not going to work now

538
00:18:28,838 --> 00:18:31,088
because when I include circle dot h,

539
00:18:31,088 --> 00:18:32,558
It starts off by saying,

540
00:18:32,558 --> 00:18:33,878
have I seen a declaration of

541
00:18:33,878 --> 00:18:35,664
point included? No, I haven't.

542
00:18:35,664 --> 00:18:38,589
So let's define point included.

543
00:18:38,589 --> 00:18:40,720
Then. Include point dot h,

544
00:18:40,720 --> 00:18:42,250
which says, oh, have I

545
00:18:42,250 --> 00:18:43,944
seen a definition of point included?

546
00:18:43,944 --> 00:18:45,519
Yes, I have. So skip all

547
00:18:45,519 --> 00:18:48,009
this and then we end up not knowing

548
00:18:48,009 --> 00:18:49,990
what a point is and we get a compilation down

549
00:18:49,990 --> 00:18:52,493
here when we come to come to point.

550
00:18:52,493 --> 00:18:53,920
So, so no, no, no.

551
00:18:53,920 --> 00:18:55,644
Every file should have

552
00:18:55,644 --> 00:18:57,954
a unique name for its Include Guard.

553
00:18:57,954 --> 00:18:59,949
Now you have to make up, so you have to

554
00:18:59,949 --> 00:19:01,914
make up a different name for each file.

555
00:19:01,914 --> 00:19:03,940
And the common convention

556
00:19:03,940 --> 00:19:05,769
is to make up a name that

557
00:19:05,769 --> 00:19:07,914
somehow incorporates the filename

558
00:19:07,914 --> 00:19:09,128
because your files are

559
00:19:09,128 --> 00:19:10,450
going to have different names.

560
00:19:10,450 --> 00:19:12,279
So if you incorporate the filename

561
00:19:12,279 --> 00:19:13,673
somehow into your,

562
00:19:13,673 --> 00:19:15,189
your Include Guard name,

563
00:19:15,189 --> 00:19:16,630
then that'll make it different.

564
00:19:16,630 --> 00:19:18,398
So my file circle dot h.

565
00:19:18,398 --> 00:19:21,099
So why don't I call this circle include.

566
00:19:21,099 --> 00:19:22,930
I'm probably not going to have

567
00:19:22,930 --> 00:19:24,969
another file called circle.

568
00:19:24,969 --> 00:19:28,224
So, so that would be a good way to,

569
00:19:28,224 --> 00:19:29,815
to make sure it's kinda unique.

570
00:19:29,815 --> 00:19:31,779
And I don't have to,

571
00:19:31,779 --> 00:19:32,950
but if I want to,

572
00:19:32,950 --> 00:19:34,359
I can put a comment here.

573
00:19:34,359 --> 00:19:37,480
Be very, very careful

574
00:19:37,480 --> 00:19:39,579
that the symbol you're testing

575
00:19:39,579 --> 00:19:41,769
against the same as

576
00:19:41,769 --> 00:19:43,328
the symbol you're defining

577
00:19:43,328 --> 00:19:44,724
for this Include Guard.

578
00:19:44,724 --> 00:19:47,798
I have over and over seen people do

579
00:19:47,798 --> 00:19:52,644
things like like this,

580
00:19:52,644 --> 00:19:54,880
where the symbol they're defining

581
00:19:54,880 --> 00:19:57,023
is called point in coal did,

582
00:19:57,023 --> 00:19:58,538
because they had a little typo there

583
00:19:58,538 --> 00:20:00,729
and they switch the EU and the L.

584
00:20:00,729 --> 00:20:02,380
But that's not the symbol

585
00:20:02,380 --> 00:20:03,699
they're testing against.

586
00:20:03,699 --> 00:20:06,398
And so they're going to have a problem

587
00:20:06,398 --> 00:20:07,839
if they point dot h

588
00:20:07,839 --> 00:20:09,339
is included more than once.

589
00:20:09,339 --> 00:20:10,778
The symbol point included

590
00:20:10,778 --> 00:20:12,114
will never be defined.

591
00:20:12,114 --> 00:20:13,118
So you're always going to

592
00:20:13,118 --> 00:20:14,394
try to do this twice

593
00:20:14,394 --> 00:20:15,969
because the symbol you're defining

594
00:20:15,969 --> 00:20:17,710
as point in cold it.

595
00:20:17,710 --> 00:20:20,289
So, so make sure that the, you,

596
00:20:20,289 --> 00:20:23,755
you, you, you have used the same symbol here.

597
00:20:23,755 --> 00:20:26,424
Now again, this is

598
00:20:26,424 --> 00:20:28,269
the point that the purpose of

599
00:20:28,269 --> 00:20:30,069
the Include Guards is to

600
00:20:30,069 --> 00:20:33,009
guard against including the same header

601
00:20:33,009 --> 00:20:36,250
more than once in the same file.

602
00:20:36,250 --> 00:20:39,519
So myapp dot CPP is including

603
00:20:39,519 --> 00:20:40,930
circle dot h as including

604
00:20:40,930 --> 00:20:42,249
point dot agents and circle

605
00:20:42,249 --> 00:20:43,795
that h includes point dot h,

606
00:20:43,795 --> 00:20:45,430
where including point that age

607
00:20:45,430 --> 00:20:47,394
more than once in the same file.

608
00:20:47,394 --> 00:20:49,240
This proof, this protects us.

609
00:20:49,240 --> 00:20:51,638
It has absolutely nothing to do with

610
00:20:51,638 --> 00:20:53,980
the fact that, you know,

611
00:20:53,980 --> 00:20:56,589
one CPP file might include

612
00:20:56,589 --> 00:20:59,619
point dot h and another CPP file.

613
00:20:59,619 --> 00:21:00,880
And in the same program

614
00:21:00,880 --> 00:21:02,484
you're building also includes

615
00:21:02,484 --> 00:21:03,730
point that age that's

616
00:21:03,730 --> 00:21:06,045
totally around, that totally separate.

617
00:21:06,045 --> 00:21:09,890
Compiling myapp dot CPP is a distinct AC

618
00:21:09,890 --> 00:21:11,959
from compiling some other CPP file

619
00:21:11,959 --> 00:21:13,805
that happens to include point dot h,

620
00:21:13,805 --> 00:21:15,799
include guards are irrelevant for that.

621
00:21:15,799 --> 00:21:16,429
That's, that's,

622
00:21:16,429 --> 00:21:17,989
that's not where it comes into play.

623
00:21:17,989 --> 00:21:19,250
The Include Guard comes into

624
00:21:19,250 --> 00:21:20,420
play when we're including

625
00:21:20,420 --> 00:21:21,950
the same header file

626
00:21:21,950 --> 00:21:24,319
more than once in compiling,

627
00:21:24,319 --> 00:21:26,420
one given file, more than

628
00:21:26,420 --> 00:21:28,459
once in compiling myapp dot cpp,

629
00:21:28,459 --> 00:21:29,795
we're including point I'd age.

630
00:21:29,795 --> 00:21:31,368
That's why it's relevant.

631
00:21:31,368 --> 00:21:34,969
All the standard headers have include guards.

632
00:21:34,969 --> 00:21:37,878
So if you are compiling a program and

633
00:21:37,878 --> 00:21:41,239
you say include iostream,

634
00:21:41,239 --> 00:21:43,069
either directly or indirectly,

635
00:21:43,069 --> 00:21:44,659
and later on you

636
00:21:44,659 --> 00:21:46,984
have another, include iostream.

637
00:21:46,984 --> 00:21:48,034
Effectively.

638
00:21:48,034 --> 00:21:50,808
That's harmless in the same header file,

639
00:21:50,808 --> 00:21:52,069
including a standard header

640
00:21:52,069 --> 00:21:53,494
more than once as harmless.

641
00:21:53,494 --> 00:21:55,249
So that's one issue here.

642
00:21:55,249 --> 00:21:57,589
Does that solve all our problems?

643
00:21:57,589 --> 00:21:59,720
No, there's another compilation

644
00:21:59,720 --> 00:22:01,069
problem to deal with.

645
00:22:01,069 --> 00:22:04,788
So let me, let me go down here.

646
00:22:04,788 --> 00:22:07,338
And let's say that we're writing

647
00:22:07,338 --> 00:22:09,920
some application for the registrar.

648
00:22:09,920 --> 00:22:12,650
And so let's say

649
00:22:12,650 --> 00:22:15,200
that the registrar has decided that

650
00:22:15,200 --> 00:22:17,944
we are going to have a class student

651
00:22:17,944 --> 00:22:21,723
and students can enroll in courses.

652
00:22:21,723 --> 00:22:23,509
So we'll have an enroll function

653
00:22:23,509 --> 00:22:25,098
that takes a pointer to a course.

654
00:22:25,098 --> 00:22:27,169
And the students study list will

655
00:22:27,169 --> 00:22:28,699
be an array of pointers

656
00:22:28,699 --> 00:22:30,138
to the courses the student,

657
00:22:30,138 --> 00:22:34,114
students enrolled it. Okay?

658
00:22:34,114 --> 00:22:36,365
We also have information about a course.

659
00:22:36,365 --> 00:22:39,409
A given course has a certain number of units,

660
00:22:39,409 --> 00:22:41,720
for example, associated with it.

661
00:22:41,720 --> 00:22:48,513
And the a given course object

662
00:22:48,513 --> 00:22:50,390
can have a roster

663
00:22:50,390 --> 00:22:52,369
of all the students enrolled in the course.

664
00:22:52,369 --> 00:22:53,960
So let's say we use an array

665
00:22:53,960 --> 00:22:55,670
of pointers to each student there.

666
00:22:55,670 --> 00:22:57,828
So for example,

667
00:22:57,828 --> 00:23:00,078
the student Fred might

668
00:23:00,078 --> 00:23:01,878
have a pointer to the course.

669
00:23:01,878 --> 00:23:04,038
Cs 32 might have a pointer

670
00:23:04,038 --> 00:23:06,184
to the course for, or physics.

671
00:23:06,184 --> 00:23:07,730
You know, what?

672
00:23:07,730 --> 00:23:09,378
A, might have a pointer

673
00:23:09,378 --> 00:23:12,328
to a course for Math 33 be.

674
00:23:12,730 --> 00:23:15,440
Now the course object,

675
00:23:15,440 --> 00:23:17,088
for example, for CS 32,

676
00:23:17,088 --> 00:23:19,578
that for the CS 32 course object will have

677
00:23:19,578 --> 00:23:21,140
the Unix function returning

678
00:23:21,140 --> 00:23:22,714
for it's a four unit course.

679
00:23:22,714 --> 00:23:24,618
And we'll have a pointer to each of

680
00:23:24,618 --> 00:23:27,528
the students enrolled in CS 32.

681
00:23:27,528 --> 00:23:30,710
Okay? So we might

682
00:23:30,710 --> 00:23:32,929
want to have some function that takes

683
00:23:32,929 --> 00:23:34,219
a student and a pointer

684
00:23:34,219 --> 00:23:35,449
to some student and a pointer to

685
00:23:35,449 --> 00:23:36,769
some course and enrolls

686
00:23:36,769 --> 00:23:38,180
that student in the course.

687
00:23:38,180 --> 00:23:39,740
So we'll take the student object,

688
00:23:39,740 --> 00:23:41,599
we'll call the enrolled member function.

689
00:23:41,599 --> 00:23:43,279
Now if we try to compile this,

690
00:23:43,279 --> 00:23:44,390
of course it won't compile.

691
00:23:44,390 --> 00:23:45,528
The compiler says, I

692
00:23:45,528 --> 00:23:46,625
don't know what student is.

693
00:23:46,625 --> 00:23:47,838
I don't know what courses,

694
00:23:47,838 --> 00:23:49,009
What are you talking about?

695
00:23:49,009 --> 00:23:50,329
And we say, oh, of course

696
00:23:50,329 --> 00:23:51,829
we're going to include,

697
00:23:51,829 --> 00:23:54,709
we better include student dot h because where

698
00:23:54,709 --> 00:23:58,098
We're we're using the student type

699
00:23:58,098 --> 00:23:59,433
and in particular we,

700
00:23:59,433 --> 00:24:01,789
we are calling a member function on students.

701
00:24:01,789 --> 00:24:03,859
So how would the compiler know

702
00:24:03,859 --> 00:24:04,939
whether a student has

703
00:24:04,939 --> 00:24:06,229
an enroll function or not?

704
00:24:06,229 --> 00:24:08,314
If we don't include student that age.

705
00:24:08,314 --> 00:24:09,919
And of course, because we're talking

706
00:24:09,919 --> 00:24:11,239
about a pointer to a course,

707
00:24:11,239 --> 00:24:13,713
we'll, we'll also include course dot h.

708
00:24:13,713 --> 00:24:15,740
So we tried to compile this now.

709
00:24:15,740 --> 00:24:17,628
Now of course we have include guards were

710
00:24:17,628 --> 00:24:18,648
following the guidelines of

711
00:24:18,648 --> 00:24:19,699
having Include Guard.

712
00:24:19,699 --> 00:24:23,359
So student dot h has an Include Guard.

713
00:24:23,359 --> 00:24:24,950
And the symbol we're using for

714
00:24:24,950 --> 00:24:26,028
that astute included

715
00:24:26,028 --> 00:24:26,869
course dot h has

716
00:24:26,869 --> 00:24:28,519
an Include Guard, the symbol.

717
00:24:28,519 --> 00:24:31,339
That is course included. Okay, so

718
00:24:31,339 --> 00:24:32,959
let's try to compile this.

719
00:24:32,959 --> 00:24:35,808
All right, so we're going to try to

720
00:24:35,808 --> 00:24:37,339
include student dot age

721
00:24:37,339 --> 00:24:39,048
that starts off by saying,

722
00:24:39,048 --> 00:24:41,269
have we included this and you know,

723
00:24:41,269 --> 00:24:42,513
have we defined the symbol yet?

724
00:24:42,513 --> 00:24:44,179
No, we haven't. So we're

725
00:24:44,179 --> 00:24:46,115
going to process all this text.

726
00:24:46,115 --> 00:24:47,959
All right, so we'll define student

727
00:24:47,959 --> 00:24:49,578
included will say Here's

728
00:24:49,578 --> 00:24:51,125
what it means to be a student.

729
00:24:51,125 --> 00:24:52,700
And the compiler barbs

730
00:24:52,700 --> 00:24:54,049
when it sees the word course.

731
00:24:54,049 --> 00:24:55,115
I don't know what a course is.

732
00:24:55,115 --> 00:24:56,585
We say, oh yes, of course,

733
00:24:56,585 --> 00:24:57,769
student dot h is

734
00:24:57,769 --> 00:24:59,298
making use of the name course.

735
00:24:59,298 --> 00:25:01,069
So we'd better, we'd

736
00:25:01,069 --> 00:25:02,555
better include core studies.

737
00:25:02,555 --> 00:25:04,519
So let's try this again.

738
00:25:04,519 --> 00:25:06,890
We compile myapp dot cpp.

739
00:25:06,890 --> 00:25:09,815
We, we include student dot age.

740
00:25:09,815 --> 00:25:12,559
Student H starts off by saying,

741
00:25:12,559 --> 00:25:13,734
have we been here before?

742
00:25:13,734 --> 00:25:15,470
Now we haven't. So we'll

743
00:25:15,470 --> 00:25:17,058
define the symbol student

744
00:25:17,058 --> 00:25:19,128
included will go include

745
00:25:19,128 --> 00:25:21,483
core stage before we go on.

746
00:25:21,483 --> 00:25:24,259
Okay, So let's go include course dot h,

747
00:25:24,259 --> 00:25:25,609
which says have we been here

748
00:25:25,609 --> 00:25:27,483
before, know we haven't.

749
00:25:27,483 --> 00:25:29,450
So let's define the symbol course

750
00:25:29,450 --> 00:25:32,493
included and start processing.

751
00:25:32,493 --> 00:25:34,250
Here's what a course is.

752
00:25:34,250 --> 00:25:37,160
Ok, Whoops, we come to the named student.

753
00:25:37,160 --> 00:25:38,794
We don't know what a student is.

754
00:25:38,794 --> 00:25:41,299
What we have, we included student dot h.

755
00:25:41,299 --> 00:25:41,990
Now we haven't

756
00:25:41,990 --> 00:25:43,490
finished including student body.

757
00:25:43,490 --> 00:25:46,144
Remember, we said include student dot h

758
00:25:46,144 --> 00:25:47,929
and that started off

759
00:25:47,929 --> 00:25:49,339
by including course dot h.

760
00:25:49,339 --> 00:25:50,930
So we haven't yet gotten to

761
00:25:50,930 --> 00:25:52,909
the declaration of the student type.

762
00:25:52,909 --> 00:25:55,578
And now we run across the word stood.

763
00:25:55,578 --> 00:25:57,409
So you say, Okay,

764
00:25:57,409 --> 00:25:58,578
I guess that means coursed

765
00:25:58,578 --> 00:26:00,065
on H on includes circled

766
00:26:00,065 --> 00:26:03,769
student dot h. So let's try this again.

767
00:26:03,769 --> 00:26:06,409
So we try to include student on each here in

768
00:26:06,409 --> 00:26:09,334
my app dot cpp student dot h says,

769
00:26:09,334 --> 00:26:10,730
have I been here before?

770
00:26:10,730 --> 00:26:12,229
Know, so let's define

771
00:26:12,229 --> 00:26:14,013
the symbol stood, include it.

772
00:26:14,013 --> 00:26:16,429
And let's go include course dot h.

773
00:26:16,429 --> 00:26:18,798
Course dot h says have we been here before?

774
00:26:18,798 --> 00:26:20,180
Know, so let's define

775
00:26:20,180 --> 00:26:21,950
the symbol course included.

776
00:26:21,950 --> 00:26:25,144
And let's go includes student dot h.

777
00:26:25,144 --> 00:26:27,529
And student dot h says,

778
00:26:27,529 --> 00:26:29,269
have I been here before?

779
00:26:29,269 --> 00:26:30,349
Well, yes, I have.

780
00:26:30,349 --> 00:26:32,328
We've already defined the students circle.

781
00:26:32,328 --> 00:26:33,409
We've already defined

782
00:26:33,409 --> 00:26:35,000
the symbol student included.

783
00:26:35,000 --> 00:26:37,114
Skip all this.

784
00:26:37,114 --> 00:26:38,869
And therefore, we don't

785
00:26:38,869 --> 00:26:41,329
process the declaration of the student type.

786
00:26:41,329 --> 00:26:43,069
And we'll come back in here,

787
00:26:43,069 --> 00:26:44,388
we continue on and we

788
00:26:44,388 --> 00:26:46,263
still don't know what a student this,

789
00:26:46,263 --> 00:26:49,069
so this isn't going to work.

790
00:26:49,069 --> 00:26:51,680
This is a so-called circular dependency.

791
00:26:51,680 --> 00:26:53,704
It's a circular dependency.

792
00:26:53,704 --> 00:26:55,939
Student depends on course

793
00:26:55,939 --> 00:26:57,650
and course depends on student.

794
00:26:57,650 --> 00:26:59,808
So the problem comes

795
00:26:59,808 --> 00:27:01,984
in trying to do this compilation.

796
00:27:01,984 --> 00:27:05,388
We can't process the declaration of

797
00:27:05,388 --> 00:27:07,309
student without knowing that course

798
00:27:07,309 --> 00:27:08,630
is the name of a type.

799
00:27:08,630 --> 00:27:09,799
And we can't process

800
00:27:09,799 --> 00:27:10,880
the declaration of course,

801
00:27:10,880 --> 00:27:11,930
without knowing the student

802
00:27:11,930 --> 00:27:13,115
is the name of the type.

803
00:27:13,115 --> 00:27:16,250
And so we've got this problem here.

804
00:27:16,250 --> 00:27:19,940
And try as you may, if you're,

805
00:27:19,940 --> 00:27:21,618
if student dot h is somehow going to

806
00:27:21,618 --> 00:27:23,808
include course dot agents in course dot h is

807
00:27:23,808 --> 00:27:25,909
somehow going to include student dot h.

808
00:27:25,909 --> 00:27:28,098
You can't solve this nicely.

809
00:27:28,098 --> 00:27:29,689
People try things like,

810
00:27:29,689 --> 00:27:32,269
well maybe all not define the student

811
00:27:32,269 --> 00:27:33,979
included symbol until after

812
00:27:33,979 --> 00:27:35,778
I've included course dot h and blah,

813
00:27:35,778 --> 00:27:36,739
blah, blah, and you try

814
00:27:36,739 --> 00:27:38,493
various rearrangements of things.

815
00:27:38,493 --> 00:27:39,439
Maybe I'll put something

816
00:27:39,439 --> 00:27:40,940
outside the Include Guard.

817
00:27:40,940 --> 00:27:42,483
Ooh, no, don't do that either.

818
00:27:42,483 --> 00:27:42,709
A,

819
00:27:42,709 --> 00:27:44,269
you try various rearrangements

820
00:27:44,269 --> 00:27:45,769
and none of them.

821
00:27:45,769 --> 00:27:48,753
You may solve this immediate problem.

822
00:27:48,753 --> 00:27:50,480
But then some other situation

823
00:27:50,480 --> 00:27:52,160
where a client is including

824
00:27:52,160 --> 00:27:53,989
student dot h and course dot age or

825
00:27:53,989 --> 00:27:56,390
one of them and it's not going to work right.

826
00:27:56,390 --> 00:27:58,144
Or maybe we should first

827
00:27:58,144 --> 00:28:00,138
include course dot h then student at it.

828
00:28:00,138 --> 00:28:01,025
No, no, no.

829
00:28:01,025 --> 00:28:03,035
So let me get to the solution.

830
00:28:03,035 --> 00:28:07,189
First of all, let me note that C plus,

831
00:28:07,189 --> 00:28:10,130
plus and C basically

832
00:28:10,130 --> 00:28:11,659
allow you when you declare a class

833
00:28:11,659 --> 00:28:14,028
and a struct or a structure to

834
00:28:14,028 --> 00:28:15,318
provide a

835
00:28:15,318 --> 00:28:18,650
so-called incomplete type declaration.

836
00:28:18,650 --> 00:28:20,419
So if I define a class or

837
00:28:20,419 --> 00:28:22,398
a structure this way,

838
00:28:22,398 --> 00:28:25,683
this is an incomplete type declaration.

839
00:28:25,683 --> 00:28:29,659
I'm announcing that a is the name of a type,

840
00:28:29,659 --> 00:28:32,253
but I'm not saying any details about it.

841
00:28:32,253 --> 00:28:33,904
That's what that semicolon saying is just,

842
00:28:33,904 --> 00:28:35,884
I'm telling you is the name of the class,

843
00:28:35,884 --> 00:28:36,919
but I'm not going to give you

844
00:28:36,919 --> 00:28:39,058
any details right now.

845
00:28:39,549 --> 00:28:42,499
Now later on in the compilation,

846
00:28:42,499 --> 00:28:43,849
you could say, Oh,

847
00:28:43,849 --> 00:28:44,778
by the way, here is

848
00:28:44,778 --> 00:28:46,625
the full declaration of a.

849
00:28:46,625 --> 00:28:49,054
In fact, in the same declaration,

850
00:28:49,054 --> 00:28:51,019
you can have

851
00:28:51,019 --> 00:28:52,339
as many incomplete type

852
00:28:52,339 --> 00:28:53,808
specifications as you like.

853
00:28:53,808 --> 00:28:55,609
Now nobody would write this this way,

854
00:28:55,609 --> 00:28:57,710
but we'll see why this is, this is okay.

855
00:28:57,710 --> 00:29:01,265
So compiling the same file, this is all fine.

856
00:29:01,265 --> 00:29:02,838
You can have as many incomplete

857
00:29:02,838 --> 00:29:04,400
type declarations as you like,

858
00:29:04,400 --> 00:29:07,204
but no more than one actual full,

859
00:29:07,204 --> 00:29:08,749
full-blown declaration

860
00:29:08,749 --> 00:29:09,920
of the type of the class.

861
00:29:09,920 --> 00:29:12,078
We'll see why that's why that's useful.

862
00:29:12,078 --> 00:29:14,329
What's the purpose of this is to let

863
00:29:14,329 --> 00:29:15,828
the compiler know that

864
00:29:15,828 --> 00:29:17,463
a is the name of a type.

865
00:29:17,463 --> 00:29:20,253
But we're not saying anything about a.

866
00:29:20,253 --> 00:29:22,009
Well, we don't always

867
00:29:22,009 --> 00:29:24,095
need to know details about a.

868
00:29:24,095 --> 00:29:25,548
So let's go back to this and

869
00:29:25,548 --> 00:29:27,305
see how that solves the problem.

870
00:29:27,305 --> 00:29:30,500
Now, notice that when

871
00:29:30,500 --> 00:29:33,319
we declare the student type,

872
00:29:33,319 --> 00:29:35,630
student has a parameter that

873
00:29:35,630 --> 00:29:37,729
is a pointer to a course,

874
00:29:37,729 --> 00:29:40,939
and student has an array of course points.

875
00:29:40,939 --> 00:29:43,203
Now there's a role in C plus plus that,

876
00:29:43,203 --> 00:29:47,720
that when you declare a structure or a class,

877
00:29:47,720 --> 00:29:50,359
the compiler needs to be able to

878
00:29:50,359 --> 00:29:53,720
figure out the size of such an object.

879
00:29:53,720 --> 00:29:57,378
So if I declare a student B

880
00:29:57,378 --> 00:29:58,849
and tell you how it's

881
00:29:58,849 --> 00:29:59,989
implemented with an array

882
00:29:59,989 --> 00:30:01,219
of 10 course pointers.

883
00:30:01,219 --> 00:30:02,630
The compiler has to know how

884
00:30:02,630 --> 00:30:04,368
big the student is.

885
00:30:04,368 --> 00:30:07,564
Now, an array of 10 objects

886
00:30:07,564 --> 00:30:09,349
is going to be 10 times the size

887
00:30:09,349 --> 00:30:10,743
of one of those things.

888
00:30:10,743 --> 00:30:12,933
So an array of 10 study with 10,

889
00:30:12,933 --> 00:30:14,719
an array of 10 course pointers is going to

890
00:30:14,719 --> 00:30:17,088
be 10 times the size I've of course point.

891
00:30:17,088 --> 00:30:17,689
How?

892
00:30:17,689 --> 00:30:19,203
Because of course pointer.

893
00:30:19,203 --> 00:30:22,924
Well, there's a rule in C plus, plus,

894
00:30:22,924 --> 00:30:25,114
all pointers are the same size

895
00:30:25,114 --> 00:30:27,005
and the compiler knows that size.

896
00:30:27,005 --> 00:30:28,730
So if we're on a machine where pointers

897
00:30:28,730 --> 00:30:30,470
are always four bytes long,

898
00:30:30,470 --> 00:30:32,420
all pointers are four bytes long no matter

899
00:30:32,420 --> 00:30:34,759
what they point to 0.

900
00:30:34,759 --> 00:30:36,289
So do we need to know

901
00:30:36,289 --> 00:30:38,028
any details about the course

902
00:30:38,028 --> 00:30:39,769
tied to know that

903
00:30:39,769 --> 00:30:41,795
this is a four-byte pointer.

904
00:30:41,795 --> 00:30:44,614
Now, so the compiler says, oh,

905
00:30:44,614 --> 00:30:46,400
okay, list is an array

906
00:30:46,400 --> 00:30:47,660
of ten pointers to things.

907
00:30:47,660 --> 00:30:49,249
And pointers are four bytes long,

908
00:30:49,249 --> 00:30:50,868
so study list is 40 bytes long,

909
00:30:50,868 --> 00:30:53,285
so I know how big this is, I'm happy.

910
00:30:53,285 --> 00:30:55,219
So in other words, to,

911
00:30:55,219 --> 00:30:58,023
to use a pointer to something,

912
00:30:58,023 --> 00:30:59,539
the compiler only needs to know

913
00:30:59,539 --> 00:31:01,098
that that's the name of a type course is

914
00:31:01,098 --> 00:31:02,358
the name of the type doesn't need to

915
00:31:02,358 --> 00:31:04,429
know any details about course.

916
00:31:04,429 --> 00:31:08,239
So in particular, student dot h does

917
00:31:08,239 --> 00:31:13,234
not need to include, whoops, course dotted.

918
00:31:13,234 --> 00:31:15,829
All it needs is

919
00:31:15,829 --> 00:31:18,019
to know course is the name of a type.

920
00:31:18,019 --> 00:31:20,974
And we have broken the circular dependency.

921
00:31:20,974 --> 00:31:23,569
We broken the fact that, well,

922
00:31:23,569 --> 00:31:25,128
student dot h needs to include

923
00:31:25,128 --> 00:31:26,180
course dot h and courts

924
00:31:26,180 --> 00:31:27,709
dot h needs to include circled.

925
00:31:27,709 --> 00:31:29,808
Anymore, student diets

926
00:31:29,808 --> 00:31:31,294
doesn't include course dot h.

927
00:31:31,294 --> 00:31:32,719
All student dot h has to

928
00:31:32,719 --> 00:31:34,324
know is course is the name of a type.

929
00:31:34,324 --> 00:31:35,959
And that's enough to process

930
00:31:35,959 --> 00:31:38,525
these declarations using these pointers.

931
00:31:38,525 --> 00:31:40,249
Now it also turns out,

932
00:31:40,249 --> 00:31:42,019
in fact that course doesn't need to

933
00:31:42,019 --> 00:31:44,180
know any details about student neither.

934
00:31:44,180 --> 00:31:47,029
So we will go ahead

935
00:31:47,029 --> 00:31:48,170
and use an incomplete

936
00:31:48,170 --> 00:31:50,028
STI test specification here.

937
00:31:50,028 --> 00:31:52,970
In general, if you can get away with

938
00:31:52,970 --> 00:31:55,160
using an incomplete type specification,

939
00:31:55,160 --> 00:31:56,074
do so.

940
00:31:56,074 --> 00:31:57,559
If you can get away with

941
00:31:57,559 --> 00:31:59,480
not including the header file and

942
00:31:59,480 --> 00:32:00,740
simply providing

943
00:32:00,740 --> 00:32:02,884
an incomplete type specification.

944
00:32:02,884 --> 00:32:05,148
Do that. One of

945
00:32:05,148 --> 00:32:06,079
the reasons is to break

946
00:32:06,079 --> 00:32:07,279
circular dependencies,

947
00:32:07,279 --> 00:32:08,990
but another reason is

948
00:32:08,990 --> 00:32:12,410
that and it speeds up your compilation.

949
00:32:12,410 --> 00:32:14,209
Enlarge systems.

950
00:32:14,209 --> 00:32:16,128
You don't want to needlessly

951
00:32:16,128 --> 00:32:17,210
include header files.

952
00:32:17,210 --> 00:32:20,159
If you don't have to include a header file.

953
00:32:20,170 --> 00:32:22,880
In a large system, you generally don't want

954
00:32:22,880 --> 00:32:25,069
to do so because you,

955
00:32:25,069 --> 00:32:26,749
it means to combine likes to go look at

956
00:32:26,749 --> 00:32:28,864
that header and deal with stuff.

957
00:32:28,864 --> 00:32:31,038
Now we don't care about multiple

958
00:32:31,038 --> 00:32:32,298
including standard header file.

959
00:32:32,298 --> 00:32:33,739
Standard headers are often

960
00:32:33,739 --> 00:32:35,614
treated differently by the compiler.

961
00:32:35,614 --> 00:32:36,798
And if you include the same

962
00:32:36,798 --> 00:32:38,029
standard header file more

963
00:32:38,029 --> 00:32:39,078
than once directly or

964
00:32:39,078 --> 00:32:40,579
indirectly, that's harmless.

965
00:32:40,579 --> 00:32:41,778
If you include a header, you

966
00:32:41,778 --> 00:32:43,038
don't really need that.

967
00:32:43,038 --> 00:32:44,464
That's, that's harmless.

968
00:32:44,464 --> 00:32:46,894
A standard header that you don't need.

969
00:32:46,894 --> 00:32:49,400
So including iostream, if you don't

970
00:32:49,400 --> 00:32:51,845
really ever use it, that's harmless.

971
00:32:51,845 --> 00:32:55,624
All right, so we've now solved the problem.

972
00:32:55,624 --> 00:32:57,545
We broken the circular dependency.

973
00:32:57,545 --> 00:32:59,179
In fact, we've broken

974
00:32:59,179 --> 00:33:00,903
at both places, so that's fine.

975
00:33:00,903 --> 00:33:04,130
I'm including student dot h says,

976
00:33:04,130 --> 00:33:05,630
Okay, Have I been here before?

977
00:33:05,630 --> 00:33:06,439
No, I haven't.

978
00:33:06,439 --> 00:33:08,989
So let's, let's define the symbol.

979
00:33:08,989 --> 00:33:10,025
O.

980
00:33:10,025 --> 00:33:12,423
Course is the name of the type. Okay, Fine.

981
00:33:12,423 --> 00:33:13,939
Thank you for telling me that.

982
00:33:13,939 --> 00:33:16,608
Let's let's now see

983
00:33:16,608 --> 00:33:18,170
what it is to be a student.

984
00:33:18,170 --> 00:33:19,909
Oh, why know the name of course?

985
00:33:19,909 --> 00:33:21,394
Course is the name of the type. Okay.

986
00:33:21,394 --> 00:33:23,210
So CPS a pointer to a course.

987
00:33:23,210 --> 00:33:25,009
Oh, I know what a course is.

988
00:33:25,009 --> 00:33:26,000
Why don't know details,

989
00:33:26,000 --> 00:33:27,108
but I know it's the name of the type.

990
00:33:27,108 --> 00:33:28,818
So, oh, you're declaring an array of

991
00:33:28,818 --> 00:33:31,369
ten pointers to courses. That's fine.

992
00:33:31,369 --> 00:33:33,199
Okay, So that's fine.

993
00:33:33,199 --> 00:33:34,430
We know is going to be 40.

994
00:33:34,430 --> 00:33:36,200
So the compiler is happy.

995
00:33:36,200 --> 00:33:38,179
And now we know what a student is.

996
00:33:38,179 --> 00:33:41,000
Now when we include course dot h.

997
00:33:41,000 --> 00:33:42,769
Have we seen this before?

998
00:33:42,769 --> 00:33:43,398
It no.

999
00:33:43,398 --> 00:33:45,364
So let's define the symbol

1000
00:33:45,364 --> 00:33:47,794
o students the name of a type.

1001
00:33:47,794 --> 00:33:49,429
Well, I've already seen

1002
00:33:49,429 --> 00:33:51,200
the complete declaration of student.

1003
00:33:51,200 --> 00:33:53,105
I already know that.

1004
00:33:53,105 --> 00:33:54,753
Is that a problem?

1005
00:33:54,753 --> 00:33:56,914
No, because as I said,

1006
00:33:56,914 --> 00:33:58,549
you can have

1007
00:33:58,549 --> 00:34:01,338
multiple incomplete types us vacation.

1008
00:34:01,338 --> 00:34:04,308
So so if we've already seen that student,

1009
00:34:04,308 --> 00:34:06,273
here's the full student declaration.

1010
00:34:06,273 --> 00:34:07,640
And now I'm going to tell

1011
00:34:07,640 --> 00:34:09,393
you students the name of a type.

1012
00:34:09,393 --> 00:34:10,550
That's harmless.

1013
00:34:10,550 --> 00:34:11,599
Okay?

1014
00:34:11,599 --> 00:34:13,250
And so we know students

1015
00:34:13,250 --> 00:34:14,750
the name of a type already anyway,

1016
00:34:14,750 --> 00:34:16,130
we process course, we see

1017
00:34:16,130 --> 00:34:17,719
the pointer to a student, that's fine.

1018
00:34:17,719 --> 00:34:19,353
We know what student is,

1019
00:34:19,353 --> 00:34:21,378
we know how big the roster is.

1020
00:34:21,378 --> 00:34:23,659
It's 1000 times the size of a pointer.

1021
00:34:23,659 --> 00:34:25,610
Okay, and when we're done with this,

1022
00:34:25,610 --> 00:34:27,244
we now know what a course is.

1023
00:34:27,244 --> 00:34:30,409
And so the rest of this is fine.

1024
00:34:30,409 --> 00:34:34,398
Now, in myapp dot cpp,

1025
00:34:34,398 --> 00:34:39,333
could I say class student,

1026
00:34:39,333 --> 00:34:41,643
and just leave it at that?

1027
00:34:41,643 --> 00:34:45,239
And class course and just leave it at that.

1028
00:34:46,480 --> 00:34:48,559
No.

1029
00:34:48,559 --> 00:34:51,409
No, I can't because this

1030
00:34:51,409 --> 00:34:53,659
won't compile because although okay,

1031
00:34:53,659 --> 00:34:54,619
we know students the name

1032
00:34:54,619 --> 00:34:55,458
of the type we're talking

1033
00:34:55,458 --> 00:34:56,449
about a pointer we know of

1034
00:34:56,449 --> 00:34:57,590
course is the name of a type.

1035
00:34:57,590 --> 00:34:58,190
We're talking about

1036
00:34:58,190 --> 00:34:59,719
a pointer that's harmless.

1037
00:34:59,719 --> 00:35:02,838
We are depending here on knowing

1038
00:35:02,838 --> 00:35:04,188
that student has

1039
00:35:04,188 --> 00:35:06,605
a member function called enroll.

1040
00:35:06,605 --> 00:35:08,630
And you don't know that from

1041
00:35:08,630 --> 00:35:11,208
this all I know student the name of a type.

1042
00:35:11,208 --> 00:35:12,498
I don't know anything about what

1043
00:35:12,498 --> 00:35:13,849
member functions it has.

1044
00:35:13,849 --> 00:35:16,114
So now we'd have to,

1045
00:35:16,114 --> 00:35:19,289
we'd have to fully include student dot h.

1046
00:35:19,809 --> 00:35:23,885
Now, for just this much,

1047
00:35:23,885 --> 00:35:25,309
we actually could get away

1048
00:35:25,309 --> 00:35:26,764
with saying class course,

1049
00:35:26,764 --> 00:35:28,878
because all we're saying is, hey,

1050
00:35:28,878 --> 00:35:30,980
this function takes in a pointer to

1051
00:35:30,980 --> 00:35:32,449
a course and passes

1052
00:35:32,449 --> 00:35:34,219
it on to the enroll function,

1053
00:35:34,219 --> 00:35:36,349
which wants a pointer to a course.

1054
00:35:36,349 --> 00:35:39,005
So does this code itself

1055
00:35:39,005 --> 00:35:41,539
need to know anything more about course,

1056
00:35:41,539 --> 00:35:42,559
what member functions it

1057
00:35:42,559 --> 00:35:43,998
has or how big it is now.

1058
00:35:43,998 --> 00:35:45,394
Now we don't actually need that.

1059
00:35:45,394 --> 00:35:46,759
So we could just get

1060
00:35:46,759 --> 00:35:48,079
away with saying class course.

1061
00:35:48,079 --> 00:35:50,643
But you know,

1062
00:35:50,643 --> 00:35:54,110
in a CPP file you're less persnickety about,

1063
00:35:54,110 --> 00:35:55,519
about don't include things

1064
00:35:55,519 --> 00:35:57,153
you don't really have to.

1065
00:35:57,153 --> 00:35:59,420
If you go ahead in the CPP file

1066
00:35:59,420 --> 00:36:01,280
and say include course

1067
00:36:01,280 --> 00:36:05,268
dot h. That's, that's okay.

1068
00:36:05,268 --> 00:36:06,528
Nobody's going, He's

1069
00:36:06,528 --> 00:36:08,639
going to yell at you for doing that.

1070
00:36:09,639 --> 00:36:11,164
Okay.

1071
00:36:11,164 --> 00:36:12,829
So that's the that's

1072
00:36:12,829 --> 00:36:14,360
the circular dependency issue

1073
00:36:14,360 --> 00:36:15,798
that I wanted to make sure

1074
00:36:15,798 --> 00:36:17,690
we were we were good on here.

1075
00:36:17,690 --> 00:36:20,539
And so when do

1076
00:36:20,539 --> 00:36:23,329
you when do you have to include

1077
00:36:23,329 --> 00:36:26,659
the header file and when can you get away

1078
00:36:26,659 --> 00:36:28,039
with simply

1079
00:36:28,039 --> 00:36:30,289
using an incomplete type specification?

1080
00:36:30,289 --> 00:36:32,418
And so here's, here's when you

1081
00:36:32,418 --> 00:36:34,833
can get away with just

1082
00:36:34,833 --> 00:36:36,800
using an incomplete type specification

1083
00:36:36,800 --> 00:36:38,119
instead of having to include

1084
00:36:38,119 --> 00:36:39,559
the whole federal header file.

1085
00:36:39,559 --> 00:36:42,199
The basic principle is if

1086
00:36:42,199 --> 00:36:43,579
the compiler needs to

1087
00:36:43,579 --> 00:36:46,235
know some details about the type,

1088
00:36:46,235 --> 00:36:48,559
then you'll have to include the header file.

1089
00:36:48,559 --> 00:36:50,570
If all it needs to know is it's the name of

1090
00:36:50,570 --> 00:36:51,590
a type you can get

1091
00:36:51,590 --> 00:36:53,315
away without, without that.

1092
00:36:53,315 --> 00:36:55,175
So when do we have to know the detail?

1093
00:36:55,175 --> 00:36:56,059
What does the Bible have to know

1094
00:36:56,059 --> 00:36:57,438
the details about a time?

1095
00:36:57,438 --> 00:36:59,420
Well, if you declare a data member,

1096
00:36:59,420 --> 00:37:00,920
That's of that time.

1097
00:37:00,920 --> 00:37:02,914
Not a pointer, not a reference.

1098
00:37:02,914 --> 00:37:04,818
Empty eclectic, Claire data member, That's,

1099
00:37:04,818 --> 00:37:06,364
that's of that type,

1100
00:37:06,364 --> 00:37:09,048
then the compiler has to know how big it is.

1101
00:37:09,048 --> 00:37:11,045
If you declare a container

1102
00:37:11,045 --> 00:37:13,474
of those actual objects.

1103
00:37:13,474 --> 00:37:18,018
So like an array of objects of that type,

1104
00:37:18,018 --> 00:37:19,684
then it has to now pointers now.

1105
00:37:19,684 --> 00:37:21,829
But, but an array, yes.

1106
00:37:21,829 --> 00:37:23,449
If you go ahead and

1107
00:37:23,449 --> 00:37:25,248
declare an object of that type,

1108
00:37:25,248 --> 00:37:26,090
it has to know

1109
00:37:26,090 --> 00:37:27,739
about that tie because I have to know what

1110
00:37:27,739 --> 00:37:29,088
Constructors constructors

1111
00:37:29,088 --> 00:37:30,659
are available for that type.

1112
00:37:30,659 --> 00:37:32,875
And if you use a member, you have to know.

1113
00:37:32,875 --> 00:37:35,798
So let's see here. If I have

1114
00:37:35,798 --> 00:37:37,119
a block class and I have

1115
00:37:37,119 --> 00:37:40,088
some data members that are,

1116
00:37:40,088 --> 00:37:41,798
here is a data member that is

1117
00:37:41,798 --> 00:37:43,525
an object of type foo.

1118
00:37:43,525 --> 00:37:45,400
So the compiler has to know how big it

1119
00:37:45,400 --> 00:37:47,199
is and to know how big a foo

1120
00:37:47,199 --> 00:37:48,009
is and has to see

1121
00:37:48,009 --> 00:37:49,179
the whole Declaration of food

1122
00:37:49,179 --> 00:37:51,070
and also whose data members are.

1123
00:37:51,070 --> 00:37:53,574
We have an array of 10 foo objects.

1124
00:37:53,574 --> 00:37:54,789
Same thing, we'd need to

1125
00:37:54,789 --> 00:37:56,230
know how big a foo is.

1126
00:37:56,230 --> 00:37:57,730
We, I'm talking about vectors yet

1127
00:37:57,730 --> 00:37:58,869
if we have a vector of foo,

1128
00:37:58,869 --> 00:38:00,009
it needs to know that it's a

1129
00:38:00,009 --> 00:38:01,164
collection of foo objects.

1130
00:38:01,164 --> 00:38:03,083
And so, and so we need that.

1131
00:38:03,083 --> 00:38:05,019
On the other hand, here we

1132
00:38:05,019 --> 00:38:06,969
only have pointers to F2s.

1133
00:38:06,969 --> 00:38:07,929
And since the compiler knows

1134
00:38:07,929 --> 00:38:09,023
how big a pointer is,

1135
00:38:09,023 --> 00:38:11,588
we can get away with just saying class foo.

1136
00:38:11,588 --> 00:38:13,344
We don't have to include the header file.

1137
00:38:13,344 --> 00:38:17,048
For just the prototype of a function,

1138
00:38:17,048 --> 00:38:20,469
you also can get away with saying class foo.

1139
00:38:20,469 --> 00:38:22,554
Well, certainly we know,

1140
00:38:22,554 --> 00:38:24,458
yeah, sure there's a pointer to a foo.

1141
00:38:24,458 --> 00:38:27,025
It's also true for a reference to a foo.

1142
00:38:27,025 --> 00:38:28,329
The compiler doesn't know

1143
00:38:28,329 --> 00:38:30,460
any details about the type.

1144
00:38:30,460 --> 00:38:34,253
And for a parameter of this type,

1145
00:38:34,253 --> 00:38:36,130
not a pointer, not a reference

1146
00:38:36,130 --> 00:38:37,824
but a parameter, the food type.

1147
00:38:37,824 --> 00:38:41,213
If all you're doing is having the prototype.

1148
00:38:41,213 --> 00:38:44,005
You don't need the full class declaration.

1149
00:38:44,005 --> 00:38:46,148
You say, well, wait a minute, passing

1150
00:38:46,148 --> 00:38:48,610
by value means copying.

1151
00:38:48,610 --> 00:38:50,019
Doesn't the compiler have to know how

1152
00:38:50,019 --> 00:38:51,730
big it is to copy it?

1153
00:38:51,730 --> 00:38:53,650
Not in the prototype.

1154
00:38:53,650 --> 00:38:58,248
In the prototype, we're not actually calling

1155
00:38:58,248 --> 00:38:59,224
the function and neither

1156
00:38:59,224 --> 00:39:00,320
are implementing the function and

1157
00:39:00,320 --> 00:39:01,369
needing to know how to

1158
00:39:01,369 --> 00:39:02,989
copy it, then how big it is.

1159
00:39:02,989 --> 00:39:05,750
It's just saying when you call this function,

1160
00:39:05,750 --> 00:39:06,708
you can go ahead and pass it

1161
00:39:06,708 --> 00:39:08,135
by value and that's okay.

1162
00:39:08,135 --> 00:39:11,179
Now, if we implement the function,

1163
00:39:11,179 --> 00:39:13,579
then yes, by implementing

1164
00:39:13,579 --> 00:39:14,418
the function that takes

1165
00:39:14,418 --> 00:39:15,590
an argument pass by value,

1166
00:39:15,590 --> 00:39:17,119
we got to include the header file,

1167
00:39:17,119 --> 00:39:18,873
declaring a local variable

1168
00:39:18,873 --> 00:39:19,938
of that type got to

1169
00:39:19,938 --> 00:39:21,378
include the header file because it

1170
00:39:21,378 --> 00:39:23,164
has to know how big this variable is.

1171
00:39:23,164 --> 00:39:25,398
If, if the food type has

1172
00:39:25,398 --> 00:39:27,920
some members like a Glebe function,

1173
00:39:27,920 --> 00:39:30,320
then the compiler has to know that

1174
00:39:30,320 --> 00:39:31,548
there is such a thing as a grep

1175
00:39:31,548 --> 00:39:32,750
function for the food types.

1176
00:39:32,750 --> 00:39:34,460
So we have to include the header file.

1177
00:39:34,460 --> 00:39:36,034
Okay, So that's a,

1178
00:39:36,034 --> 00:39:37,849
that's a summary of the rules.

1179
00:39:37,849 --> 00:39:40,039
Rules there. So here's

1180
00:39:40,039 --> 00:39:41,614
a question about circular dependencies.

1181
00:39:41,614 --> 00:39:43,458
When, if we're deciding,

1182
00:39:43,458 --> 00:39:45,650
you know, we gotta break circular dependency.

1183
00:39:45,650 --> 00:39:46,760
Well, what if we're

1184
00:39:46,760 --> 00:39:47,780
not dealing with pointers?

1185
00:39:47,780 --> 00:39:50,268
What if we're dealing with actual objects?

1186
00:39:50,268 --> 00:39:52,159
So let's see what that would look

1187
00:39:52,159 --> 00:39:54,574
like and why that is not a problem.

1188
00:39:54,574 --> 00:39:56,809
So let's say an object has a

1189
00:39:56,809 --> 00:39:59,570
biotic inside it and be

1190
00:39:59,570 --> 00:40:03,170
object as maybe an ENT number

1191
00:40:03,170 --> 00:40:04,923
and an a object inside.

1192
00:40:04,923 --> 00:40:06,108
So we have struct data

1193
00:40:06,108 --> 00:40:08,628
has a B object inside it struck BY,

1194
00:40:08,628 --> 00:40:10,833
that has an int and an a object inside.

1195
00:40:10,833 --> 00:40:15,438
Now, of course for this to compile,

1196
00:40:15,438 --> 00:40:18,813
we need the compiler has to see the name B.

1197
00:40:18,813 --> 00:40:22,369
So you say, Well, kinda do that.

1198
00:40:22,369 --> 00:40:24,273
No, that's, that's a data member

1199
00:40:24,273 --> 00:40:26,059
of type B, not a pointer to a B.

1200
00:40:26,059 --> 00:40:28,760
So I asked to see the whole Declaration 0.

1201
00:40:28,760 --> 00:40:29,614
Then I guess we got to

1202
00:40:29,614 --> 00:40:31,010
put the declaration of a,

1203
00:40:31,010 --> 00:40:32,480
of a, but we put

1204
00:40:32,480 --> 00:40:34,219
the full declaration to be up above a.

1205
00:40:34,219 --> 00:40:35,869
We have the same problem here.

1206
00:40:35,869 --> 00:40:38,809
So you can't solve the problem here.

1207
00:40:38,809 --> 00:40:42,304
You cannot have a contain a b object,

1208
00:40:42,304 --> 00:40:44,373
and B contain an object.

1209
00:40:44,373 --> 00:40:46,009
There's no way to order

1210
00:40:46,009 --> 00:40:48,483
those declarations to make it work and no,

1211
00:40:48,483 --> 00:40:49,820
using any complete text

1212
00:40:49,820 --> 00:40:52,130
specification will solve the problem.

1213
00:40:52,130 --> 00:40:55,625
But I'll say, Well,

1214
00:40:55,625 --> 00:40:56,929
but you wouldn't want to do this

1215
00:40:56,929 --> 00:40:58,715
anyway. You can't.

1216
00:40:58,715 --> 00:41:00,259
This would be illegal anyway,

1217
00:41:00,259 --> 00:41:02,059
even if the compiler did allow you somehow

1218
00:41:02,059 --> 00:41:04,235
to talk about before we saw the definition.

1219
00:41:04,235 --> 00:41:05,704
Because think about it.

1220
00:41:05,704 --> 00:41:08,088
What does an a object look like?

1221
00:41:08,088 --> 00:41:10,789
If I declare a variable a of type a,

1222
00:41:10,789 --> 00:41:12,664
a little lowercase a type a.

1223
00:41:12,664 --> 00:41:16,128
This object is an object layout there.

1224
00:41:16,128 --> 00:41:17,809
Now capital a object has

1225
00:41:17,809 --> 00:41:20,014
inside it just one data member,

1226
00:41:20,014 --> 00:41:21,920
which is NB object.

1227
00:41:21,920 --> 00:41:26,750
Now if the object has inside it integer am.

1228
00:41:26,750 --> 00:41:30,108
Object which hasn't side of the object,

1229
00:41:30,108 --> 00:41:33,994
which hasn't signed integer and an, a object.

1230
00:41:33,994 --> 00:41:36,259
And, and so it looks like we got some kind

1231
00:41:36,259 --> 00:41:38,778
of infinite problem here I am.

1232
00:41:38,778 --> 00:41:40,280
Here's a simple way to ask

1233
00:41:40,280 --> 00:41:42,588
how big is an a object?

1234
00:41:42,588 --> 00:41:44,329
So let's see.

1235
00:41:44,329 --> 00:41:46,340
The size of an a object.

1236
00:41:46,340 --> 00:41:47,449
Since it contains has to

1237
00:41:47,449 --> 00:41:48,559
be object is going to be

1238
00:41:48,559 --> 00:41:51,184
presumably the size of the B option, okay?

1239
00:41:51,184 --> 00:41:53,014
And the size of the object,

1240
00:41:53,014 --> 00:41:56,824
let's say integers or four bytes long is 4.

1241
00:41:56,824 --> 00:41:58,519
Plus the size may happen.

1242
00:41:58,519 --> 00:41:59,375
Okay?

1243
00:41:59,375 --> 00:42:01,579
So we can substitute

1244
00:42:01,579 --> 00:42:02,659
size of B and we find that

1245
00:42:02,659 --> 00:42:04,219
the size of an a object,

1246
00:42:04,219 --> 00:42:06,260
besides money object, is equal to

1247
00:42:06,260 --> 00:42:09,239
4 plus the size of an object.

1248
00:42:09,809 --> 00:42:12,474
So solve that equation.

1249
00:42:12,474 --> 00:42:15,353
How many bytes does AnyObject occupy?

1250
00:42:15,353 --> 00:42:17,409
Well, the solution to this

1251
00:42:17,409 --> 00:42:18,518
is basically

1252
00:42:18,518 --> 00:42:20,079
the only solution here is infinite.

1253
00:42:20,079 --> 00:42:21,608
If x is infinite, then

1254
00:42:21,608 --> 00:42:23,800
infinity is equal to 4k plus there.

1255
00:42:23,800 --> 00:42:25,778
So you'd have an infinite

1256
00:42:25,778 --> 00:42:27,849
size object that's not allowed.

1257
00:42:27,849 --> 00:42:30,864
All right, so this situation will not occur.

1258
00:42:30,864 --> 00:42:32,349
So now I want to go on to

1259
00:42:32,349 --> 00:42:33,639
our next major topic area,

1260
00:42:33,639 --> 00:42:35,034
which is resource management.

1261
00:42:35,034 --> 00:42:37,329
Now, what do I mean by resource?

1262
00:42:37,329 --> 00:42:39,489
A resource is something that the program

1263
00:42:39,489 --> 00:42:42,639
needs to use in order to do its job.

1264
00:42:42,639 --> 00:42:44,079
It's rather like the use of

1265
00:42:44,079 --> 00:42:46,539
the word resource in economics.

1266
00:42:46,539 --> 00:42:49,688
A resource is something that a person or

1267
00:42:49,688 --> 00:42:53,525
a company or a society wants or needs.

1268
00:42:53,525 --> 00:42:55,699
Things like food or oil

1269
00:42:55,699 --> 00:42:59,449
or money or land, or labor.

1270
00:42:59,449 --> 00:43:02,059
In any event, if a resource is unlimited,

1271
00:43:02,059 --> 00:43:03,835
there's no need to manage it.

1272
00:43:03,835 --> 00:43:05,360
In a computer context.

1273
00:43:05,360 --> 00:43:07,309
For example, if we have

1274
00:43:07,309 --> 00:43:08,480
an infinite amount of memory

1275
00:43:08,480 --> 00:43:09,949
available, we always have as much.

1276
00:43:09,949 --> 00:43:11,059
Or even if not literally,

1277
00:43:11,059 --> 00:43:12,079
infant will always have

1278
00:43:12,079 --> 00:43:14,344
enough memory as much as we might need.

1279
00:43:14,344 --> 00:43:15,858
You could write programs, I

1280
00:43:15,858 --> 00:43:17,599
could be very efficiently

1281
00:43:17,599 --> 00:43:19,295
solved if you had

1282
00:43:19,295 --> 00:43:21,829
an array with a gazillion elements,

1283
00:43:21,829 --> 00:43:23,605
if you had all that space of L,

1284
00:43:23,605 --> 00:43:24,469
you might be able to do things

1285
00:43:24,469 --> 00:43:25,340
more efficiently than if

1286
00:43:25,340 --> 00:43:28,355
you had to run with some limitations.

1287
00:43:28,355 --> 00:43:29,989
So in the case of

1288
00:43:29,989 --> 00:43:31,893
unlimited resources is not interesting.

1289
00:43:31,893 --> 00:43:32,704
There's nothing demand,

1290
00:43:32,704 --> 00:43:33,960
there's no need to manage.

1291
00:43:33,960 --> 00:43:36,534
We're looking at the issues

1292
00:43:36,534 --> 00:43:38,829
involving limited resources,

1293
00:43:38,829 --> 00:43:40,028
things like memory.

1294
00:43:40,028 --> 00:43:41,635
There's only so much memory

1295
00:43:41,635 --> 00:43:45,114
or our processor time.

1296
00:43:45,114 --> 00:43:47,498
If you're on a computer system with

1297
00:43:47,498 --> 00:43:48,909
one processor that can execute

1298
00:43:48,909 --> 00:43:51,023
instructions at a certain rate,

1299
00:43:51,023 --> 00:43:52,599
that's kind of a limitation.

1300
00:43:52,599 --> 00:43:54,760
And if there's a lot

1301
00:43:54,760 --> 00:43:56,289
of computation that you want to get done

1302
00:43:56,289 --> 00:43:56,768
or you have

1303
00:43:56,768 --> 00:43:58,358
multiple programs that are running

1304
00:43:58,358 --> 00:43:59,469
simultaneously and

1305
00:43:59,469 --> 00:44:00,954
there's only one processor,

1306
00:44:00,954 --> 00:44:02,920
how do you allocate the time of the processor

1307
00:44:02,920 --> 00:44:04,989
from between all the programs.

1308
00:44:04,989 --> 00:44:06,775
So there's a limitation,

1309
00:44:06,775 --> 00:44:09,699
limitations on how much disk space you have,

1310
00:44:09,699 --> 00:44:13,733
limitations on how many files

1311
00:44:13,733 --> 00:44:15,190
your program might have

1312
00:44:15,190 --> 00:44:16,635
open at the same time.

1313
00:44:16,635 --> 00:44:17,929
You have limitations on

1314
00:44:17,929 --> 00:44:20,824
how many network connections you might have.

1315
00:44:20,824 --> 00:44:23,690
At the same time, the operating system will

1316
00:44:23,690 --> 00:44:26,358
put limits on limits like these.

1317
00:44:26,358 --> 00:44:29,570
So the, the issue of management then is,

1318
00:44:29,570 --> 00:44:32,269
is you've gotta be aware of these issues.

1319
00:44:32,269 --> 00:44:33,963
You've gotta be aware of these limitations

1320
00:44:33,963 --> 00:44:36,829
and write your programs in

1321
00:44:36,829 --> 00:44:39,318
a way that don't ignore

1322
00:44:39,318 --> 00:44:40,579
those issues because they will

1323
00:44:40,579 --> 00:44:42,018
come up and bite you at some point.

1324
00:44:42,018 --> 00:44:42,994
At some point you'll,

1325
00:44:42,994 --> 00:44:44,855
you'll run into a problem.

1326
00:44:44,855 --> 00:44:48,318
So for example, maybe I have a program

1327
00:44:48,318 --> 00:44:51,528
that is going to process 1000 files.

1328
00:44:51,528 --> 00:44:53,059
And what my program's going to

1329
00:44:53,059 --> 00:44:54,664
do is work like this.

1330
00:44:54,664 --> 00:44:57,050
It's going to open a file.

1331
00:44:57,050 --> 00:44:59,059
What brands yourself. So I'm going to open

1332
00:44:59,059 --> 00:45:01,744
a file, process it,

1333
00:45:01,744 --> 00:45:03,724
then I'm going to open the next file,

1334
00:45:03,724 --> 00:45:05,119
process it, and then open

1335
00:45:05,119 --> 00:45:06,994
the next file, process it, et cetera.

1336
00:45:06,994 --> 00:45:08,030
That's my algorithm.

1337
00:45:08,030 --> 00:45:09,590
Now the problem is if

1338
00:45:09,590 --> 00:45:11,239
my operating system as a limit

1339
00:45:11,239 --> 00:45:13,429
on how many open files

1340
00:45:13,429 --> 00:45:15,003
I can have in my program at a time.

1341
00:45:15,003 --> 00:45:18,155
Let's say it's 128.

1342
00:45:18,155 --> 00:45:20,719
Usually pick some power to, let's say,

1343
00:45:20,719 --> 00:45:21,514
and let's say it's a 100,

1344
00:45:21,514 --> 00:45:22,398
There's a limited let's say there's

1345
00:45:22,398 --> 00:45:24,335
a little bit of a 100 open files I can have.

1346
00:45:24,335 --> 00:45:25,849
Well, what's going to happen

1347
00:45:25,849 --> 00:45:26,900
is if I open a file,

1348
00:45:26,900 --> 00:45:28,130
use it, open a file,

1349
00:45:28,130 --> 00:45:30,378
use it, open a file, use it.

1350
00:45:30,378 --> 00:45:32,418
After I've opened a 100 files.

1351
00:45:32,418 --> 00:45:35,135
When I open a 100 file number a 100 one,

1352
00:45:35,135 --> 00:45:38,945
the open I'll fake am and so I got a problem.

1353
00:45:38,945 --> 00:45:41,869
So usually if there's

1354
00:45:41,869 --> 00:45:43,099
some kind of resource and

1355
00:45:43,099 --> 00:45:44,764
a way to acquire that resource.

1356
00:45:44,764 --> 00:45:46,324
In the case of files,

1357
00:45:46,324 --> 00:45:47,898
opening the file is,

1358
00:45:47,898 --> 00:45:50,465
among other things, acquiring, you know,

1359
00:45:50,465 --> 00:45:54,320
the the the open file descriptor information,

1360
00:45:54,320 --> 00:45:55,639
et cetera, for that file,

1361
00:45:55,639 --> 00:45:57,559
if there's only a finite amount of that,

1362
00:45:57,559 --> 00:45:59,509
there needs to be a one, needs

1363
00:45:59,509 --> 00:46:01,264
to be a way to release the resources,

1364
00:46:01,264 --> 00:46:02,929
give it back to the operating system.

1365
00:46:02,929 --> 00:46:05,043
So you can open a file.

1366
00:46:05,043 --> 00:46:06,170
You can close the file.

1367
00:46:06,170 --> 00:46:07,443
When you close a file,

1368
00:46:07,443 --> 00:46:09,394
it's no longer open that releases

1369
00:46:09,394 --> 00:46:10,489
the resource that

1370
00:46:10,489 --> 00:46:12,349
the operating system is holding for the five.

1371
00:46:12,349 --> 00:46:16,264
So a correct implementation would be,

1372
00:46:16,264 --> 00:46:18,139
would be if, if once,

1373
00:46:18,139 --> 00:46:19,608
if once I process to file,

1374
00:46:19,608 --> 00:46:21,259
I don't have to look at it again.

1375
00:46:21,259 --> 00:46:23,000
Correct implementation would simply

1376
00:46:23,000 --> 00:46:24,724
be opened a file,

1377
00:46:24,724 --> 00:46:26,809
use it, close the file,

1378
00:46:26,809 --> 00:46:28,519
open a file, use it.

1379
00:46:28,519 --> 00:46:31,009
Close the file, open a file, use it closer.

1380
00:46:31,009 --> 00:46:32,315
By that way.

1381
00:46:32,315 --> 00:46:34,324
I have at most one file

1382
00:46:34,324 --> 00:46:35,869
open at any given time.

1383
00:46:35,869 --> 00:46:37,068
So I'm not going to run out, I'm not

1384
00:46:37,068 --> 00:46:38,224
gonna hit my 100 file limit.

1385
00:46:38,224 --> 00:46:39,380
I can go ahead and process

1386
00:46:39,380 --> 00:46:41,478
a 1000 files, 10 thousand files,

1387
00:46:41,478 --> 00:46:43,369
because I'm never going to

1388
00:46:43,369 --> 00:46:45,528
have more than one file open at a time,

1389
00:46:45,528 --> 00:46:47,358
so I never come close to that 100 file

1390
00:46:47,358 --> 00:46:49,880
it on an open file descriptors.

1391
00:46:49,880 --> 00:46:52,730
So there's an example of a writing code

1392
00:46:52,730 --> 00:46:54,260
that manages the resource

1393
00:46:54,260 --> 00:46:56,780
of open files correctly.

1394
00:46:56,780 --> 00:47:01,085
So there's lots and lots of resources you,

1395
00:47:01,085 --> 00:47:02,719
one another one would be,

1396
00:47:02,719 --> 00:47:07,833
say, exclusive access to a database record.

1397
00:47:07,833 --> 00:47:10,248
So you'll have a situation,

1398
00:47:10,248 --> 00:47:12,769
for example, where I have a bank account,

1399
00:47:12,769 --> 00:47:14,945
let's say it has a $100 in

1400
00:47:14,945 --> 00:47:20,210
and say two people share the same account.

1401
00:47:20,210 --> 00:47:22,175
They both have ATM cards.

1402
00:47:22,175 --> 00:47:24,693
They both go up to an ATM machine

1403
00:47:24,693 --> 00:47:26,208
at two different our

1404
00:47:26,208 --> 00:47:27,949
ATM machines and into parts of the city.

1405
00:47:27,949 --> 00:47:30,079
Let's say they both

1406
00:47:30,079 --> 00:47:31,954
take their cards in it about the same time.

1407
00:47:31,954 --> 00:47:34,804
They both asked to withdraw a $100.

1408
00:47:34,804 --> 00:47:35,719
Okay?

1409
00:47:35,719 --> 00:47:38,570
So one thing that

1410
00:47:38,570 --> 00:47:40,159
might happen is the way the ATM machine

1411
00:47:40,159 --> 00:47:41,375
works as it does the following.

1412
00:47:41,375 --> 00:47:42,784
Oh, you want to withdraw a 100 adults?

1413
00:47:42,784 --> 00:47:45,079
So what I'm gonna do, go check,

1414
00:47:45,079 --> 00:47:47,000
go get your your current balance,

1415
00:47:47,000 --> 00:47:48,318
check it to make sure you have

1416
00:47:48,318 --> 00:47:50,510
enough to withdraw that amount.

1417
00:47:50,510 --> 00:47:54,034
If so, then I will dispense you the cache.

1418
00:47:54,034 --> 00:47:55,489
I will subtract that amount from your

1419
00:47:55,489 --> 00:47:57,905
balanced and store it back in the database.

1420
00:47:57,905 --> 00:48:00,108
And so you can see there's a problem here.

1421
00:48:00,108 --> 00:48:02,315
If this machine says,

1422
00:48:02,315 --> 00:48:05,239
let me get the balance which is a $100.

1423
00:48:05,239 --> 00:48:06,528
Okay?

1424
00:48:06,528 --> 00:48:08,239
You want a $100, that's fine.

1425
00:48:08,239 --> 00:48:09,498
So I'm going to dispense

1426
00:48:09,498 --> 00:48:10,969
the cache and I'm going to subtract a

1427
00:48:10,969 --> 00:48:12,139
100 from this before it

1428
00:48:12,139 --> 00:48:13,369
gets a chance to write back

1429
00:48:13,369 --> 00:48:15,994
to 0 because your balance is now empty.

1430
00:48:15,994 --> 00:48:17,329
The other one says,

1431
00:48:17,329 --> 00:48:19,429
you know, starts ovens and says, Oh,

1432
00:48:19,429 --> 00:48:20,539
I'm going to get the balance which

1433
00:48:20,539 --> 00:48:21,753
is still a 100 up here,

1434
00:48:21,753 --> 00:48:23,885
the database, I'll get the 100,

1435
00:48:23,885 --> 00:48:26,208
you know, you've got it and you want a $100.

1436
00:48:26,208 --> 00:48:27,199
Final, give it to you,

1437
00:48:27,199 --> 00:48:28,278
I'll set the thing desert.

1438
00:48:28,278 --> 00:48:29,210
Meanwhile, this guy gets

1439
00:48:29,210 --> 00:48:30,079
around to writing back to

1440
00:48:30,079 --> 00:48:30,829
0 and this guy gets

1441
00:48:30,829 --> 00:48:32,014
rendered writing back Zara,

1442
00:48:32,014 --> 00:48:35,239
and both of you got a $100 and

1443
00:48:35,239 --> 00:48:36,768
the account balance is now 0

1444
00:48:36,768 --> 00:48:39,364
and you wind bank loses.

1445
00:48:39,364 --> 00:48:40,789
So, so there's gotta be

1446
00:48:40,789 --> 00:48:42,875
some kind of exclusive access.

1447
00:48:42,875 --> 00:48:44,659
Typically that's going to be some kind of

1448
00:48:44,659 --> 00:48:46,579
idea of a lock that you have to

1449
00:48:46,579 --> 00:48:49,128
acquire a lock and release the lock

1450
00:48:49,128 --> 00:48:53,105
so that the right transaction is 0.

1451
00:48:53,105 --> 00:48:55,070
I'm going to be working math and I kept,

1452
00:48:55,070 --> 00:48:57,574
let me acquire a lock on that account,

1453
00:48:57,574 --> 00:48:59,900
which means the database will say,

1454
00:48:59,900 --> 00:49:01,804
if somebody's got the lock,

1455
00:49:01,804 --> 00:49:03,528
I'm not going to let anybody else lock

1456
00:49:03,528 --> 00:49:05,614
this account yet or access anything on.

1457
00:49:05,614 --> 00:49:09,409
So if I say I'm going OK in the record,

1458
00:49:09,409 --> 00:49:10,820
the database says nobody's

1459
00:49:10,820 --> 00:49:12,349
got the lock in that record. Okay.

1460
00:49:12,349 --> 00:49:13,699
You've got the lock.

1461
00:49:13,699 --> 00:49:15,139
I will not let anybody

1462
00:49:15,139 --> 00:49:17,570
else acquire

1463
00:49:17,570 --> 00:49:18,963
the lock for this this right. Okay.

1464
00:49:18,963 --> 00:49:19,699
So fine.

1465
00:49:19,699 --> 00:49:21,320
I've got the lock so I can get the balance.

1466
00:49:21,320 --> 00:49:22,550
I do my thing while I'm

1467
00:49:22,550 --> 00:49:23,840
in the middle of doing this thing.

1468
00:49:23,840 --> 00:49:25,460
This guy says, You know,

1469
00:49:25,460 --> 00:49:27,755
I'd like to try to get that record.

1470
00:49:27,755 --> 00:49:30,438
Davis says, Well, you gotta lock first.

1471
00:49:30,438 --> 00:49:31,309
I'm sorry.

1472
00:49:31,309 --> 00:49:33,050
I would like to acquire the lock.

1473
00:49:33,050 --> 00:49:34,699
The database says, Well, you got to wait,

1474
00:49:34,699 --> 00:49:36,048
cuz somebody else has the law.

1475
00:49:36,048 --> 00:49:37,594
So this guy has to wait.

1476
00:49:37,594 --> 00:49:40,550
Once this guy has taken up a $100,

1477
00:49:40,550 --> 00:49:42,304
written back a 0 balance,

1478
00:49:42,304 --> 00:49:43,550
it then says, Okay, I'm

1479
00:49:43,550 --> 00:49:45,094
done, release the lock.

1480
00:49:45,094 --> 00:49:46,684
So the database says fine,

1481
00:49:46,684 --> 00:49:47,809
now you've got your lock.

1482
00:49:47,809 --> 00:49:49,940
So so it kept this process

1483
00:49:49,940 --> 00:49:51,440
from doing stuff with

1484
00:49:51,440 --> 00:49:52,954
the record until this one did.

1485
00:49:52,954 --> 00:49:54,800
So this idea of acquiring

1486
00:49:54,800 --> 00:49:55,954
and releasing locks,

1487
00:49:55,954 --> 00:49:57,500
there's only a finite number of blocks you

1488
00:49:57,500 --> 00:49:59,208
can have the submissions involved with that.

1489
00:49:59,208 --> 00:50:00,260
There's another example

1490
00:50:00,260 --> 00:50:02,148
of resources to manage.

1491
00:50:02,148 --> 00:50:03,875
So in our case, the,

1492
00:50:03,875 --> 00:50:06,530
the resource we're going to manage in

1493
00:50:06,530 --> 00:50:07,909
this class that comes up

1494
00:50:07,909 --> 00:50:09,605
over and over again is memory.

1495
00:50:09,605 --> 00:50:11,900
So your machine has

1496
00:50:11,900 --> 00:50:14,224
only a finite amount of memory to give you.

1497
00:50:14,224 --> 00:50:17,809
And you want to

1498
00:50:17,809 --> 00:50:19,068
write applications that don't

1499
00:50:19,068 --> 00:50:19,713
run out of memory.

1500
00:50:19,713 --> 00:50:23,150
So let me, let me go

1501
00:50:23,150 --> 00:50:24,858
through the setup

1502
00:50:24,858 --> 00:50:27,498
for how this is going to work.

1503
00:50:27,498 --> 00:50:30,079
So let's say that.

1504
00:50:30,079 --> 00:50:33,204
Let's say I'd like to do,

1505
00:50:33,204 --> 00:50:36,128
is I guess the easiest way

1506
00:50:36,128 --> 00:50:38,559
to do this is to, because so many,

1507
00:50:38,559 --> 00:50:40,344
so many aspects of memory manager, Art,

1508
00:50:40,344 --> 00:50:42,505
mentor about memory management

1509
00:50:42,505 --> 00:50:44,648
are already handled by the library.

1510
00:50:44,648 --> 00:50:46,659
Let me go back to

1511
00:50:46,659 --> 00:50:48,775
before there was a library doing it for you.

1512
00:50:48,775 --> 00:50:54,373
So let's go back in time, about 30 years.

1513
00:50:54,373 --> 00:50:56,548
So we're back in 990.

1514
00:50:56,548 --> 00:50:59,864
There is no C plus plus Standard.

1515
00:50:59,864 --> 00:51:02,340
Different compiler writers have

1516
00:51:02,340 --> 00:51:03,929
slightly different interpretations of

1517
00:51:03,929 --> 00:51:05,579
what some of the things in C plus plus mean.

1518
00:51:05,579 --> 00:51:08,489
In particular, there's no standard library.

1519
00:51:08,489 --> 00:51:10,755
There's no standard string type.

1520
00:51:10,755 --> 00:51:13,048
Every compiler vendor is writing

1521
00:51:13,048 --> 00:51:14,278
their own string type for you to

1522
00:51:14,278 --> 00:51:15,750
use, to use their library.

1523
00:51:15,750 --> 00:51:17,369
They're all slightly different.

1524
00:51:17,369 --> 00:51:20,309
So here we are, where we're going to provide

1525
00:51:20,309 --> 00:51:21,659
a string type for

1526
00:51:21,659 --> 00:51:23,474
people who aren't using our compiler to use.

1527
00:51:23,474 --> 00:51:24,389
So we're going to write

1528
00:51:24,389 --> 00:51:25,469
a string type and there

1529
00:51:25,469 --> 00:51:27,719
is no standard C plus plus string type.

1530
00:51:27,719 --> 00:51:28,784
So that's the environment

1531
00:51:28,784 --> 00:51:30,193
this example's going to be.

1532
00:51:30,193 --> 00:51:32,489
Now, we do of course,

1533
00:51:32,489 --> 00:51:34,559
have the C standard library.

1534
00:51:34,559 --> 00:51:36,389
Which has standard functions

1535
00:51:36,389 --> 00:51:38,219
for manipulating C strings.

1536
00:51:38,219 --> 00:51:40,920
So STR see PY string copy to

1537
00:51:40,920 --> 00:51:42,389
copy a C string and an array

1538
00:51:42,389 --> 00:51:44,400
of characters with 0 byte at the end.

1539
00:51:44,400 --> 00:51:46,349
Strlen to figure out the length of

1540
00:51:46,349 --> 00:51:49,019
a C string that, that exists.

1541
00:51:49,019 --> 00:51:49,889
But we're going to have to

1542
00:51:49,889 --> 00:51:51,014
write our own string type.

1543
00:51:51,014 --> 00:51:52,679
So let me start the setup,

1544
00:51:52,679 --> 00:51:54,179
and that would be how

1545
00:51:54,179 --> 00:51:55,903
we might want to use our string type.

1546
00:51:55,903 --> 00:51:58,289
So as a simple example usage,

1547
00:51:58,289 --> 00:52:01,349
I want to have some function h.

1548
00:52:01,349 --> 00:52:03,943
And it creates a string,

1549
00:52:03,943 --> 00:52:04,768
say with the text

1550
00:52:04,768 --> 00:52:06,494
Hello and does stuff with it.

1551
00:52:06,494 --> 00:52:08,985
So in order for that much to work,

1552
00:52:08,985 --> 00:52:10,739
will want to have a string plus I'll use

1553
00:52:10,739 --> 00:52:12,090
a capital S to distinguish it

1554
00:52:12,090 --> 00:52:13,588
from the library type string,

1555
00:52:13,588 --> 00:52:16,110
which we're assuming doesn't exist yet.

1556
00:52:16,110 --> 00:52:18,554
For that to work, we

1557
00:52:18,554 --> 00:52:20,534
need to have a constructor for string.

1558
00:52:20,534 --> 00:52:23,384
And it's going to take as its argument,

1559
00:52:23,384 --> 00:52:25,170
basically a C string at

1560
00:52:25,170 --> 00:52:27,599
a double quoted string literal in C and

1561
00:52:27,599 --> 00:52:29,983
C plus plus represents

1562
00:52:29,983 --> 00:52:31,994
an array of characters.

1563
00:52:31,994 --> 00:52:33,630
In fact, an array of constant characters,

1564
00:52:33,630 --> 00:52:35,039
array of characters you promise not to

1565
00:52:35,039 --> 00:52:36,539
modify an array of

1566
00:52:36,539 --> 00:52:37,648
characters with

1567
00:52:37,648 --> 00:52:40,273
a 0 byte terminating that string.

1568
00:52:40,273 --> 00:52:42,884
So what that means is somewhere in memory,

1569
00:52:42,884 --> 00:52:45,239
there's an array the compiler has laid

1570
00:52:45,239 --> 00:52:47,880
out with a capital H, lowercase,

1571
00:52:47,880 --> 00:52:50,565
a lowercase, a lowercase l,

1572
00:52:50,565 --> 00:52:53,985
a lower-case 00 byte, somewhere in memory.

1573
00:52:53,985 --> 00:52:55,528
There's this array the compiler

1574
00:52:55,528 --> 00:52:57,179
has set up for us.

1575
00:52:57,179 --> 00:52:58,528
It does that anytime you write

1576
00:52:58,528 --> 00:52:59,833
a string literal, okay,

1577
00:52:59,833 --> 00:53:01,739
so in an expression

1578
00:53:01,739 --> 00:53:03,884
where you use a string literal like that,

1579
00:53:03,884 --> 00:53:05,730
the compiler is going to say, okay,

1580
00:53:05,730 --> 00:53:06,898
I need to pass this array

1581
00:53:06,898 --> 00:53:08,175
to a constructor function.

1582
00:53:08,175 --> 00:53:09,900
Now of course, you can't pass on

1583
00:53:09,900 --> 00:53:12,869
our ray by value to a function.

1584
00:53:12,869 --> 00:53:14,923
And we learn that C and CS 31, when you,

1585
00:53:14,923 --> 00:53:15,478
when you think you're

1586
00:53:15,478 --> 00:53:16,648
passing an array to a function,

1587
00:53:16,648 --> 00:53:17,789
you're really passing a pointer

1588
00:53:17,789 --> 00:53:19,170
to element 0 of the array.

1589
00:53:19,170 --> 00:53:20,969
So this string constructed

1590
00:53:20,969 --> 00:53:22,514
is really receiving is

1591
00:53:22,514 --> 00:53:26,009
the pointer to the first of many characters.

1592
00:53:26,009 --> 00:53:27,208
And the expectation

1593
00:53:27,208 --> 00:53:28,289
is it's going to be a C string,

1594
00:53:28,289 --> 00:53:29,414
so it ends with a 0 bytes.

1595
00:53:29,414 --> 00:53:31,139
So there's my constructor.

1596
00:53:31,139 --> 00:53:33,329
So the, as I said,

1597
00:53:33,329 --> 00:53:34,710
the next thing to think about

1598
00:53:34,710 --> 00:53:37,123
is if this is what we want to have,

1599
00:53:37,123 --> 00:53:40,048
we should be thinking about.

1600
00:53:40,048 --> 00:53:42,239
Is there any other functionality

1601
00:53:42,239 --> 00:53:43,273
we want to have?

1602
00:53:43,273 --> 00:53:43,800
And then we can

1603
00:53:43,800 --> 00:53:45,028
start thinking about representation.

1604
00:53:45,028 --> 00:53:47,443
So let me think about this.

1605
00:53:47,443 --> 00:53:48,599
Are there other ways I

1606
00:53:48,599 --> 00:53:49,829
want to create a string?

1607
00:53:49,829 --> 00:53:51,360
In particular, do I

1608
00:53:51,360 --> 00:53:52,784
want to have a default constructor?

1609
00:53:52,784 --> 00:53:54,643
And you'd almost surely say, sure,

1610
00:53:54,643 --> 00:53:56,070
there's a reasonable default value

1611
00:53:56,070 --> 00:53:57,945
for strings, the empty string.

1612
00:53:57,945 --> 00:53:59,309
So why do we allow

1613
00:53:59,309 --> 00:54:00,778
a default constructor as well?

1614
00:54:00,778 --> 00:54:01,679
Okay,

1615
00:54:01,679 --> 00:54:03,389
so then what we're

1616
00:54:03,389 --> 00:54:04,199
going to start thinking is,

1617
00:54:04,199 --> 00:54:05,940
all right, Then let's

1618
00:54:05,940 --> 00:54:08,114
start thinking about representations.

1619
00:54:08,114 --> 00:54:11,565
So, well, Here's a real simple one.

1620
00:54:11,565 --> 00:54:12,480
Why don't we just have an array of

1621
00:54:12,480 --> 00:54:13,768
characters and the object.

1622
00:54:13,768 --> 00:54:16,048
So every spring object simply has

1623
00:54:16,048 --> 00:54:17,639
this one data member that's

1624
00:54:17,639 --> 00:54:19,603
an array of a 100 character.

1625
00:54:19,603 --> 00:54:21,523
Well, there's some problems with this.

1626
00:54:21,523 --> 00:54:23,264
In particular, the main problem

1627
00:54:23,264 --> 00:54:25,483
is if you have an array,

1628
00:54:25,483 --> 00:54:28,889
then the number of elements in the array,

1629
00:54:28,889 --> 00:54:29,878
if you're declaring an array,

1630
00:54:29,878 --> 00:54:30,809
the number of elements in

1631
00:54:30,809 --> 00:54:32,219
the array has to be a constant

1632
00:54:32,219 --> 00:54:33,420
known at compile time.

1633
00:54:33,420 --> 00:54:35,893
We have to pick some constant to put there.

1634
00:54:35,893 --> 00:54:36,989
I picked a 100.

1635
00:54:36,989 --> 00:54:39,639
What's not so great about that?

1636
00:54:39,679 --> 00:54:42,300
Well, what if I

1637
00:54:42,300 --> 00:54:43,108
want to have strings that are

1638
00:54:43,108 --> 00:54:44,429
more than a 100 characters?

1639
00:54:44,429 --> 00:54:47,608
I won't be able to fit long strings in here.

1640
00:54:47,608 --> 00:54:50,278
So, oh, okay, Well,

1641
00:54:50,278 --> 00:54:51,778
surely nobody wants a string of

1642
00:54:51,778 --> 00:54:53,579
say, a 100 thousand characters.

1643
00:54:53,579 --> 00:54:54,643
So let's put that there then.

1644
00:54:54,643 --> 00:54:55,994
That'll be room for any string,

1645
00:54:55,994 --> 00:54:57,778
room enough for any spring somebody wants.

1646
00:54:57,778 --> 00:54:59,248
What's wrong with that?

1647
00:54:59,248 --> 00:55:02,340
Well, then the problem is

1648
00:55:02,340 --> 00:55:03,840
every string is going to

1649
00:55:03,840 --> 00:55:06,210
take up a 100 thousand bytes.

1650
00:55:06,210 --> 00:55:08,818
Even a string like hello where we only

1651
00:55:08,818 --> 00:55:10,050
really need five

1652
00:55:10,050 --> 00:55:11,309
and we're going to be using a 100.

1653
00:55:11,309 --> 00:55:13,139
That's a lot of wasted space.

1654
00:55:13,139 --> 00:55:15,570
You won't be able to have too many strings in

1655
00:55:15,570 --> 00:55:17,849
your program without running out of memory.

1656
00:55:17,849 --> 00:55:20,309
So the problem with a fixed number

1657
00:55:20,309 --> 00:55:22,648
is if it's too big,

1658
00:55:22,648 --> 00:55:24,869
you're wasting a lot of space and might

1659
00:55:24,869 --> 00:55:26,009
not be able to have a lot of these

1660
00:55:26,009 --> 00:55:27,329
are objects of this type.

1661
00:55:27,329 --> 00:55:28,844
And if it's too small,

1662
00:55:28,844 --> 00:55:29,550
there'll be a lot of

1663
00:55:29,550 --> 00:55:30,599
things that we can't represent.

1664
00:55:30,599 --> 00:55:31,349
A lot of strength we can't

1665
00:55:31,349 --> 00:55:32,099
represent because it's too

1666
00:55:32,099 --> 00:55:34,574
short so that I have to reject that.

1667
00:55:34,574 --> 00:55:36,869
So the only other alternative is to say,

1668
00:55:36,869 --> 00:55:40,498
Well then let's instead make the texted,

1669
00:55:40,498 --> 00:55:43,275
the string dynamically allocated and

1670
00:55:43,275 --> 00:55:45,030
our object will hold a pointer

1671
00:55:45,030 --> 00:55:46,498
to the text of the string.

1672
00:55:46,498 --> 00:55:48,090
We'll try something like that.

1673
00:55:48,090 --> 00:55:50,099
So the idea would be then

1674
00:55:50,099 --> 00:55:51,795
a string object like ask

1675
00:55:51,795 --> 00:55:53,443
will have one data member,

1676
00:55:53,443 --> 00:55:55,858
the M text data member.

1677
00:55:55,858 --> 00:55:57,748
And we'll, we'll have it be a pointer to

1678
00:55:57,748 --> 00:56:00,960
a dynamically allocated array of characters.

1679
00:56:00,960 --> 00:56:02,144
Possibly.

1680
00:56:02,144 --> 00:56:05,969
Why not just have it be a copy of the season?

1681
00:56:05,969 --> 00:56:07,528
So we'll dynamically allocate

1682
00:56:07,528 --> 00:56:09,360
an array of characters big

1683
00:56:09,360 --> 00:56:10,920
enough to hold the string and then

1684
00:56:10,920 --> 00:56:12,809
will store a pointer to it.

1685
00:56:12,809 --> 00:56:14,429
Well, of course, as soon as you start

1686
00:56:14,429 --> 00:56:16,454
working with dynamic allocation,

1687
00:56:16,454 --> 00:56:18,224
you're saying, hey, operating system,

1688
00:56:18,224 --> 00:56:20,309
give me some storage for, for this array.

1689
00:56:20,309 --> 00:56:21,449
Well, there's

1690
00:56:21,449 --> 00:56:22,724
only a finite amount of storage,

1691
00:56:22,724 --> 00:56:24,614
so that's a resource that has to be managed.

1692
00:56:24,614 --> 00:56:26,699
We have to make sure that we don't use

1693
00:56:26,699 --> 00:56:28,858
up all the storage for strings.

1694
00:56:28,858 --> 00:56:32,099
We don't even need the memory for anymore.

1695
00:56:32,099 --> 00:56:34,289
So working all that out is going to be

1696
00:56:34,289 --> 00:56:37,079
the topic of what issues come up.

1697
00:56:37,079 --> 00:56:39,298
The problem is, resource management

1698
00:56:39,298 --> 00:56:41,130
is not a trivial issue.

1699
00:56:41,130 --> 00:56:42,688
It starts off looking that way.

1700
00:56:42,688 --> 00:56:43,949
It's like, oh, sure,

1701
00:56:43,949 --> 00:56:45,119
for any resource we allocate,

1702
00:56:45,119 --> 00:56:45,570
we gotta give it

1703
00:56:45,570 --> 00:56:46,483
back when we're done with it,

1704
00:56:46,483 --> 00:56:47,818
there's more and there's

1705
00:56:47,818 --> 00:56:49,380
many ways to go wrong.

1706
00:56:49,380 --> 00:56:51,914
And so that's what we got to see later.

1707
00:56:51,914 --> 00:56:53,759
I also wanted to default constructor,

1708
00:56:53,759 --> 00:56:55,378
which will produce the empty string.

1709
00:56:55,378 --> 00:56:58,094
Whoops, I spilled coffee on my shirt.

1710
00:56:58,094 --> 00:57:00,644
Oh no. Let me change my shirt.

1711
00:57:00,644 --> 00:57:02,048
Hang on.

1712
00:57:02,048 --> 00:57:03,378
Okay.

1713
00:57:03,378 --> 00:57:04,369
Where was I?

1714
00:57:04,369 --> 00:57:08,208
If I also want to default constructor,

1715
00:57:08,208 --> 00:57:09,648
which would produce an empty string.

1716
00:57:09,648 --> 00:57:10,759
And that leads me to think

1717
00:57:10,759 --> 00:57:12,574
about the representation.

1718
00:57:12,574 --> 00:57:14,630
How can I represent an empty string?

1719
00:57:14,630 --> 00:57:16,159
So I can see

1720
00:57:16,159 --> 00:57:18,664
two possibilities that would be reasonable.

1721
00:57:18,664 --> 00:57:20,360
One would be, well,

1722
00:57:20,360 --> 00:57:22,219
this is what a string of

1723
00:57:22,219 --> 00:57:24,813
five interesting characters looks like.

1724
00:57:24,813 --> 00:57:26,510
A six element array with

1725
00:57:26,510 --> 00:57:27,710
five interesting characters

1726
00:57:27,710 --> 00:57:29,268
followed by a 0 byte.

1727
00:57:29,268 --> 00:57:32,300
Then a two character string would have

1728
00:57:32,300 --> 00:57:33,949
two interesting characters followed by us

1729
00:57:33,949 --> 00:57:35,809
or by an empty string.

1730
00:57:35,809 --> 00:57:37,474
What I have now, interesting characters

1731
00:57:37,474 --> 00:57:39,034
followed by a 0 by.

1732
00:57:39,034 --> 00:57:40,489
So one way to represent

1733
00:57:40,489 --> 00:57:41,793
the empty string would be,

1734
00:57:41,793 --> 00:57:43,039
how about have a dynamically

1735
00:57:43,039 --> 00:57:45,063
allocated array of one byte.

1736
00:57:45,063 --> 00:57:47,268
And, and we're going to put the 0 byte there.

1737
00:57:47,268 --> 00:57:48,380
That'll be our representation

1738
00:57:48,380 --> 00:57:49,219
of the empty string.

1739
00:57:49,219 --> 00:57:50,059
That'll work.

1740
00:57:50,059 --> 00:57:51,980
But there's another possibility.

1741
00:57:51,980 --> 00:57:53,793
How about just a point?

1742
00:57:53,793 --> 00:57:56,090
So that would also conceivably

1743
00:57:56,090 --> 00:57:57,530
be a reasonable representation

1744
00:57:57,530 --> 00:57:58,579
of the empty string.

1745
00:57:58,579 --> 00:58:01,789
So before we go any further,

1746
00:58:01,789 --> 00:58:03,603
we probably should make a decision,

1747
00:58:03,603 --> 00:58:05,000
or at least a tentative decision.

1748
00:58:05,000 --> 00:58:06,739
And then as we implement,

1749
00:58:06,739 --> 00:58:08,000
we may decide, Oh,

1750
00:58:08,000 --> 00:58:09,559
that wasn't the right decision

1751
00:58:09,559 --> 00:58:10,579
we wanted to make us make

1752
00:58:10,579 --> 00:58:11,898
the other decision because

1753
00:58:11,898 --> 00:58:13,474
both of these are perfectly reasonable.

1754
00:58:13,474 --> 00:58:16,159
I mean, here's the arguments for both cases.

1755
00:58:16,159 --> 00:58:18,289
The first case, I

1756
00:58:18,289 --> 00:58:19,369
went with this representation

1757
00:58:19,369 --> 00:58:20,329
for the empty string,

1758
00:58:20,329 --> 00:58:21,963
it's consistent with

1759
00:58:21,963 --> 00:58:23,735
every other non-empty string.

1760
00:58:23,735 --> 00:58:25,489
So, so that would probably

1761
00:58:25,489 --> 00:58:27,715
make our implementation code.

1762
00:58:27,715 --> 00:58:30,599
Easier because it's not a special case.

1763
00:58:30,599 --> 00:58:33,480
The empty string would just another string.

1764
00:58:33,480 --> 00:58:35,489
It's not as if we're guaranteed

1765
00:58:35,489 --> 00:58:37,559
every string has a non null pointer here.

1766
00:58:37,559 --> 00:58:38,349
It points to in

1767
00:58:38,349 --> 00:58:40,708
a dynamically allocated array.

1768
00:58:40,708 --> 00:58:41,579
It's got the text to

1769
00:58:41,579 --> 00:58:42,630
the characters that make up

1770
00:58:42,630 --> 00:58:44,789
the strand followed by a 0 back by,

1771
00:58:44,789 --> 00:58:48,134
that would be uniform across all strings.

1772
00:58:48,134 --> 00:58:49,708
And that would make our job

1773
00:58:49,708 --> 00:58:51,239
as an implementer easier.

1774
00:58:51,239 --> 00:58:53,219
On the other hand, the empty string

1775
00:58:53,219 --> 00:58:54,778
is a very frequently occurring string.

1776
00:58:54,778 --> 00:58:56,489
If I decide to declare an array

1777
00:58:56,489 --> 00:58:58,710
of a 100 thousand strings,

1778
00:58:58,710 --> 00:58:59,699
each string will be

1779
00:58:59,699 --> 00:59:01,318
constructed whenever you create

1780
00:59:01,318 --> 00:59:04,289
an array of objects of a class type,

1781
00:59:04,289 --> 00:59:07,139
every element will be default constructed.

1782
00:59:07,139 --> 00:59:08,880
So that'll be a 100 thousand

1783
00:59:08,880 --> 00:59:11,159
default constructor, empty strings.

1784
00:59:11,159 --> 00:59:14,219
Now, to dynamically allocate storage,

1785
00:59:14,219 --> 00:59:16,244
whether it's a bigger a or a small array,

1786
00:59:16,244 --> 00:59:17,744
takes dozens of instructions.

1787
00:59:17,744 --> 00:59:19,110
Does the machine language instructions

1788
00:59:19,110 --> 00:59:20,878
to dynamically allocate storage,

1789
00:59:20,878 --> 00:59:22,724
even if it's just a one byte array.

1790
00:59:22,724 --> 00:59:24,960
So the cost of

1791
00:59:24,960 --> 00:59:26,070
creating an array of

1792
00:59:26,070 --> 00:59:27,358
a lot of empty strings is

1793
00:59:27,358 --> 00:59:29,489
going to be lots and lots of instruction is

1794
00:59:29,489 --> 00:59:30,838
getting executed to properly

1795
00:59:30,838 --> 00:59:32,610
build those empty strengths.

1796
00:59:32,610 --> 00:59:34,949
And when we go away,

1797
00:59:34,949 --> 00:59:36,539
the destructor gets called on each of

1798
00:59:36,539 --> 00:59:37,619
those strings and that takes

1799
00:59:37,619 --> 00:59:39,434
several dozen instructions.

1800
00:59:39,434 --> 00:59:41,460
So there's a time cost

1801
00:59:41,460 --> 00:59:43,800
with this representation of the empty string.

1802
00:59:43,800 --> 00:59:45,434
There's also a space cost

1803
00:59:45,434 --> 00:59:47,039
and it's more than you might think.

1804
00:59:47,039 --> 00:59:49,260
It looks like every empty string

1805
00:59:49,260 --> 00:59:51,614
is going to take up one byte.

1806
00:59:51,614 --> 00:59:53,278
And in fact, when you

1807
00:59:53,278 --> 00:59:55,139
dynamically allocate storage,

1808
00:59:55,139 --> 00:59:57,148
there has to be some bookkeeping information

1809
00:59:57,148 --> 00:59:58,619
that the storage allocator keeps.

1810
00:59:58,619 --> 01:00:01,574
It keeps around to keep track of, you know,

1811
01:00:01,574 --> 01:00:03,690
how big that dynamically allocated storage

1812
01:00:03,690 --> 01:00:04,918
is because when you call

1813
01:00:04,918 --> 01:00:06,239
it delete to get rid of it,

1814
01:00:06,239 --> 01:00:07,648
when you use delete to get rid of

1815
01:00:07,648 --> 01:00:10,184
it dynamically allocated item,

1816
01:00:10,184 --> 01:00:12,719
all you give delete is where it is.

1817
01:00:12,719 --> 01:00:16,318
So somehow the storage allocator have to have

1818
01:00:16,318 --> 01:00:18,119
some bookkeeping information to figure out

1819
01:00:18,119 --> 01:00:19,228
how much space do we get

1820
01:00:19,228 --> 01:00:20,653
back to the operating system.

1821
01:00:20,653 --> 01:00:22,934
So so that overhead,

1822
01:00:22,934 --> 01:00:24,420
that extra space overhead

1823
01:00:24,420 --> 01:00:26,159
for the bookkeeping information,

1824
01:00:26,159 --> 01:00:30,929
that could be eight bytes, maybe more.

1825
01:00:30,929 --> 01:00:33,208
So our array of

1826
01:00:33,208 --> 01:00:35,143
a 100 thousand empty two strings

1827
01:00:35,143 --> 01:00:36,510
is not only going to take up

1828
01:00:36,510 --> 01:00:38,039
space for the strings themselves,

1829
01:00:38,039 --> 01:00:39,418
which each string is

1830
01:00:39,418 --> 01:00:41,699
just takes up the size of a pointer,

1831
01:00:41,699 --> 01:00:43,648
but also the dynamically allocate

1832
01:00:43,648 --> 01:00:46,394
an array and the bookkeeping information.

1833
01:00:46,394 --> 01:00:48,090
And so the overhead is, well,

1834
01:00:48,090 --> 01:00:49,873
if it's eight bytes per object,

1835
01:00:49,873 --> 01:00:52,079
and we have a 100 thousand strings in our,

1836
01:00:52,079 --> 01:00:55,514
in our array, that's 800 kilobytes,

1837
01:00:55,514 --> 01:00:57,809
just a bookkeeping information

1838
01:00:57,809 --> 01:00:59,414
for those empty strengths.

1839
01:00:59,414 --> 01:01:02,280
On the other hand, if the empty string is

1840
01:01:02,280 --> 01:01:05,114
represented as this way

1841
01:01:05,114 --> 01:01:06,733
with the null pointer in here,

1842
01:01:06,733 --> 01:01:09,434
there is no extra storage overhead.

1843
01:01:09,434 --> 01:01:12,253
So that safe space and

1844
01:01:12,253 --> 01:01:14,715
the cost to initialize

1845
01:01:14,715 --> 01:01:16,769
this to be to the null pointer,

1846
01:01:16,769 --> 01:01:17,460
you know,

1847
01:01:17,460 --> 01:01:19,590
one machine language instruction essentially.

1848
01:01:19,590 --> 01:01:23,039
So, so if I

1849
01:01:23,039 --> 01:01:25,875
were designing this for practical purposes,

1850
01:01:25,875 --> 01:01:28,079
I would probably want to have

1851
01:01:28,079 --> 01:01:29,925
the empty string be

1852
01:01:29,925 --> 01:01:32,458
a special case represented this way.

1853
01:01:32,458 --> 01:01:34,530
Now that's going to make all my

1854
01:01:34,530 --> 01:01:35,699
implementation's a little

1855
01:01:35,699 --> 01:01:37,048
more complicated for me,

1856
01:01:37,048 --> 01:01:39,690
the developer implementing string,

1857
01:01:39,690 --> 01:01:43,168
because I have to check for that case,

1858
01:01:43,168 --> 01:01:44,159
every other string is

1859
01:01:44,159 --> 01:01:45,480
a non null pointer here,

1860
01:01:45,480 --> 01:01:47,550
but the empty string would have a null point.

1861
01:01:47,550 --> 01:01:50,039
That would make my code and let me know.

1862
01:01:50,039 --> 01:01:51,300
And people pay more attention

1863
01:01:51,300 --> 01:01:52,559
when writing the code to implement

1864
01:01:52,559 --> 01:01:53,894
the member functions of strengths

1865
01:01:53,894 --> 01:01:55,545
for users don't care about us.

1866
01:01:55,545 --> 01:01:56,670
They just use the string type.

1867
01:01:56,670 --> 01:01:58,079
It works from their point of view.

1868
01:01:58,079 --> 01:01:58,769
But

1869
01:01:58,769 --> 01:01:59,625
And implemented,

1870
01:01:59,625 --> 01:02:01,259
I would have to do more work.

1871
01:02:01,259 --> 01:02:04,469
So the choices between

1872
01:02:04,469 --> 01:02:07,019
doing more work for me, the implementer,

1873
01:02:07,019 --> 01:02:09,525
in order to make my user's life easier,

1874
01:02:09,525 --> 01:02:10,949
taking up less storage,

1875
01:02:10,949 --> 01:02:12,945
faster performance, et cetera.

1876
01:02:12,945 --> 01:02:16,829
Or make my life as an implementer easier.

1877
01:02:16,829 --> 01:02:18,449
But it's going to be a little more

1878
01:02:18,449 --> 01:02:20,610
costly for users to use my strengths.

1879
01:02:20,610 --> 01:02:22,260
So this is kind of

1880
01:02:22,260 --> 01:02:23,849
from the second Star Trek movie,

1881
01:02:23,849 --> 01:02:25,048
the needs of the many outweigh

1882
01:02:25,048 --> 01:02:26,773
the needs of the few or the one,

1883
01:02:26,773 --> 01:02:28,574
the needs of all my users,

1884
01:02:28,574 --> 01:02:30,570
making life easier for all my users.

1885
01:02:30,570 --> 01:02:32,744
So my stream type is more important

1886
01:02:32,744 --> 01:02:35,639
than saving me a little bit of extra work.

1887
01:02:35,639 --> 01:02:38,503
So this would be the right decision to make.

1888
01:02:38,503 --> 01:02:39,599
And in fact, if you look

1889
01:02:39,599 --> 01:02:41,309
at most library implementations,

1890
01:02:41,309 --> 01:02:43,333
the string type and standard library,

1891
01:02:43,333 --> 01:02:45,989
you find that indeed they'll have

1892
01:02:45,989 --> 01:02:48,059
a simpler representation for

1893
01:02:48,059 --> 01:02:49,800
the empty string that,

1894
01:02:49,800 --> 01:02:51,360
that doesn't need to allocate

1895
01:02:51,360 --> 01:02:53,699
storage because that saves time.

1896
01:02:53,699 --> 01:02:55,304
This is better for everybody.

1897
01:02:55,304 --> 01:02:57,344
Now, that said,

1898
01:02:57,344 --> 01:02:59,068
that's the decision I would make

1899
01:02:59,068 --> 01:03:01,349
it in the real world in

1900
01:03:01,349 --> 01:03:04,708
practice for our purposes,

1901
01:03:04,708 --> 01:03:06,300
for this explanation of going

1902
01:03:06,300 --> 01:03:08,219
through the resource management issue.

1903
01:03:08,219 --> 01:03:10,050
That's just an extra complication

1904
01:03:10,050 --> 01:03:11,099
I we would have.

1905
01:03:11,099 --> 01:03:12,719
So I'm going to make the decision

1906
01:03:12,719 --> 01:03:14,458
that for this presentation,

1907
01:03:14,458 --> 01:03:16,048
representation of the empty string

1908
01:03:16,048 --> 01:03:16,949
will look like that.

1909
01:03:16,949 --> 01:03:19,380
So it'll be a dynamically allocated array

1910
01:03:19,380 --> 01:03:20,730
with Zuora by them.

1911
01:03:20,730 --> 01:03:21,838
So there you go.

1912
01:03:21,838 --> 01:03:23,639
I've decided on my representation for string,

1913
01:03:23,639 --> 01:03:24,840
but, but wait a minute.

1914
01:03:24,840 --> 01:03:26,833
I will discover as I

1915
01:03:26,833 --> 01:03:28,739
implement many member functions for strings,

1916
01:03:28,739 --> 01:03:29,699
useful things to do with

1917
01:03:29,699 --> 01:03:30,960
strings that may have

1918
01:03:30,960 --> 01:03:32,519
those functions need to

1919
01:03:32,519 --> 01:03:34,108
find out the length of the string.

1920
01:03:34,108 --> 01:03:35,489
So many of my member

1921
01:03:35,489 --> 01:03:36,809
functions for string will,

1922
01:03:36,809 --> 01:03:37,980
as part of their work, need

1923
01:03:37,980 --> 01:03:39,329
to know the length of the string.

1924
01:03:39,329 --> 01:03:42,208
So notice that the only way

1925
01:03:42,208 --> 01:03:43,949
this representation to know the length

1926
01:03:43,949 --> 01:03:46,003
of the string is to

1927
01:03:46,003 --> 01:03:48,449
start from the pointer and find the 0 line,

1928
01:03:48,449 --> 01:03:50,190
which is what the strlen function does.

1929
01:03:50,190 --> 01:03:51,929
Remember on my assumption that this

1930
01:03:51,929 --> 01:03:53,730
is 990 and we don't

1931
01:03:53,730 --> 01:03:55,769
have a standard library with

1932
01:03:55,769 --> 01:03:58,409
the B glass from seeing what class,

1933
01:03:58,409 --> 01:03:59,070
we still have

1934
01:03:59,070 --> 01:04:00,539
the C standard library available.

1935
01:04:00,539 --> 01:04:01,679
So we can use functions for

1936
01:04:01,679 --> 01:04:03,059
C strings like strlen.

1937
01:04:03,059 --> 01:04:05,278
So anytime, anywhere, any of

1938
01:04:05,278 --> 01:04:06,360
our other functions need to

1939
01:04:06,360 --> 01:04:07,469
know the length of the string,

1940
01:04:07,469 --> 01:04:09,329
they've got a visit every bite of the string.

1941
01:04:09,329 --> 01:04:10,858
So for a long string that

1942
01:04:10,858 --> 01:04:12,690
could be, that could be costly.

1943
01:04:12,690 --> 01:04:14,789
So here's another thought

1944
01:04:14,789 --> 01:04:16,079
for how I represent a string.

1945
01:04:16,079 --> 01:04:19,755
I'll store not only a pointer to the tax,

1946
01:04:19,755 --> 01:04:21,150
but also how many

1947
01:04:21,150 --> 01:04:22,889
interesting characters are in the string.

1948
01:04:22,889 --> 01:04:25,184
So every string object will have two members.

1949
01:04:25,184 --> 01:04:26,534
If I make this decision,

1950
01:04:26,534 --> 01:04:28,438
one will be a pointer to the, the,

1951
01:04:28,438 --> 01:04:30,389
the text and one will be what the,

1952
01:04:30,389 --> 01:04:32,278
the, the length of that text is.

1953
01:04:32,278 --> 01:04:34,110
So five interesting characters

1954
01:04:34,110 --> 01:04:35,864
here is 0 interesting characters here.

1955
01:04:35,864 --> 01:04:37,619
I'll do that because I think that'll make

1956
01:04:37,619 --> 01:04:39,420
my implementations takes them

1957
01:04:39,420 --> 01:04:40,918
a little more space for string object,

1958
01:04:40,918 --> 01:04:42,028
but, but it makes

1959
01:04:42,028 --> 01:04:43,199
the implementation is faster.

1960
01:04:43,199 --> 01:04:45,778
I think anytime you think this is going to

1961
01:04:45,778 --> 01:04:47,250
be the better choice for

1962
01:04:47,250 --> 01:04:49,048
various performance region reasons,

1963
01:04:49,048 --> 01:04:50,804
you would want to measure that.

1964
01:04:50,804 --> 01:04:54,838
So, so again, in real-world situations,

1965
01:04:54,838 --> 01:04:56,070
you make your decision,

1966
01:04:56,070 --> 01:04:58,528
you run some tests, you measure it.

1967
01:04:58,528 --> 01:05:00,179
You maybe consider the alternating

1968
01:05:00,179 --> 01:05:01,710
implementation, run some tests,

1969
01:05:01,710 --> 01:05:03,000
measure it and see

1970
01:05:03,000 --> 01:05:04,485
which one is in fact going to,

1971
01:05:04,485 --> 01:05:05,923
going to be better for you.

1972
01:05:05,923 --> 01:05:08,159
So, to make our presentation easier,

1973
01:05:08,159 --> 01:05:09,449
this is the choice I'll make.

1974
01:05:09,449 --> 01:05:12,690
That leads me to going back to code bell,

1975
01:05:12,690 --> 01:05:14,009
easy to say, okay, I will

1976
01:05:14,009 --> 01:05:15,974
have an additional data member.

1977
01:05:15,974 --> 01:05:16,949
That'll,

1978
01:05:16,949 --> 01:05:18,389
that'll hold the length of the string.

1979
01:05:18,389 --> 01:05:20,010
All right, So again,

1980
01:05:20,010 --> 01:05:21,239
it's a good idea to document

1981
01:05:21,239 --> 01:05:22,289
your class invariant if

1982
01:05:22,289 --> 01:05:23,460
you make these decisions.

1983
01:05:23,460 --> 01:05:25,394
So I'll say that.

1984
01:05:25,394 --> 01:05:27,269
All right, So my class invariant,

1985
01:05:27,269 --> 01:05:29,190
invariant properties of my representations,

1986
01:05:29,190 --> 01:05:30,119
so I keep track and make sure

1987
01:05:30,119 --> 01:05:31,543
I always satisfy them.

1988
01:05:31,543 --> 01:05:33,179
One of them is of course,

1989
01:05:33,179 --> 01:05:36,599
that mtext is a pointer to my intent.

1990
01:05:36,599 --> 01:05:38,804
It's a dynamically allocated array.

1991
01:05:38,804 --> 01:05:40,320
And how many characters in the array?

1992
01:05:40,320 --> 01:05:41,728
Well, actually it should

1993
01:05:41,728 --> 01:05:43,063
be related to the M1,

1994
01:05:43,063 --> 01:05:44,338
enough characters to hold

1995
01:05:44,338 --> 01:05:46,318
the interesting characters in

1996
01:05:46,318 --> 01:05:47,610
the string plus one more for

1997
01:05:47,610 --> 01:05:49,708
this terabyte at the end, of course.

1998
01:05:49,708 --> 01:05:52,139
Another property is the length

1999
01:05:52,139 --> 01:05:54,659
of a string has to be at least 0.

2000
01:05:54,659 --> 01:05:56,608
And another property is

2001
01:05:56,608 --> 01:05:59,309
that there is a 0 byte at the end.

2002
01:05:59,309 --> 01:06:00,420
Well actually here's another way to

2003
01:06:00,420 --> 01:06:01,588
say M line is supposed to

2004
01:06:01,588 --> 01:06:03,150
represent the result of what

2005
01:06:03,150 --> 01:06:04,875
calling strlen would give me.

2006
01:06:04,875 --> 01:06:06,989
So, so if I call the C library

2007
01:06:06,989 --> 01:06:09,028
function strlen on M text,

2008
01:06:09,028 --> 01:06:10,440
I should get back the length.

2009
01:06:10,440 --> 01:06:11,338
So I've decided what

2010
01:06:11,338 --> 01:06:12,599
my data representations are.

2011
01:06:12,599 --> 01:06:14,534
Now I can start implementing the functions.

2012
01:06:14,534 --> 01:06:17,773
So I will implement my constructor.

2013
01:06:17,773 --> 01:06:21,688
And let me, let me try this implementation.

2014
01:06:21,688 --> 01:06:22,980
Well, that's a C string,

2015
01:06:22,980 --> 01:06:24,434
so I'll sign it there.

2016
01:06:24,434 --> 01:06:26,429
So I try something like that as

2017
01:06:26,429 --> 01:06:28,019
my, as my implementation.

2018
01:06:28,019 --> 01:06:29,460
This is wrong.

2019
01:06:29,460 --> 01:06:31,619
This is an incorrect implementation.

2020
01:06:31,619 --> 01:06:33,824
This is wrong because

2021
01:06:33,824 --> 01:06:36,405
It's going to lead to some funny effects.

2022
01:06:36,405 --> 01:06:37,980
So let's see what

2023
01:06:37,980 --> 01:06:39,434
those funny effects would be.

2024
01:06:39,434 --> 01:06:40,619
Alright, so again, remember

2025
01:06:40,619 --> 01:06:41,639
the constructor is

2026
01:06:41,639 --> 01:06:42,929
simply taking the parameter,

2027
01:06:42,929 --> 01:06:44,099
you give it the pointer and

2028
01:06:44,099 --> 01:06:45,644
stuffing it in the M text.

2029
01:06:45,644 --> 01:06:47,849
And also taking the length of that,

2030
01:06:47,849 --> 01:06:50,023
that stuck and sticking in the mLab.

2031
01:06:50,023 --> 01:06:51,568
So let me, let me

2032
01:06:51,568 --> 01:06:53,278
take a look at what that would do.

2033
01:06:53,278 --> 01:06:55,139
Absolutely get an example where

2034
01:06:55,139 --> 01:06:57,704
the positive character array,

2035
01:06:57,704 --> 01:06:59,474
okay, I found an array of characters pop.

2036
01:06:59,474 --> 01:07:01,543
All right, I will,

2037
01:07:01,543 --> 01:07:03,449
I'll read a line of input.

2038
01:07:03,449 --> 01:07:06,179
Now, admittedly, and 990,

2039
01:07:06,179 --> 01:07:08,699
the standard library wasn't standardized,

2040
01:07:08,699 --> 01:07:10,619
but many, many libraries

2041
01:07:10,619 --> 01:07:13,170
had implementations where okay too,

2042
01:07:13,170 --> 01:07:16,170
I see, or you could call getline are.

2043
01:07:16,170 --> 01:07:18,539
And you get the array limit

2044
01:07:18,539 --> 01:07:20,414
on how many characters to store.

2045
01:07:20,414 --> 01:07:22,349
So that will read a line of input,

2046
01:07:22,349 --> 01:07:24,434
Let's say the user types in hello.

2047
01:07:24,434 --> 01:07:26,188
So the user types in hello,

2048
01:07:26,188 --> 01:07:27,389
and this is going to put it in

2049
01:07:27,389 --> 01:07:29,250
this character array with his thereby.

2050
01:07:29,250 --> 01:07:31,304
Okay, so again, hello to 0 byte at the end.

2051
01:07:31,304 --> 01:07:32,608
Now let's create a string

2052
01:07:32,608 --> 01:07:34,335
object from that string.

2053
01:07:34,335 --> 01:07:35,713
Okay, Now as I,

2054
01:07:35,713 --> 01:07:37,380
as I wrote the constructor,

2055
01:07:37,380 --> 01:07:38,789
my constructor said, okay,

2056
01:07:38,789 --> 01:07:41,474
we have our two numbers, our texts and MLN.

2057
01:07:41,474 --> 01:07:43,440
And as I wrote the constructor,

2058
01:07:43,440 --> 01:07:46,753
I said m texts gets the argument if I'm

2059
01:07:46,753 --> 01:07:49,108
passing a pointer to buffer

2060
01:07:49,108 --> 01:07:50,489
because an array name by assault

2061
01:07:50,489 --> 01:07:51,809
and disappointed at element 0,

2062
01:07:51,809 --> 01:07:53,909
the array, if I pass that

2063
01:07:53,909 --> 01:07:56,443
as to the constructor as value.

2064
01:07:56,443 --> 01:07:57,568
And if my constructor

2065
01:07:57,568 --> 01:08:00,945
says assign value to m tax,

2066
01:08:00,945 --> 01:08:03,945
well then that pointer gets assigned M text

2067
01:08:03,945 --> 01:08:05,550
and strlen and value becomes

2068
01:08:05,550 --> 01:08:07,378
m land was the other code I said.

2069
01:08:07,378 --> 01:08:09,465
And we leave the constructor,

2070
01:08:09,465 --> 01:08:10,648
the local parameter

2071
01:08:10,648 --> 01:08:12,043
value because the right way,

2072
01:08:12,043 --> 01:08:13,889
and here it is as has

2073
01:08:13,889 --> 01:08:16,140
a pointer to hello with a 0,

2074
01:08:16,140 --> 01:08:17,310
but at the end, and Atlanta's

2075
01:08:17,310 --> 01:08:18,810
five looks great.

2076
01:08:18,810 --> 01:08:20,805
Did all kinds of stuff I can do with that.

2077
01:08:20,805 --> 01:08:21,510
That'll be right.

2078
01:08:21,510 --> 01:08:22,890
So look like it has the text,

2079
01:08:22,890 --> 01:08:25,244
Hello, everything, everything seems legit.

2080
01:08:25,244 --> 01:08:26,939
There's only one problem.

2081
01:08:26,939 --> 01:08:29,460
It's very confusing to the user for.

2082
01:08:29,460 --> 01:08:32,413
Well, if the user later on,

2083
01:08:32,413 --> 01:08:33,600
say reads another line

2084
01:08:33,600 --> 01:08:34,828
and put it into the buffer,

2085
01:08:34,828 --> 01:08:38,338
figuring that, okay, I can align it input,

2086
01:08:38,338 --> 01:08:40,078
I typed it below that,

2087
01:08:40,078 --> 01:08:41,130
got put into the strengths,

2088
01:08:41,130 --> 01:08:42,255
so the strings got the **** out.

2089
01:08:42,255 --> 01:08:43,079
Nevertheless, let me go use

2090
01:08:43,079 --> 01:08:44,368
the buffers for something else.

2091
01:08:44,368 --> 01:08:46,335
So I read a line of input to the buffer.

2092
01:08:46,335 --> 01:08:49,033
Let's say that line of input is, Oh,

2093
01:08:49,033 --> 01:08:51,960
wow, well, buffers right here.

2094
01:08:51,960 --> 01:08:55,139
So incomes, the wildlife being out alone,

2095
01:08:55,139 --> 01:08:58,963
actually pillow occupy six characters here.

2096
01:08:58,963 --> 01:09:00,795
If I 3D and wow,

2097
01:09:00,795 --> 01:09:04,744
will get the w o to w 0

2098
01:09:04,744 --> 01:09:08,010
by leftover from the halo would be

2099
01:09:08,010 --> 01:09:11,849
the final lower-case 00 byte here.

2100
01:09:11,849 --> 01:09:16,920
Basically, we are putting WOW, 0 right here.

2101
01:09:16,920 --> 01:09:18,479
And now we've got

2102
01:09:18,479 --> 01:09:20,069
the strange situation, right?

2103
01:09:20,069 --> 01:09:21,989
We ready and to buffer,

2104
01:09:21,989 --> 01:09:24,373
we made no mention of the string s.

2105
01:09:24,373 --> 01:09:27,810
Yet this change, conceptually what S is value

2106
01:09:27,810 --> 01:09:29,970
is now code that uses

2107
01:09:29,970 --> 01:09:31,109
AES and tries to do

2108
01:09:31,109 --> 01:09:32,729
stuff with the string is going to get,

2109
01:09:32,729 --> 01:09:35,010
well, it's gotta be weird because

2110
01:09:35,010 --> 01:09:36,088
the code is going to think that

2111
01:09:36,088 --> 01:09:37,965
the length of the string is five.

2112
01:09:37,965 --> 01:09:40,484
And well, it's not.

2113
01:09:40,484 --> 01:09:41,850
The strlen is,

2114
01:09:41,850 --> 01:09:43,019
there's really only up to here,

2115
01:09:43,019 --> 01:09:45,719
so it's only really effectively three.

2116
01:09:45,719 --> 01:09:47,878
The string value changed out from under us.

2117
01:09:47,878 --> 01:09:49,710
It, it, it was hello before and

2118
01:09:49,710 --> 01:09:51,838
now Ss values no longer hello,

2119
01:09:51,838 --> 01:09:53,774
but we didn't even mention us.

2120
01:09:53,774 --> 01:09:55,215
This is totally wrong.

2121
01:09:55,215 --> 01:09:57,538
This is, this is really bad,

2122
01:09:57,538 --> 01:10:00,118
bad practice here because our expectation

2123
01:10:00,118 --> 01:10:03,329
is that if I create a string from that tax,

2124
01:10:03,329 --> 01:10:04,904
that tax no longer matters.

2125
01:10:04,904 --> 01:10:06,524
If now belongs to the strength.

2126
01:10:06,524 --> 01:10:07,680
Well, that's not what we did.

2127
01:10:07,680 --> 01:10:08,970
We saved a pointer to

2128
01:10:08,970 --> 01:10:10,590
where that text came from M.

2129
01:10:10,590 --> 01:10:11,878
And that's well, okay.

2130
01:10:11,878 --> 01:10:14,998
So what we want is when you create a string,

2131
01:10:14,998 --> 01:10:18,465
each string gets its own array of text.

2132
01:10:18,465 --> 01:10:20,039
Let me go back to the code here.

2133
01:10:20,039 --> 01:10:21,180
Now, actually,

2134
01:10:21,180 --> 01:10:22,559
there's another reason this is wrong.

2135
01:10:22,559 --> 01:10:23,850
It won't even compile.

2136
01:10:23,850 --> 01:10:27,764
Value is a pointer to constant characters.

2137
01:10:27,764 --> 01:10:30,569
M text says is

2138
01:10:30,569 --> 01:10:33,389
declared as a pointer to texts.

2139
01:10:33,389 --> 01:10:36,314
That is, we don't promise not to modify.

2140
01:10:36,314 --> 01:10:38,640
Compiler won't even let you do that.

2141
01:10:38,640 --> 01:10:40,634
So, so this won't even compile.

2142
01:10:40,634 --> 01:10:42,208
But if you thought, well,

2143
01:10:42,208 --> 01:10:43,800
why don't I make this not a

2144
01:10:43,800 --> 01:10:45,569
pointer to constant characters less promised.

2145
01:10:45,569 --> 01:10:46,619
Let's not promised not to

2146
01:10:46,619 --> 01:10:47,984
modify the characters.

2147
01:10:47,984 --> 01:10:49,380
Get rid of the const here,

2148
01:10:49,380 --> 01:10:50,819
and then we can go ahead and do this.

2149
01:10:50,819 --> 01:10:51,599
Well, yeah,

2150
01:10:51,599 --> 01:10:53,128
that assignment would then be, would compile.

2151
01:10:53,128 --> 01:10:54,838
But we still have this weird problem that

2152
01:10:54,838 --> 01:10:57,118
the strings value changes out from under it.

2153
01:10:57,118 --> 01:11:00,225
So now, now, and in fact,

2154
01:11:00,225 --> 01:11:01,590
I already anticipated that in

2155
01:11:01,590 --> 01:11:03,479
my class and barium and I said,

2156
01:11:03,479 --> 01:11:05,159
Wait a minute, am tax is a pointer

2157
01:11:05,159 --> 01:11:06,958
to a dynamically allocated array.

2158
01:11:06,958 --> 01:11:08,774
Well, no, it's not, not here.

2159
01:11:08,774 --> 01:11:10,904
So yeah, I totally messed up here.

2160
01:11:10,904 --> 01:11:13,168
So now let's, let's do this right.

2161
01:11:13,168 --> 01:11:14,925
Now. What we did for M line is correct.

2162
01:11:14,925 --> 01:11:17,203
I'm text needs to be

2163
01:11:17,203 --> 01:11:19,140
a dynamically allocated array

2164
01:11:19,140 --> 01:11:20,609
of some number of characters.

2165
01:11:20,609 --> 01:11:22,168
That's what we need to set.

2166
01:11:22,168 --> 01:11:24,000
Dynamically allocated an array

2167
01:11:24,000 --> 01:11:25,634
of the appropriate number of characters.

2168
01:11:25,634 --> 01:11:26,788
New will give us back

2169
01:11:26,788 --> 01:11:28,350
a pointer to the beginning of that array.

2170
01:11:28,350 --> 01:11:29,953
And that's what gets stored at M text

2171
01:11:29,953 --> 01:11:31,378
and how many characters?

2172
01:11:31,378 --> 01:11:32,894
Well, big enough to hold the string.

2173
01:11:32,894 --> 01:11:35,219
But since I decided I want my representation

2174
01:11:35,219 --> 01:11:37,618
of the string to have a 0 byte at the end.

2175
01:11:37,618 --> 01:11:39,180
It's not going to be m land,

2176
01:11:39,180 --> 01:11:40,875
it's going to be m land plus one.

2177
01:11:40,875 --> 01:11:43,048
So that causes the string to,

2178
01:11:43,048 --> 01:11:45,029
right now the contents out though,

2179
01:11:45,029 --> 01:11:46,229
instead of going to live to

2180
01:11:46,229 --> 01:11:47,594
the white board or put it here,

2181
01:11:47,594 --> 01:11:49,979
the contents of the strings M text,

2182
01:11:49,979 --> 01:11:51,418
okay, It's, it's, it's

2183
01:11:51,418 --> 01:11:52,649
M line is going to be five.

2184
01:11:52,649 --> 01:11:54,448
And the M text right now is going to be

2185
01:11:54,448 --> 01:11:57,128
an array of, at the very moment, it

2186
01:11:57,128 --> 01:11:58,744
Uninitialized character,

2187
01:11:58,744 --> 01:11:59,779
we dynamically allocate

2188
01:11:59,779 --> 01:12:01,039
an array of six characters.

2189
01:12:01,039 --> 01:12:03,020
We didn't yet say what values they have.

2190
01:12:03,020 --> 01:12:04,670
So we need to make sure we take

2191
01:12:04,670 --> 01:12:07,189
the text of the string here.

2192
01:12:07,189 --> 01:12:08,569
Value is a pointer to that to be

2193
01:12:08,569 --> 01:12:10,175
hello string them that's empty.

2194
01:12:10,175 --> 01:12:11,329
And let us five and we have

2195
01:12:11,329 --> 01:12:13,039
the array of 600 initialized characters.

2196
01:12:13,039 --> 01:12:16,954
We need to get those characters into mtext.

2197
01:12:16,954 --> 01:12:19,639
Again, we have the C standard library

2198
01:12:19,639 --> 01:12:21,439
so we can use string copy.

2199
01:12:21,439 --> 01:12:25,444
So we will copy into M text from value.

2200
01:12:25,444 --> 01:12:26,689
So again, str copy

2201
01:12:26,689 --> 01:12:29,884
takes two pointers to characters.

2202
01:12:29,884 --> 01:12:31,220
The first is a pointer to carry

2203
01:12:31,220 --> 01:12:32,809
an array of characters you can modify.

2204
01:12:32,809 --> 01:12:33,789
The second is he's appointed

2205
01:12:33,789 --> 01:12:34,789
to characters and, and,

2206
01:12:34,789 --> 01:12:35,810
and the function is not going to

2207
01:12:35,810 --> 01:12:37,099
modify those characters.

2208
01:12:37,099 --> 01:12:38,988
And so it'll copy the characters

2209
01:12:38,988 --> 01:12:42,149
from the second array into the first array,

2210
01:12:42,149 --> 01:12:44,444
stopping after it copies a 0 byte.

2211
01:12:44,444 --> 01:12:47,264
So if value is pointing to the hello string,

2212
01:12:47,264 --> 01:12:48,479
this, this constant string

2213
01:12:48,479 --> 01:12:50,384
in memory that has hello.

2214
01:12:50,384 --> 01:12:53,654
Then we're gonna get our h here,

2215
01:12:53,654 --> 01:12:56,010
or here, or here,

2216
01:12:56,010 --> 01:12:57,809
or here, or here,

2217
01:12:57,809 --> 01:12:59,354
or I guess I missed one question marks

2218
01:12:59,354 --> 01:13:01,170
and is thereby the character who's,

2219
01:13:01,170 --> 01:13:02,550
who's representation is 0.

2220
01:13:02,550 --> 01:13:06,270
Okay, so now S looks like that.

2221
01:13:06,270 --> 01:13:07,769
If we passed it hello,

2222
01:13:07,769 --> 01:13:09,689
does that satisfy our invariant?

2223
01:13:09,689 --> 01:13:10,889
Mtext is a pointer to

2224
01:13:10,889 --> 01:13:12,420
a dynamically allocated array of

2225
01:13:12,420 --> 01:13:14,265
five plus 16 characters.

2226
01:13:14,265 --> 01:13:16,484
Yes, we allocated six characters.

2227
01:13:16,484 --> 01:13:18,840
Five is greater than equal to 05

2228
01:13:18,840 --> 01:13:21,029
is indeed equal to strlen of M text.

2229
01:13:21,029 --> 01:13:22,319
All right, So there is

2230
01:13:22,319 --> 01:13:23,640
a correct implementation of

2231
01:13:23,640 --> 01:13:25,168
our constructor that takes one Arctic,

2232
01:13:25,168 --> 01:13:25,649
alright,

2233
01:13:25,649 --> 01:13:28,560
our constructor that takes no arguments,

2234
01:13:28,560 --> 01:13:30,675
the default constructor that we declared,

2235
01:13:30,675 --> 01:13:32,849
if that's our string t here.

2236
01:13:32,849 --> 01:13:35,413
So our string t, Let's see.

2237
01:13:35,413 --> 01:13:37,304
What we want t to look like

2238
01:13:37,304 --> 01:13:39,854
is, well, the M line should be 0.

2239
01:13:39,854 --> 01:13:41,895
So I guess we could that.

2240
01:13:41,895 --> 01:13:43,469
I decided I do want to go with

2241
01:13:43,469 --> 01:13:45,134
the representation where M text

2242
01:13:45,134 --> 01:13:46,798
is an array of

2243
01:13:46,798 --> 01:13:48,614
dynamically allocated characters.

2244
01:13:48,614 --> 01:13:50,100
So it'll be one character

2245
01:13:50,100 --> 01:13:52,469
and we want that to be the 0 byte.

2246
01:13:52,469 --> 01:13:53,908
So we can say that we

2247
01:13:53,908 --> 01:13:55,050
dynamically allocate an array of

2248
01:13:55,050 --> 01:13:56,368
one character and then

2249
01:13:56,368 --> 01:13:57,913
we set that to the 0 byte.

2250
01:13:57,913 --> 01:13:59,640
So that would be our representation

2251
01:13:59,640 --> 01:14:01,859
of the, the empty string.

2252
01:14:01,859 --> 01:14:04,574
Now be, before I go further,

2253
01:14:04,574 --> 01:14:06,630
I may decide that what I

2254
01:14:06,630 --> 01:14:08,578
want to do is examine

2255
01:14:08,578 --> 01:14:10,199
these two constructors and take

2256
01:14:10,199 --> 01:14:12,555
a look at their implementations.

2257
01:14:12,555 --> 01:14:14,488
And it's a worthwhile exercise.

2258
01:14:14,488 --> 01:14:16,140
You may end up, it may end up proving,

2259
01:14:16,140 --> 01:14:17,729
proving not so valuable,

2260
01:14:17,729 --> 01:14:18,884
but it's worth doing.

2261
01:14:18,884 --> 01:14:20,908
It's a worthwhile exercise to look at.

2262
01:14:20,908 --> 01:14:22,588
These two functions have

2263
01:14:22,588 --> 01:14:24,118
different parameter lists,

2264
01:14:24,118 --> 01:14:25,935
but this one is,

2265
01:14:25,935 --> 01:14:27,838
is shorter than that one.

2266
01:14:27,838 --> 01:14:29,609
There's a possibility of combination

2267
01:14:29,609 --> 01:14:30,734
here or something or, or,

2268
01:14:30,734 --> 01:14:32,368
or just look for commonality

2269
01:14:32,368 --> 01:14:33,659
in the implementations.

2270
01:14:33,659 --> 01:14:35,819
And maybe we might be able to factor that,

2271
01:14:35,819 --> 01:14:37,019
that commonality into

2272
01:14:37,019 --> 01:14:38,864
a common helper function or something.

2273
01:14:38,864 --> 01:14:40,409
So as an exercise,

2274
01:14:40,409 --> 01:14:42,644
what I'm going to try to do is,

2275
01:14:42,644 --> 01:14:44,849
for example, here's the general case

2276
01:14:44,849 --> 01:14:46,668
and here the empty string.

2277
01:14:46,668 --> 01:14:48,229
I'm going to try to

2278
01:14:48,229 --> 01:14:50,569
massage this code and try to make

2279
01:14:50,569 --> 01:14:52,368
this code look more

2280
01:14:52,368 --> 01:14:53,869
like be constructed

2281
01:14:53,869 --> 01:14:55,414
through with one argument code.

2282
01:14:55,414 --> 01:14:57,034
So let's see.

2283
01:14:57,034 --> 01:14:58,850
Well, this one says M texts gets

2284
01:14:58,850 --> 01:14:59,930
a new array of

2285
01:14:59,930 --> 01:15:02,734
characters of length m length plus one.

2286
01:15:02,734 --> 01:15:04,369
This one also says M text

2287
01:15:04,369 --> 01:15:05,868
gets a new array of characters,

2288
01:15:05,868 --> 01:15:07,969
but we just put one here.

2289
01:15:07,969 --> 01:15:09,680
But wait a minute,

2290
01:15:09,680 --> 01:15:11,494
could I make this look more like that?

2291
01:15:11,494 --> 01:15:12,378
Well, sure.

2292
01:15:12,378 --> 01:15:16,743
Mln is 00 plus one is, is one.

2293
01:15:16,743 --> 01:15:19,159
So I could say MLN

2294
01:15:19,159 --> 01:15:22,250
plus one here and that would still be one.

2295
01:15:22,250 --> 01:15:23,509
All right, Well that makes

2296
01:15:23,509 --> 01:15:24,710
that statement look more like

2297
01:15:24,710 --> 01:15:27,954
the other one. How about this one?

2298
01:15:27,954 --> 01:15:29,100
This one sets M.

2299
01:15:29,100 --> 01:15:31,123
Linda strlen of value.

2300
01:15:31,123 --> 01:15:34,168
This one says Sam, lend to 0.

2301
01:15:34,168 --> 01:15:36,899
Could I put like strlen

2302
01:15:36,899 --> 01:15:40,274
of something and have the answer be 0?

2303
01:15:40,274 --> 01:15:41,640
Is there something I

2304
01:15:41,640 --> 01:15:42,989
can replace the dot, dot,

2305
01:15:42,989 --> 01:15:45,029
dot with that will cause

2306
01:15:45,029 --> 01:15:48,689
strlen to return 0 because that

2307
01:15:48,689 --> 01:15:50,698
would then make this produce

2308
01:15:50,698 --> 01:15:54,914
the right result of 0 for M line, the M line.

2309
01:15:54,914 --> 01:15:57,029
But it looks more like the other constructor,

2310
01:15:57,029 --> 01:15:59,234
which is my, my goal for now.

2311
01:15:59,234 --> 01:16:01,470
To see if I can make these look more

2312
01:16:01,470 --> 01:16:03,929
similar to maybe factor out commonality.

2313
01:16:03,929 --> 01:16:05,219
While you think about it for

2314
01:16:05,219 --> 01:16:06,269
a bit and you say, Well,

2315
01:16:06,269 --> 01:16:09,429
the empty string has a length of zeros.

2316
01:16:09,429 --> 01:16:11,189
So if I put a double quote,

2317
01:16:11,189 --> 01:16:12,359
double quote for the empty string,

2318
01:16:12,359 --> 01:16:13,828
that, that would do the trick.

2319
01:16:13,828 --> 01:16:15,779
Okay, well, that's possibly interesting.

2320
01:16:15,779 --> 01:16:17,369
Now how about this last thing?

2321
01:16:17,369 --> 01:16:19,289
Here? I want to make sure that

2322
01:16:19,289 --> 01:16:22,724
the array contains a 0 byte in position 0.

2323
01:16:22,724 --> 01:16:25,259
Here I did a string copy to make

2324
01:16:25,259 --> 01:16:26,550
my array have the text of

2325
01:16:26,550 --> 01:16:28,484
the string with a 0 byte at the end.

2326
01:16:28,484 --> 01:16:30,014
Well, let's try this.

2327
01:16:30,014 --> 01:16:32,158
Could I do what's called a string

2328
01:16:32,158 --> 01:16:35,144
copy into em tags just like the other,

2329
01:16:35,144 --> 01:16:37,109
the other one with something or

2330
01:16:37,109 --> 01:16:40,109
another would end up having M text.

2331
01:16:40,109 --> 01:16:41,519
Look like that.

2332
01:16:41,519 --> 01:16:43,154
Just a 0 byte it,

2333
01:16:43,154 --> 01:16:44,909
is there anything I can copy into

2334
01:16:44,909 --> 01:16:46,784
N M text to do that?

2335
01:16:46,784 --> 01:16:48,194
And I think about it and say, well,

2336
01:16:48,194 --> 01:16:49,828
you know, if you copy the empty string,

2337
01:16:49,828 --> 01:16:51,163
the empty string is,

2338
01:16:51,163 --> 01:16:52,829
the empty string is going to

2339
01:16:52,829 --> 01:16:55,769
be just one character in it with a 0 byte.

2340
01:16:55,769 --> 01:16:57,479
And if I copy that see spring into

2341
01:16:57,479 --> 01:16:59,369
m tax than M text looks like that.

2342
01:16:59,369 --> 01:17:00,779
So the results of

2343
01:17:00,779 --> 01:17:02,279
this exercise is that

2344
01:17:02,279 --> 01:17:03,600
here's another implementation of

2345
01:17:03,600 --> 01:17:05,474
the default constructor that

2346
01:17:05,474 --> 01:17:08,505
looks just like the other constructor,

2347
01:17:08,505 --> 01:17:11,384
except with value being the empty string.

2348
01:17:11,384 --> 01:17:13,543
Well, if that's the case,

2349
01:17:13,543 --> 01:17:16,019
then I can do things the following way.

2350
01:17:16,019 --> 01:17:17,564
I can say, You know what,

2351
01:17:17,564 --> 01:17:18,840
I will just get rid

2352
01:17:18,840 --> 01:17:20,310
of this default constructor

2353
01:17:20,310 --> 01:17:24,283
and provide a default value to use if the,

2354
01:17:24,283 --> 01:17:25,829
if the color of the constructor

2355
01:17:25,829 --> 01:17:27,600
for string leaves off the argument.

2356
01:17:27,600 --> 01:17:29,264
If you leave off the argument,

2357
01:17:29,264 --> 01:17:30,359
act like the arguments,

2358
01:17:30,359 --> 01:17:31,890
the empty string, the double quote,

2359
01:17:31,890 --> 01:17:33,838
double quote, and then I don't even need

2360
01:17:33,838 --> 01:17:37,079
to declare this constructor at all.

2361
01:17:37,079 --> 01:17:39,300
So second I really work well.

2362
01:17:39,300 --> 01:17:40,050
Yeah.

2363
01:17:40,050 --> 01:17:42,149
So if I declares T This

2364
01:17:42,149 --> 01:17:44,488
way, the compiler says,

2365
01:17:44,488 --> 01:17:45,000
Okay,

2366
01:17:45,000 --> 01:17:46,260
it looks like you're trying to construct

2367
01:17:46,260 --> 01:17:47,430
a string and you're not

2368
01:17:47,430 --> 01:17:49,350
passing any arguments to the constructor.

2369
01:17:49,350 --> 01:17:50,863
Is there a constructor

2370
01:17:50,863 --> 01:17:53,145
that can take no arguments?

2371
01:17:53,145 --> 01:17:54,569
Well, I didn't declare

2372
01:17:54,569 --> 01:17:55,649
one that takes no arguments,

2373
01:17:55,649 --> 01:17:56,819
but I did declare one that

2374
01:17:56,819 --> 01:17:58,618
takes one argument and you're

2375
01:17:58,618 --> 01:17:59,998
allowed to leave it off and

2376
01:17:59,998 --> 01:18:02,708
the compiler will supply that argument o.

2377
01:18:02,708 --> 01:18:04,533
So the compiler says, Sure,

2378
01:18:04,533 --> 01:18:07,279
I will act as if you had said create

2379
01:18:07,279 --> 01:18:10,715
t and constructed it from the empty string.

2380
01:18:10,715 --> 01:18:12,079
So the compiler will

2381
01:18:12,079 --> 01:18:13,444
turn in the statement into,

2382
01:18:13,444 --> 01:18:14,809
into this one essentially a call to

2383
01:18:14,809 --> 01:18:16,069
the constructor with one argument

2384
01:18:16,069 --> 01:18:17,149
passing it the empty string.

2385
01:18:17,149 --> 01:18:19,685
So the compiler says, Okay, fine,

2386
01:18:19,685 --> 01:18:21,020
then I'll

2387
01:18:21,020 --> 01:18:22,908
execute this constructor where value

2388
01:18:22,908 --> 01:18:25,668
is a pointer to

2389
01:18:25,668 --> 01:18:27,319
an array of one character

2390
01:18:27,319 --> 01:18:28,520
that has a 0 byte in it.

2391
01:18:28,520 --> 01:18:30,229
Strlen of that is 0.

2392
01:18:30,229 --> 01:18:33,259
So, So t will get 0 for the NLN.

2393
01:18:33,259 --> 01:18:34,759
Dynamically allocate

2394
01:18:34,759 --> 01:18:36,453
an array of one character,

2395
01:18:36,453 --> 01:18:38,359
store a pointer to that an M text,

2396
01:18:38,359 --> 01:18:41,060
and copy the empty string into M text.

2397
01:18:41,060 --> 01:18:43,474
Okay, and so it does, and it works.

2398
01:18:43,474 --> 01:18:45,234
I get t looking like that.

2399
01:18:45,234 --> 01:18:46,019
What I want.

2400
01:18:46,019 --> 01:18:48,479
So you can't always do that.

2401
01:18:48,479 --> 01:18:49,934
Where does that result isn't

2402
01:18:49,934 --> 01:18:52,170
always going to end up being, Hey,

2403
01:18:52,170 --> 01:18:53,488
if I had those two functions

2404
01:18:53,488 --> 01:18:54,719
that were very similar and

2405
01:18:54,719 --> 01:18:55,829
I massage one of them

2406
01:18:55,829 --> 01:18:57,599
to look more like the other one.

2407
01:18:57,599 --> 01:19:00,253
Maybe I could actually combine them into one.

2408
01:19:00,253 --> 01:19:01,560
Doesn't always work.

2409
01:19:01,560 --> 01:19:03,479
This case, it worked out just fine.

2410
01:19:03,479 --> 01:19:06,539
Okay, so we simplified our implementation

2411
01:19:06,539 --> 01:19:08,310
by having that only one function

2412
01:19:08,310 --> 01:19:09,854
to maintain not more than one.

2413
01:19:09,854 --> 01:19:12,689
Alright, so let's see.

2414
01:19:12,689 --> 01:19:14,520
Any other things I want to do with this?

2415
01:19:14,520 --> 01:19:17,250
Well, I do want to think about, well,

2416
01:19:17,250 --> 01:19:19,965
anytime you pass a pointer to a function,

2417
01:19:19,965 --> 01:19:21,779
you should ask yourself,

2418
01:19:21,779 --> 01:19:23,894
what if somebody passes a null pointer?

2419
01:19:23,894 --> 01:19:25,288
That's always possibility.

2420
01:19:25,288 --> 01:19:26,819
They're not supposed to necessarily,

2421
01:19:26,819 --> 01:19:29,100
but think about what to do about that.

2422
01:19:29,100 --> 01:19:31,394
If somebody decides to create a string.

2423
01:19:31,394 --> 01:19:32,880
So let me go back up here.

2424
01:19:32,880 --> 01:19:36,510
Maybe they have a character pointer p,

2425
01:19:36,510 --> 01:19:40,814
and they do some stuff with P. And

2426
01:19:40,814 --> 01:19:43,199
ultimately they're then going to

2427
01:19:43,199 --> 01:19:46,543
create a string with P as an argument.

2428
01:19:46,543 --> 01:19:48,569
So there's some code that sets P somehow.

2429
01:19:48,569 --> 01:19:50,159
And then eventually we decided to say, OK,

2430
01:19:50,159 --> 01:19:52,349
now let's take the C string that p points

2431
01:19:52,349 --> 01:19:55,123
to and, and passed here.

2432
01:19:55,123 --> 01:19:58,140
Now, maybe setting P involve calling

2433
01:19:58,140 --> 01:19:59,789
some function that returns a pointer to

2434
01:19:59,789 --> 01:20:00,779
character that was supposed to

2435
01:20:00,779 --> 01:20:02,024
point to a C string.

2436
01:20:02,024 --> 01:20:03,930
And if the function couldn't do its job,

2437
01:20:03,930 --> 01:20:05,324
it returned a null pointer.

2438
01:20:05,324 --> 01:20:07,559
So it's possible maybe

2439
01:20:07,559 --> 01:20:09,984
that P has the null pointer value.

2440
01:20:09,984 --> 01:20:11,868
If P is a null pointer value,

2441
01:20:11,868 --> 01:20:14,283
then if we call this constructor this way,

2442
01:20:14,283 --> 01:20:16,413
in the environment of the constructor,

2443
01:20:16,413 --> 01:20:19,145
value is going to be the null pointer.

2444
01:20:19,145 --> 01:20:21,590
And our code starts off by saying, okay,

2445
01:20:21,590 --> 01:20:22,788
so let's see, let's

2446
01:20:22,788 --> 01:20:24,109
see what happens when we're constructing.

2447
01:20:24,109 --> 01:20:26,029
You, want to be constructing you.

2448
01:20:26,029 --> 01:20:26,975
So let's see what happens.

2449
01:20:26,975 --> 01:20:28,998
Values, the null pointer value got passed in.

2450
01:20:28,998 --> 01:20:31,533
We call strlen with the null pointer value.

2451
01:20:31,533 --> 01:20:34,550
So the answer for what happens now is

2452
01:20:34,550 --> 01:20:36,048
what does the C library do

2453
01:20:36,048 --> 01:20:38,073
if you pass strlen a null pointer.

2454
01:20:38,073 --> 01:20:39,380
And the C standard

2455
01:20:39,380 --> 01:20:40,458
and the C Plus Plus standard

2456
01:20:40,458 --> 01:20:43,069
agree that that's undefined behavior.

2457
01:20:43,069 --> 01:20:46,429
The strlen function is not obligated to,

2458
01:20:46,429 --> 01:20:48,408
to check for the null pointer and do

2459
01:20:48,408 --> 01:20:49,609
something reasonable that case

2460
01:20:49,609 --> 01:20:50,748
it could crash.

2461
01:20:50,748 --> 01:20:53,119
In fact, on most implementations that crash.

2462
01:20:53,119 --> 01:20:55,760
Okay, So we can't just do this,

2463
01:20:55,760 --> 01:20:57,963
we'll have to check for this ourself

2464
01:20:57,963 --> 01:20:59,435
to, for better safety.

2465
01:20:59,435 --> 01:21:01,248
So we will say, okay,

2466
01:21:01,248 --> 01:21:02,958
if value is in fact

2467
01:21:02,958 --> 01:21:03,993
the null pointer,

2468
01:21:03,993 --> 01:21:05,073
we're going to have to do something.

2469
01:21:05,073 --> 01:21:06,260
So again, now we

2470
01:21:06,260 --> 01:21:07,789
come up with a policy decision.

2471
01:21:07,789 --> 01:21:09,139
What should we do if the user

2472
01:21:09,139 --> 01:21:10,939
gives our string and null pointer?

2473
01:21:10,939 --> 01:21:13,774
Should we say that that's no good.

2474
01:21:13,774 --> 01:21:15,123
We're not gonna let you do that

2475
01:21:15,123 --> 01:21:16,595
or let's think about it.

2476
01:21:16,595 --> 01:21:18,078
If you're a client who passed

2477
01:21:18,078 --> 01:21:19,774
a null pointer to the string constructor,

2478
01:21:19,774 --> 01:21:21,304
knowing that

2479
01:21:21,304 --> 01:21:22,729
you're supposed to pass a pointer to

2480
01:21:22,729 --> 01:21:24,349
some C string plus

2481
01:21:24,349 --> 01:21:26,180
maximum C string like hello,

2482
01:21:26,180 --> 01:21:27,993
or even the empty string.

2483
01:21:27,993 --> 01:21:28,880
In fact, if you don't pass

2484
01:21:28,880 --> 01:21:29,689
any arguments at all,

2485
01:21:29,689 --> 01:21:30,979
you get the empty string.

2486
01:21:30,979 --> 01:21:32,509
I could think it's reasonable to

2487
01:21:32,509 --> 01:21:34,340
assume the null pointer

2488
01:21:34,340 --> 01:21:36,145
should probably produce an empty string two.

2489
01:21:36,145 --> 01:21:38,460
I think that would make sense that if I

2490
01:21:38,460 --> 01:21:40,545
constructed a string and I gave,

2491
01:21:40,545 --> 01:21:41,759
I gave an empty string as

2492
01:21:41,759 --> 01:21:43,350
the argument to the constructor.

2493
01:21:43,350 --> 01:21:45,750
I would expect that if this works,

2494
01:21:45,750 --> 01:21:47,220
it gives me the empty string.

2495
01:21:47,220 --> 01:21:48,884
Okay, I think that's reasonable.

2496
01:21:48,884 --> 01:21:50,055
So let me do that.

2497
01:21:50,055 --> 01:21:52,048
Let me make it so that if you pass

2498
01:21:52,048 --> 01:21:54,645
the null pointer to the string constructor,

2499
01:21:54,645 --> 01:21:55,784
you're going to get the empty string.

2500
01:21:55,784 --> 01:21:57,720
Now, the easiest way to do

2501
01:21:57,720 --> 01:21:58,979
that is rather than

2502
01:21:58,979 --> 01:22:00,599
kind of duplicate this code again,

2503
01:22:00,599 --> 01:22:02,444
let's just say, alright,

2504
01:22:02,444 --> 01:22:03,930
the parameter passed to

2505
01:22:03,930 --> 01:22:06,328
the function value is a local variable.

2506
01:22:06,328 --> 01:22:08,203
And that local variable value

2507
01:22:08,203 --> 01:22:10,033
starts off with a value of the null pointer.

2508
01:22:10,033 --> 01:22:12,300
Well, let's just make that local variable

2509
01:22:12,300 --> 01:22:13,694
now point to the empty string.

2510
01:22:13,694 --> 01:22:16,213
So we can just do that and then proceed.

2511
01:22:16,213 --> 01:22:18,390
So let's see what that's going to do.

2512
01:22:18,390 --> 01:22:20,564
Double quote, double quote.

2513
01:22:20,564 --> 01:22:22,979
As a C string constant, double quote,

2514
01:22:22,979 --> 01:22:24,479
double quote causes the compiler

2515
01:22:24,479 --> 01:22:26,099
to up in memory somewhere

2516
01:22:26,099 --> 01:22:27,750
an array of one character with

2517
01:22:27,750 --> 01:22:30,074
a 0 byte it and returns,

2518
01:22:30,074 --> 01:22:31,319
in this expression returns

2519
01:22:31,319 --> 01:22:32,130
a pointer to that,

2520
01:22:32,130 --> 01:22:33,283
the beginning of that array.

2521
01:22:33,283 --> 01:22:34,738
So the double quote,

2522
01:22:34,738 --> 01:22:35,929
double quote here in

2523
01:22:35,929 --> 01:22:37,529
this statement is going to be

2524
01:22:37,529 --> 01:22:39,720
a pointer to array characters

2525
01:22:39,720 --> 01:22:41,324
that we promised not to modify.

2526
01:22:41,324 --> 01:22:43,798
And we want to store that into value.

2527
01:22:43,798 --> 01:22:45,149
Can hold a pointer to

2528
01:22:45,149 --> 01:22:47,069
character as we promised not to modify.

2529
01:22:47,069 --> 01:22:49,034
Oh, okay, So now

2530
01:22:49,034 --> 01:22:51,269
value contains a pointer to us,

2531
01:22:51,269 --> 01:22:52,875
an array that has 0 byte,

2532
01:22:52,875 --> 01:22:54,359
which is perfect because now

2533
01:22:54,359 --> 01:22:57,899
strlen of that IT value is,

2534
01:22:57,899 --> 01:23:00,448
let me note that this is, it's pointing

2535
01:23:00,448 --> 01:23:03,298
to not a, not a carrier,

2536
01:23:03,298 --> 01:23:05,698
so that it's pointing to

2537
01:23:05,698 --> 01:23:08,264
an array of no character at one character,

2538
01:23:08,264 --> 01:23:10,274
an element 0 that arrays to 0 byte.

2539
01:23:10,274 --> 01:23:12,824
So, so let's call strlen on that,

2540
01:23:12,824 --> 01:23:14,819
that, that pointer to that array, okay,

2541
01:23:14,819 --> 01:23:16,140
Sterling gives us back 0 and

2542
01:23:16,140 --> 01:23:17,969
everything proceeds as we want and we

2543
01:23:17,969 --> 01:23:19,873
end up with you being

2544
01:23:19,873 --> 01:23:22,170
the M text is an array pointer

2545
01:23:22,170 --> 01:23:23,579
to an array that has, it's just a 0.

2546
01:23:23,579 --> 01:23:25,349
Byte, length is 0, so everything works out.

2547
01:23:25,349 --> 01:23:27,045
Okay? There we go.

2548
01:23:27,045 --> 01:23:28,408
We bullet-proof this.

2549
01:23:28,408 --> 01:23:31,168
So now no matter what you pass that,

2550
01:23:31,168 --> 01:23:32,220
we can check for whether you

2551
01:23:32,220 --> 01:23:33,359
pass a pointer to

2552
01:23:33,359 --> 01:23:35,670
a C string or you pass a null pointer,

2553
01:23:35,670 --> 01:23:36,869
we're, we're covered

2554
01:23:36,869 --> 01:23:38,264
and we do something reasonable.

2555
01:23:38,264 --> 01:23:41,323
What the function can't detect is,

2556
01:23:41,323 --> 01:23:43,050
well, what if you pass a pointer

2557
01:23:43,050 --> 01:23:44,850
to an array of characters?

2558
01:23:44,850 --> 01:23:47,220
But that array does

2559
01:23:47,220 --> 01:23:48,689
not contain a 0 byte in it,

2560
01:23:48,689 --> 01:23:50,338
so it's not a valid C string.

2561
01:23:50,338 --> 01:23:51,238
Well, there's no way

2562
01:23:51,238 --> 01:23:52,454
our function can know that.

2563
01:23:52,454 --> 01:23:53,970
Our function only gets

2564
01:23:53,970 --> 01:23:55,319
a pointer to where the array starts.

2565
01:23:55,319 --> 01:23:57,750
It has no idea how many characters make

2566
01:23:57,750 --> 01:23:59,579
up the actual declared size

2567
01:23:59,579 --> 01:24:02,460
of the array versus, versus.

2568
01:24:02,460 --> 01:24:04,199
Going beyond the end of

2569
01:24:04,199 --> 01:24:05,310
the array that it can't tell.

2570
01:24:05,310 --> 01:24:05,534
It.

2571
01:24:05,534 --> 01:24:06,720
It just says I, all I can

2572
01:24:06,720 --> 01:24:09,039
know is go until I see a 0.

2573
01:24:09,199 --> 01:24:10,635
All right,

2574
01:24:10,635 --> 01:24:12,253
sometimes people see things like this.

2575
01:24:12,253 --> 01:24:12,869
Say Wait a minute,

2576
01:24:12,869 --> 01:24:14,444
didn't you say value is const,

2577
01:24:14,444 --> 01:24:15,764
how can you assign to it?

2578
01:24:15,764 --> 01:24:17,533
Well, I'm not saying value is,

2579
01:24:17,533 --> 01:24:19,708
value is a local variable

2580
01:24:19,708 --> 01:24:21,359
of this, of this constructor.

2581
01:24:21,359 --> 01:24:23,130
It can change its value.

2582
01:24:23,130 --> 01:24:24,840
The type of the variable is

2583
01:24:24,840 --> 01:24:26,609
a pointer to constant characters.

2584
01:24:26,609 --> 01:24:28,363
The cost modifies the character.

2585
01:24:28,363 --> 01:24:29,715
The const says that

2586
01:24:29,715 --> 01:24:32,310
that value is a point you to characters,

2587
01:24:32,310 --> 01:24:34,423
and those characters cannot be modified.

2588
01:24:34,423 --> 01:24:36,644
If you try to go through the name value,

2589
01:24:36,644 --> 01:24:37,560
you won't be allowed

2590
01:24:37,560 --> 01:24:38,819
to modify those characters.

2591
01:24:38,819 --> 01:24:39,988
But you can certainly make

2592
01:24:39,988 --> 01:24:42,390
value point to a different array of

2593
01:24:42,390 --> 01:24:44,128
characters that can't be modified or

2594
01:24:44,128 --> 01:24:45,029
yet another array of

2595
01:24:45,029 --> 01:24:46,694
characters that can't be modified.

2596
01:24:46,694 --> 01:24:48,255
So value can point to

2597
01:24:48,255 --> 01:24:50,845
two different arrays over its lifetime.

2598
01:24:50,845 --> 01:24:52,774
It's just the through the name value.

2599
01:24:52,774 --> 01:24:54,198
You can't modify those characters.

2600
01:24:54,198 --> 01:24:55,578
Okay, so we end up with that.

2601
01:24:55,578 --> 01:24:57,079
That's our implementation of the constructor.

2602
01:24:57,079 --> 01:24:58,564
And we say, Okay, fine,

2603
01:24:58,564 --> 01:25:00,408
I guess this code is good.

2604
01:25:00,408 --> 01:25:01,880
And of course, no,

2605
01:25:01,880 --> 01:25:03,078
this code is not good

2606
01:25:03,078 --> 01:25:05,779
because if that's all we've got here,

2607
01:25:05,779 --> 01:25:07,579
we've got memory leaks.

2608
01:25:07,579 --> 01:25:09,948
So the problem is

2609
01:25:09,948 --> 01:25:13,219
that if we call the function h,

2610
01:25:13,219 --> 01:25:15,498
we're setting up three strings.

2611
01:25:15,498 --> 01:25:17,720
So let me stop sharing here.

2612
01:25:17,720 --> 01:25:19,100
And sorry, I have a function h

2613
01:25:19,100 --> 01:25:20,869
recreate a string hello.

2614
01:25:20,869 --> 01:25:22,609
We expect that one's

2615
01:25:22,609 --> 01:25:24,125
good enough to illustrate the problem.

2616
01:25:24,125 --> 01:25:25,474
We call the function h.

2617
01:25:25,474 --> 01:25:27,288
When h creates a string S,

2618
01:25:27,288 --> 01:25:28,970
that constructor is going to dynamically

2619
01:25:28,970 --> 01:25:30,168
allocate an array.

2620
01:25:30,168 --> 01:25:32,163
Similarly, by copy.

2621
01:25:32,163 --> 01:25:32,948
Hello.

2622
01:25:32,948 --> 01:25:34,498
Into the array, great.

2623
01:25:34,498 --> 01:25:36,149
We use S in the function.

2624
01:25:36,149 --> 01:25:37,829
When we leave the function,

2625
01:25:37,829 --> 01:25:39,734
as we had declared our string class,

2626
01:25:39,734 --> 01:25:41,054
when we leave the function,

2627
01:25:41,054 --> 01:25:42,779
local variables go away.

2628
01:25:42,779 --> 01:25:45,555
But S is this object here.

2629
01:25:45,555 --> 01:25:46,963
That's all that S is,

2630
01:25:46,963 --> 01:25:48,224
S is this object.

2631
01:25:48,224 --> 01:25:49,739
And we did not

2632
01:25:49,739 --> 01:25:51,765
declare a destructor for the string type.

2633
01:25:51,765 --> 01:25:54,208
So if you don't declare a destructor

2634
01:25:54,208 --> 01:25:56,670
for the string type, the compiler right?

2635
01:25:56,670 --> 01:25:57,689
One for you.

2636
01:25:57,689 --> 01:26:00,208
And if all the data members

2637
01:26:00,208 --> 01:26:01,814
are simply a built-in type,

2638
01:26:01,814 --> 01:26:03,779
the compiler generated destructor

2639
01:26:03,779 --> 01:26:06,149
does nothing interesting.

2640
01:26:06,149 --> 01:26:08,264
So it just says, okay,

2641
01:26:08,264 --> 01:26:09,719
the instructor finishes and now

2642
01:26:09,719 --> 01:26:11,189
the string object goes away,

2643
01:26:11,189 --> 01:26:12,689
but the dynamically allocated

2644
01:26:12,689 --> 01:26:15,238
array was never released.

2645
01:26:15,238 --> 01:26:17,113
You allocate something with new,

2646
01:26:17,113 --> 01:26:18,359
that storage belongs to

2647
01:26:18,359 --> 01:26:19,663
your program until you

2648
01:26:19,663 --> 01:26:20,939
call delete and pass

2649
01:26:20,939 --> 01:26:22,470
that a pointer to that storage.

2650
01:26:22,470 --> 01:26:24,329
So we have a memory leak

2651
01:26:24,329 --> 01:26:26,220
here every time we call h.

2652
01:26:26,220 --> 01:26:27,899
When it returns, there's

2653
01:26:27,899 --> 01:26:29,173
some storage allocated

2654
01:26:29,173 --> 01:26:30,390
that belongs to our program,

2655
01:26:30,390 --> 01:26:31,618
but we can't get to anymore

2656
01:26:31,618 --> 01:26:33,255
because we have no more pointers to.

2657
01:26:33,255 --> 01:26:34,890
And of course, the problem with memory leaks

2658
01:26:34,890 --> 01:26:36,569
is, is over time,

2659
01:26:36,569 --> 01:26:38,130
if you keep acquiring

2660
01:26:38,130 --> 01:26:41,475
more and more storage that you can't use.

2661
01:26:41,475 --> 01:26:44,279
Eventually some, at some point your program

2662
01:26:44,279 --> 01:26:45,628
runs up and they ask

2663
01:26:45,628 --> 01:26:47,009
for storage from the operating system.

2664
01:26:47,009 --> 01:26:48,163
The operating system says,

2665
01:26:48,163 --> 01:26:50,878
I don't have any more storage giving sorry,

2666
01:26:50,878 --> 01:26:52,649
and your program crashes

2667
01:26:52,649 --> 01:26:54,283
because it doesn't have enough memory,

2668
01:26:54,283 --> 01:26:56,175
even though logically it should,

2669
01:26:56,175 --> 01:26:57,088
because every time we're

2670
01:26:57,088 --> 01:26:58,125
done with the string,

2671
01:26:58,125 --> 01:26:59,670
we don't need the storage anymore,

2672
01:26:59,670 --> 01:27:00,779
but we didn't explicitly

2673
01:27:00,779 --> 01:27:02,474
use delete to give it back.

2674
01:27:02,474 --> 01:27:04,560
So that's the purposes of the destructor.

2675
01:27:04,560 --> 01:27:06,029
The purpose of a destructor,

2676
01:27:06,029 --> 01:27:08,039
the destructor for a class is to

2677
01:27:08,039 --> 01:27:10,890
release any resources that the object

2678
01:27:10,890 --> 01:27:12,960
called that's going away folds

2679
01:27:12,960 --> 01:27:16,529
so that they could potentially be re-used.

2680
01:27:16,529 --> 01:27:18,059
So it motivates you to write

2681
01:27:18,059 --> 01:27:20,475
a destructor is almost invariably

2682
01:27:20,475 --> 01:27:22,529
your objects over

2683
01:27:22,529 --> 01:27:24,944
its lifetime acquire some resource.

2684
01:27:24,944 --> 01:27:26,998
In our case, it was dynamic memory for this,

2685
01:27:26,998 --> 01:27:28,844
it acquires some resource

2686
01:27:28,844 --> 01:27:30,060
and you want to make sure

2687
01:27:30,060 --> 01:27:31,529
when the object goes away,

2688
01:27:31,529 --> 01:27:32,998
the resources released.

2689
01:27:32,998 --> 01:27:34,559
That's why you write destructors.

2690
01:27:34,559 --> 01:27:39,600
And so let me note the behavior destructors.

2691
01:27:39,600 --> 01:27:42,208
Now, I said we have here that the way

2692
01:27:42,208 --> 01:27:43,319
construction works

2693
01:27:43,319 --> 01:27:44,908
is whenever you have a constructor,

2694
01:27:44,908 --> 01:27:45,960
the compiler or

2695
01:27:45,960 --> 01:27:47,579
the constructor goes through three steps.

2696
01:27:47,579 --> 01:27:49,545
Step one isn't relevant to us yet.

2697
01:27:49,545 --> 01:27:52,109
Step 2 is construct the data members.

2698
01:27:52,109 --> 01:27:53,849
And we said how to do that.

2699
01:27:53,849 --> 01:27:56,099
Step 3 is due the body, the constructor.

2700
01:27:56,099 --> 01:27:58,198
Oh, by the way, I wrote

2701
01:27:58,198 --> 01:28:00,614
my constructor here and I didn't mention,

2702
01:28:00,614 --> 01:28:01,109
I didn't use

2703
01:28:01,109 --> 01:28:02,880
the memory initialization list to

2704
01:28:02,880 --> 01:28:04,199
initialize M line and M

2705
01:28:04,199 --> 01:28:05,970
text there built-in types,

2706
01:28:05,970 --> 01:28:07,363
they would be left on initialized

2707
01:28:07,363 --> 01:28:09,134
by step to a construction.

2708
01:28:09,134 --> 01:28:11,939
And instead I, I gave them their values.

2709
01:28:11,939 --> 01:28:13,274
And step 3 of construction,

2710
01:28:13,274 --> 01:28:15,270
partly because these are

2711
01:28:15,270 --> 01:28:17,130
slightly more complicated expressions.

2712
01:28:17,130 --> 01:28:19,769
I'm not just setting MLN to a simple value.

2713
01:28:19,769 --> 01:28:21,210
It's going to be the result

2714
01:28:21,210 --> 01:28:22,800
of calling strlen.

2715
01:28:22,800 --> 01:28:26,039
But I don't want to call strlen until after.

2716
01:28:26,039 --> 01:28:28,123
I know that values, not the null pointer.

2717
01:28:28,123 --> 01:28:29,158
And I don't want to initialize

2718
01:28:29,158 --> 01:28:30,644
M text until I've,

2719
01:28:30,644 --> 01:28:32,385
I've figured out m land.

2720
01:28:32,385 --> 01:28:34,170
And so to try to do that in

2721
01:28:34,170 --> 01:28:35,460
the membrane initialization list

2722
01:28:35,460 --> 01:28:36,750
makes it get pretty ugly.

2723
01:28:36,750 --> 01:28:38,189
The member initialization list

2724
01:28:38,189 --> 01:28:39,689
would have to arrange to

2725
01:28:39,689 --> 01:28:41,729
initialize m LAN using

2726
01:28:41,729 --> 01:28:43,484
some expression that will,

2727
01:28:43,484 --> 01:28:45,569
that will either be 0 if values

2728
01:28:45,569 --> 01:28:48,118
a null pointer or strlen a value of it's not.

2729
01:28:48,118 --> 01:28:50,399
And that gets more complicated and ugly.

2730
01:28:50,399 --> 01:28:51,359
So.

2731
01:28:51,359 --> 01:28:53,338
In this case, I chose not to use

2732
01:28:53,338 --> 01:28:55,198
the member initialization list to

2733
01:28:55,198 --> 01:28:56,279
initialize the data members

2734
01:28:56,279 --> 01:28:57,868
here because they're excuse.

2735
01:28:57,868 --> 01:28:59,069
There are some complicated stuff

2736
01:28:59,069 --> 01:29:00,104
that had to happen.

2737
01:29:00,104 --> 01:29:01,394
Anyway.

2738
01:29:01,394 --> 01:29:03,074
How does destruction work?

2739
01:29:03,074 --> 01:29:04,500
Well, the destructor also

2740
01:29:04,500 --> 01:29:05,729
goes through three steps,

2741
01:29:05,729 --> 01:29:08,849
and it's essentially kind

2742
01:29:08,849 --> 01:29:10,109
of the opposite of

2743
01:29:10,109 --> 01:29:12,149
construction in reverse order.

2744
01:29:12,149 --> 01:29:14,128
You do what the constructor does in

2745
01:29:14,128 --> 01:29:15,418
the opposite order and

2746
01:29:15,418 --> 01:29:16,949
you destroy instead of create.

2747
01:29:16,949 --> 01:29:17,878
So the first thing that

2748
01:29:17,878 --> 01:29:19,498
happens when a destructor gets

2749
01:29:19,498 --> 01:29:20,819
executed is the body

2750
01:29:20,819 --> 01:29:22,168
of the destructor gets executed,

2751
01:29:22,168 --> 01:29:26,038
then each data member is somehow destroyed.

2752
01:29:26,038 --> 01:29:27,719
What does that look like? Well, if

2753
01:29:27,719 --> 01:29:29,369
it's a built-in type, do nothing.

2754
01:29:29,369 --> 01:29:32,698
So if a data member as an int or a double,

2755
01:29:32,698 --> 01:29:35,234
a pointer or anything of a built-in type.

2756
01:29:35,234 --> 01:29:36,463
Nothing happens if it's

2757
01:29:36,463 --> 01:29:38,010
a class type that it'll

2758
01:29:38,010 --> 01:29:40,003
call that classes destructor,

2759
01:29:40,003 --> 01:29:42,989
okay, and then step 3 corresponds to step 1,

2760
01:29:42,989 --> 01:29:44,100
which we don't know anything about it.

2761
01:29:44,100 --> 01:29:45,944
So fill that in later.

2762
01:29:45,944 --> 01:29:47,279
Okay, since I did not

2763
01:29:47,279 --> 01:29:48,539
write a destructor for string,

2764
01:29:48,539 --> 01:29:49,588
the compiler rights and for

2765
01:29:49,588 --> 01:29:51,328
me that has an empty body.

2766
01:29:51,328 --> 01:29:54,029
So the way my strings get destroyed,

2767
01:29:54,029 --> 01:29:55,859
as I said, is not very good.

2768
01:29:55,859 --> 01:29:58,770
We do nothing for the body, the distracter.

2769
01:29:58,770 --> 01:30:00,975
And the two data member types

2770
01:30:00,975 --> 01:30:02,788
are built-in types,

2771
01:30:02,788 --> 01:30:04,109
character star, and ends.

2772
01:30:04,109 --> 01:30:06,298
So to start this step

2773
01:30:06,298 --> 01:30:08,399
2 does nothing for them.

2774
01:30:08,399 --> 01:30:09,885
And so we're left where?

2775
01:30:09,885 --> 01:30:11,925
Okay, now the string goes away,

2776
01:30:11,925 --> 01:30:13,500
but the dynamic storage for

2777
01:30:13,500 --> 01:30:15,944
the text to the string, It's still there.

2778
01:30:15,944 --> 01:30:17,548
So we gotta write a destructor for

2779
01:30:17,548 --> 01:30:19,229
the string type to clean that up.

2780
01:30:19,229 --> 01:30:21,764
So my string class will

2781
01:30:21,764 --> 01:30:24,524
have an instructor that I'll declare

2782
01:30:24,524 --> 01:30:26,564
and I will implement it.

2783
01:30:26,564 --> 01:30:29,399
Now the job of the destructor is to

2784
01:30:29,399 --> 01:30:31,259
leave the object in a state

2785
01:30:31,259 --> 01:30:33,359
where step 2 in step 1,

2786
01:30:33,359 --> 01:30:36,314
step 3 of destruction, finished the job.

2787
01:30:36,314 --> 01:30:39,373
Okay, So in my case,

2788
01:30:39,373 --> 01:30:41,819
all I've got is my string has

2789
01:30:41,819 --> 01:30:44,849
a pointer to dynamic storage and an integer.

2790
01:30:44,849 --> 01:30:47,130
The integer, there's nothing special to do.

2791
01:30:47,130 --> 01:30:48,479
The pointer, there'd be nothing special to

2792
01:30:48,479 --> 01:30:49,979
do once I got rid of that storage.

2793
01:30:49,979 --> 01:30:53,189
So all I have to do is get rid

2794
01:30:53,189 --> 01:30:55,783
of the dynamically allocated array

2795
01:30:55,783 --> 01:30:57,180
and that's the wrong way to do it.

2796
01:30:57,180 --> 01:30:59,550
So there's an annoying

2797
01:30:59,550 --> 01:31:01,079
little detail about C plus

2798
01:31:01,079 --> 01:31:02,939
plus when it comes to storage allocation and

2799
01:31:02,939 --> 01:31:05,595
deallocation that we have to deal with.

2800
01:31:05,595 --> 01:31:09,658
If you allocate something as a single object.

2801
01:31:09,658 --> 01:31:10,859
So maybe I have

2802
01:31:10,859 --> 01:31:12,554
some constructor parameters as well.

2803
01:31:12,554 --> 01:31:16,469
If I dynamically allocate one blah, object.

2804
01:31:16,469 --> 01:31:19,350
There it is with some constructor parameters.

2805
01:31:19,350 --> 01:31:20,460
If, if, if I want to

2806
01:31:20,460 --> 01:31:21,719
default construct the blob,

2807
01:31:21,719 --> 01:31:23,069
take this dynamically allocated,

2808
01:31:23,069 --> 01:31:24,929
I can leave off the, the parameters

2809
01:31:24,929 --> 01:31:27,298
Anna and leave off the parentheses if I like.

2810
01:31:27,298 --> 01:31:30,465
In any event, whichever way I do it,

2811
01:31:30,465 --> 01:31:32,173
this will create one blah,

2812
01:31:32,173 --> 01:31:34,844
objects and BP will point to it.

2813
01:31:34,844 --> 01:31:37,305
And when it's time for, to get rid of it,

2814
01:31:37,305 --> 01:31:38,729
you pass the pointer to that Blob

2815
01:31:38,729 --> 01:31:40,784
object, delete this way.

2816
01:31:40,784 --> 01:31:43,738
On the other hand, if

2817
01:31:43,738 --> 01:31:46,635
I declare an array of objects,

2818
01:31:46,635 --> 01:31:48,479
dynamically allocate an array of objects.

2819
01:31:48,479 --> 01:31:50,128
So let's say I dynamically allocate

2820
01:31:50,128 --> 01:31:52,184
an array of a 100 foo objects.

2821
01:31:52,184 --> 01:31:53,670
Now in order to have an array of

2822
01:31:53,670 --> 01:31:55,470
objects that have some type,

2823
01:31:55,470 --> 01:31:57,090
that type has to have a default constructor.

2824
01:31:57,090 --> 01:31:59,639
So, so foo, I'm assuming Foo has

2825
01:31:59,639 --> 01:32:00,899
a default constructor that

2826
01:32:00,899 --> 01:32:03,449
properly initializes a full object.

2827
01:32:03,449 --> 01:32:04,590
So that default constructor

2828
01:32:04,590 --> 01:32:05,309
will be called a 100

2829
01:32:05,309 --> 01:32:06,449
times one for each

2830
01:32:06,449 --> 01:32:07,934
of the four objects in the array.

2831
01:32:07,934 --> 01:32:09,734
So this will dynamically allocate

2832
01:32:09,734 --> 01:32:10,859
an array of a 100 items.

2833
01:32:10,859 --> 01:32:14,078
Nfp will point to element 0 of that array.

2834
01:32:14,119 --> 01:32:16,963
When it comes time to get rid of it,

2835
01:32:16,963 --> 01:32:21,373
you must use the array form of delete.

2836
01:32:21,373 --> 01:32:23,550
Let's delete an empty pair of

2837
01:32:23,550 --> 01:32:26,439
square brackets and the pointer.

2838
01:32:26,750 --> 01:32:28,619
Why?

2839
01:32:28,619 --> 01:32:30,644
There is a long reason for that.

2840
01:32:30,644 --> 01:32:32,594
But that's the role of the language.

2841
01:32:32,594 --> 01:32:35,909
If you allocate a single item, then with new,

2842
01:32:35,909 --> 01:32:37,109
then you delete it with

2843
01:32:37,109 --> 01:32:38,850
a single object form of nu,

2844
01:32:38,850 --> 01:32:40,559
which has no square brackets.

2845
01:32:40,559 --> 01:32:44,024
If you allocate an array of items with new,

2846
01:32:44,024 --> 01:32:45,958
when you delete it, you've gotta use

2847
01:32:45,958 --> 01:32:48,729
the delete square bracket form.

2848
01:32:48,979 --> 01:32:52,149
You pass appointed element 0, that array,

2849
01:32:52,149 --> 01:32:54,810
and two to delete square bracket,

2850
01:32:54,810 --> 01:32:55,288
and that'll,

2851
01:32:55,288 --> 01:32:57,045
that'll clean up the array properly.

2852
01:32:57,045 --> 01:32:59,864
Other restrictions are, if you

2853
01:32:59,864 --> 01:33:03,029
dynamically allocated an array.

2854
01:33:03,029 --> 01:33:05,970
The only pointer related to that array,

2855
01:33:05,970 --> 01:33:07,500
this legal to pass to delete

2856
01:33:07,500 --> 01:33:09,029
square brackets is a pointer

2857
01:33:09,029 --> 01:33:10,708
to element 0 of the array.

2858
01:33:10,708 --> 01:33:12,435
You can't, for example,

2859
01:33:12,435 --> 01:33:15,555
allocate a 100 element array,

2860
01:33:15,555 --> 01:33:17,489
get back a pointer to the beginning of

2861
01:33:17,489 --> 01:33:19,213
that array and decide,

2862
01:33:19,213 --> 01:33:20,609
you know, what, I want to get

2863
01:33:20,609 --> 01:33:22,515
rid of the last 20 elements.

2864
01:33:22,515 --> 01:33:24,599
So I will call delete

2865
01:33:24,599 --> 01:33:27,704
passing in a pointer to say FP plus 8.

2866
01:33:27,704 --> 01:33:30,000
So FP plus 80 would be

2867
01:33:30,000 --> 01:33:33,225
a pointer value that points two element,

2868
01:33:33,225 --> 01:33:34,963
element 80 of the array.

2869
01:33:34,963 --> 01:33:36,239
And you're hoping maybe

2870
01:33:36,239 --> 01:33:37,168
to get rid of elements

2871
01:33:37,168 --> 01:33:38,698
8399 to the array by

2872
01:33:38,698 --> 01:33:40,484
calling delete with that value.

2873
01:33:40,484 --> 01:33:42,675
Not allow undefined behavior.

2874
01:33:42,675 --> 01:33:44,670
The only pointer you can pass

2875
01:33:44,670 --> 01:33:46,829
to delete square bracket is,

2876
01:33:46,829 --> 01:33:48,179
is the same pointer value

2877
01:33:48,179 --> 01:33:49,139
that was given to you by now.

2878
01:33:49,139 --> 01:33:50,340
It could be in a different variable,

2879
01:33:50,340 --> 01:33:50,713
but it's a lot.

2880
01:33:50,713 --> 01:33:51,748
It's gotta be, it's gotta be

2881
01:33:51,748 --> 01:33:54,760
the address of element 0 of that array.

2882
01:33:54,890 --> 01:33:59,439
So, so there's, there's a limitation here.

2883
01:33:59,720 --> 01:34:02,265
Briefly.

2884
01:34:02,265 --> 01:34:05,399
The reason for having two different forms of

2885
01:34:05,399 --> 01:34:08,594
delete is basically an optimization,

2886
01:34:08,594 --> 01:34:11,399
a storage optimization decision by

2887
01:34:11,399 --> 01:34:14,788
Stroustrup in designing C plus plus, that,

2888
01:34:14,788 --> 01:34:17,010
if you have a pointer to a single object,

2889
01:34:17,010 --> 01:34:19,259
the only bookkeeping information you really,

2890
01:34:19,259 --> 01:34:20,939
the storage allocator really needs

2891
01:34:20,939 --> 01:34:23,399
is where is that object and how big is it?

2892
01:34:23,399 --> 01:34:25,454
So, so basically how big is that?

2893
01:34:25,454 --> 01:34:26,729
And obviously there's one

2894
01:34:26,729 --> 01:34:28,020
object if it's a class type,

2895
01:34:28,020 --> 01:34:29,189
I've got to call the destructor for

2896
01:34:29,189 --> 01:34:31,349
that class and get rid of the one object.

2897
01:34:31,349 --> 01:34:34,350
If you're dynamically allocating an array,

2898
01:34:34,350 --> 01:34:36,675
then the bookkeeping information

2899
01:34:36,675 --> 01:34:38,010
has to be a little more than that.

2900
01:34:38,010 --> 01:34:41,055
It can't just be how big is the array?

2901
01:34:41,055 --> 01:34:42,720
You know, I know, I know,

2902
01:34:42,720 --> 01:34:44,179
I know the type of object and,

2903
01:34:44,179 --> 01:34:46,543
and there's an end, and here's the array.

2904
01:34:46,543 --> 01:34:48,539
Because it needs to

2905
01:34:48,539 --> 01:34:49,859
know more than for a single object.

2906
01:34:49,859 --> 01:34:51,509
For single object, There's only one,

2907
01:34:51,509 --> 01:34:53,503
an array, there's a bunch.

2908
01:34:53,503 --> 01:34:55,050
And because there's a bunch,

2909
01:34:55,050 --> 01:34:56,578
that means the destructor

2910
01:34:56,578 --> 01:34:58,109
has to be called a bunch of times.

2911
01:34:58,109 --> 01:35:01,439
So there's more work to get rid of

2912
01:35:01,439 --> 01:35:03,088
an array because the destructor

2913
01:35:03,088 --> 01:35:04,590
is being called a certain number of times,

2914
01:35:04,590 --> 01:35:05,010
then there has to

2915
01:35:05,010 --> 01:35:06,088
be some bookkeeping information,

2916
01:35:06,088 --> 01:35:07,469
the records that there's

2917
01:35:07,469 --> 01:35:08,640
some number of times.

2918
01:35:08,640 --> 01:35:11,939
So the bookkeeping and information needed

2919
01:35:11,939 --> 01:35:13,560
for an array is more

2920
01:35:13,560 --> 01:35:16,005
than that for a single object.

2921
01:35:16,005 --> 01:35:19,229
And so, because there's like

2922
01:35:19,229 --> 01:35:21,613
two different ways or

2923
01:35:21,613 --> 01:35:23,128
two different things that we have to keep.

2924
01:35:23,128 --> 01:35:24,180
One is information for

2925
01:35:24,180 --> 01:35:25,139
a single object versus

2926
01:35:25,139 --> 01:35:26,399
information for an array.

2927
01:35:26,399 --> 01:35:28,529
You've gotta help the compiler a lot though

2928
01:35:28,529 --> 01:35:31,304
the runtime system along by indicating which,

2929
01:35:31,304 --> 01:35:33,270
which version is using.

2930
01:35:33,270 --> 01:35:35,719
There are some thoughts about well,

2931
01:35:35,719 --> 01:35:37,319
I started I went through the thought of well,

2932
01:35:37,319 --> 01:35:39,060
why not just have 11 form

2933
01:35:39,060 --> 01:35:40,663
for the booking information?

2934
01:35:40,663 --> 01:35:41,909
If there's only one form for

2935
01:35:41,909 --> 01:35:43,168
the bookkeeping information and there's

2936
01:35:43,168 --> 01:35:45,720
only one form of delete we need.

2937
01:35:45,720 --> 01:35:48,390
So why don't we just have

2938
01:35:48,390 --> 01:35:49,679
the storage allocator

2939
01:35:49,679 --> 01:35:52,184
treat a single object

2940
01:35:52,184 --> 01:35:53,969
as an array of one object.

2941
01:35:53,969 --> 01:35:56,145
So I'm saying it looks like the same thing.

2942
01:35:56,145 --> 01:35:58,439
Then everything is conceptually to the,

2943
01:35:58,439 --> 01:36:00,930
to the storage allocator, an array.

2944
01:36:00,930 --> 01:36:01,770
And so we can just

2945
01:36:01,770 --> 01:36:02,953
use the same algorithm there.

2946
01:36:02,953 --> 01:36:04,439
Well, the problem is if you have

2947
01:36:04,439 --> 01:36:05,984
a million single objects,

2948
01:36:05,984 --> 01:36:07,469
then since

2949
01:36:07,469 --> 01:36:10,243
the bookkeeping information for an array,

2950
01:36:10,243 --> 01:36:11,609
if we're treating each one of

2951
01:36:11,609 --> 01:36:13,064
them is an array of one object,

2952
01:36:13,064 --> 01:36:14,338
takes up more room than

2953
01:36:14,338 --> 01:36:15,359
a bookkeeping information for

2954
01:36:15,359 --> 01:36:17,878
just a single object in the normal sense,

2955
01:36:17,878 --> 01:36:21,059
then it's a lot of extra storage.

2956
01:36:21,059 --> 01:36:22,408
So blah, blah, blah.

2957
01:36:22,408 --> 01:36:23,130
You don't have to understand

2958
01:36:23,130 --> 01:36:23,939
that explanation at all.

2959
01:36:23,939 --> 01:36:25,425
I didn't give it very well.

2960
01:36:25,425 --> 01:36:26,849
The basic problem is

2961
01:36:26,849 --> 01:36:28,529
that the choice was either

2962
01:36:28,529 --> 01:36:30,029
simplify the language by

2963
01:36:30,029 --> 01:36:32,175
having one short one form of delete,

2964
01:36:32,175 --> 01:36:34,649
at the expense of taking up

2965
01:36:34,649 --> 01:36:36,449
more storage for lots and lots of

2966
01:36:36,449 --> 01:36:38,505
dynamically allocated single objects.

2967
01:36:38,505 --> 01:36:42,104
Or optimize the storage performance.

2968
01:36:42,104 --> 01:36:45,359
And just put the burden on the programmer to,

2969
01:36:45,359 --> 01:36:47,220
to distinguish between deleting

2970
01:36:47,220 --> 01:36:49,515
a single item or distinguishing an array.

2971
01:36:49,515 --> 01:36:51,014
He chose the latter.

2972
01:36:51,014 --> 01:36:52,979
One of the design goals of C plus plus

2973
01:36:52,979 --> 01:36:54,779
is for high-performance applications.

2974
01:36:54,779 --> 01:36:57,719
That also means not needlessly.

2975
01:36:57,719 --> 01:36:58,708
Using storage.

2976
01:36:58,708 --> 01:37:00,000
If you can come up with a way where,

2977
01:37:00,000 --> 01:37:00,298
where there's

2978
01:37:00,298 --> 01:37:02,100
a more efficient representation.

2979
01:37:02,100 --> 01:37:04,694
So the bird was passed on to us.

2980
01:37:04,694 --> 01:37:08,984
And so that means we have to keep track of

2981
01:37:08,984 --> 01:37:10,470
our pointers if we're dynamically

2982
01:37:10,470 --> 01:37:11,639
allocating something and

2983
01:37:11,639 --> 01:37:12,868
storing the result in a pointer

2984
01:37:12,868 --> 01:37:14,399
when it comes time to get rid of it,

2985
01:37:14,399 --> 01:37:16,960
you have to know how it was allocated.

2986
01:37:17,090 --> 01:37:19,559
Now in our case that simple

2987
01:37:19,559 --> 01:37:22,664
because we're always allocating an array.

2988
01:37:22,664 --> 01:37:23,878
So we know we're going

2989
01:37:23,878 --> 01:37:25,003
to be deleting an array.

2990
01:37:25,003 --> 01:37:27,359
And therefore, the correct implementation of

2991
01:37:27,359 --> 01:37:28,875
our destructor would be

2992
01:37:28,875 --> 01:37:30,810
to use the re-form the Delete.

2993
01:37:30,810 --> 01:37:32,264
Now that is correct.

2994
01:37:32,264 --> 01:37:34,409
Delete the stories that I'm texts 0.2,

2995
01:37:34,409 --> 01:37:35,939
which was allocated as an array.

2996
01:37:35,939 --> 01:37:37,904
So we use the array form of delete.

2997
01:37:37,904 --> 01:37:39,538
So now we have

2998
01:37:39,538 --> 01:37:41,849
our destructor correctly implemented

2999
01:37:41,849 --> 01:37:45,569
and that should solve

3000
01:37:45,569 --> 01:37:47,069
our resource management problems.

3001
01:37:47,069 --> 01:37:48,164
Australia.

3002
01:37:48,164 --> 01:37:50,279
Oh no, it does not.

3003
01:37:50,279 --> 01:37:51,764
There's still more.

3004
01:37:51,764 --> 01:37:53,925
We have the string class has some,

3005
01:37:53,925 --> 01:37:55,828
some serious problems that,

3006
01:37:55,828 --> 01:37:57,554
that we need to fix.

3007
01:37:57,554 --> 01:37:59,759
So I mean this part's fine.

3008
01:37:59,759 --> 01:38:00,719
They construct is find

3009
01:38:00,719 --> 01:38:01,904
the destructor is fine.

3010
01:38:01,904 --> 01:38:03,538
But there's more we need to

3011
01:38:03,538 --> 01:38:06,014
do to get correct behavior.

3012
01:38:06,014 --> 01:38:08,760
Let me just note that the steps of

3013
01:38:08,760 --> 01:38:15,420
destruction explain why we're okay.

3014
01:38:15,420 --> 01:38:17,850
Again, I had this employee type at some point

3015
01:38:17,850 --> 01:38:21,128
where let me go back.

3016
01:38:22,029 --> 01:38:24,708
We had this employee type and

3017
01:38:24,708 --> 01:38:26,628
this employee type it

3018
01:38:26,628 --> 01:38:29,375
back and see us 31 before I even saw classes.

3019
01:38:29,375 --> 01:38:31,069
We had this employee type that a

3020
01:38:31,069 --> 01:38:33,274
string, a double-ended end.

3021
01:38:33,274 --> 01:38:36,140
Now, if you create an employee,

3022
01:38:36,140 --> 01:38:38,210
that means each employee objects going to

3023
01:38:38,210 --> 01:38:40,204
have a data member of type string,

3024
01:38:40,204 --> 01:38:42,260
which probably has a pointer to

3025
01:38:42,260 --> 01:38:43,488
a dynamically allocated

3026
01:38:43,488 --> 01:38:44,538
array of characters for

3027
01:38:44,538 --> 01:38:45,979
the persons name is

3028
01:38:45,979 --> 01:38:47,149
strings generally will have

3029
01:38:47,149 --> 01:38:48,769
a pointer to the dynamically allocated array

3030
01:38:48,769 --> 01:38:50,239
of characters for the text.

3031
01:38:50,239 --> 01:38:52,069
At a double Internet.

3032
01:38:52,069 --> 01:38:55,279
We did not write a destructor for this type.

3033
01:38:55,279 --> 01:38:57,319
So if I have

3034
01:38:57,319 --> 01:38:59,088
an employee variable and later

3035
01:38:59,088 --> 01:39:01,128
on we leave the scope of that variable.

3036
01:39:01,128 --> 01:39:02,000
We leave the function where

3037
01:39:02,000 --> 01:39:03,654
that variable is declared.

3038
01:39:03,654 --> 01:39:06,613
The destructor for E gets called.

3039
01:39:06,613 --> 01:39:09,359
So we didn't write

3040
01:39:09,359 --> 01:39:10,889
a destructor for the employee types,

3041
01:39:10,889 --> 01:39:12,029
so the compiler writes one for

3042
01:39:12,029 --> 01:39:13,333
us that has an empty body.

3043
01:39:13,333 --> 01:39:14,729
Now why did we not have

3044
01:39:14,729 --> 01:39:16,680
a problem here with a memory leak?

3045
01:39:16,680 --> 01:39:19,859
Well, when the destructor

3046
01:39:19,859 --> 01:39:22,274
for this employee is called,

3047
01:39:22,274 --> 01:39:24,899
step one does nothing

3048
01:39:24,899 --> 01:39:26,399
because the compiler generate

3049
01:39:26,399 --> 01:39:28,260
the destructor has an empty body.

3050
01:39:28,260 --> 01:39:31,229
Step 2 says Destroy each data member.

3051
01:39:31,229 --> 01:39:33,720
So those of a built-in type, we do nothing.

3052
01:39:33,720 --> 01:39:35,429
So nothing happens regarding

3053
01:39:35,429 --> 01:39:37,569
the salary and the age.

3054
01:39:37,819 --> 01:39:40,048
But the name is

3055
01:39:40,048 --> 01:39:42,329
a string, that's a class type.

3056
01:39:42,329 --> 01:39:44,309
Name is a string.

3057
01:39:44,309 --> 01:39:46,395
String has a pointer to dynamic storage

3058
01:39:46,395 --> 01:39:48,930
0 should or we can have a memory leak?

3059
01:39:48,930 --> 01:39:51,779
No, because if the data members of

3060
01:39:51,779 --> 01:39:54,149
a class type that classes

3061
01:39:54,149 --> 01:39:55,769
destructor gets called,

3062
01:39:55,769 --> 01:39:57,015
destructor gets called.

3063
01:39:57,015 --> 01:39:58,739
So the string destructor will take

3064
01:39:58,739 --> 01:40:01,034
care of cleaning up this data member,

3065
01:40:01,034 --> 01:40:03,795
which is good and makes sense because,

3066
01:40:03,795 --> 01:40:05,279
why should we have to

3067
01:40:05,279 --> 01:40:06,958
know the details of how string is

3068
01:40:06,958 --> 01:40:08,939
implemented in order to

3069
01:40:08,939 --> 01:40:10,993
write an employee destructor.

3070
01:40:10,993 --> 01:40:13,529
If string chooses to dynamically

3071
01:40:13,529 --> 01:40:14,670
allocate storage as

3072
01:40:14,670 --> 01:40:16,484
part of this representation,

3073
01:40:16,484 --> 01:40:18,239
string is presumably

3074
01:40:18,239 --> 01:40:20,024
responsible for cleaning it up.

3075
01:40:20,024 --> 01:40:21,958
We, the designer or the employee

3076
01:40:21,958 --> 01:40:23,835
type should not have to worry about that.

3077
01:40:23,835 --> 01:40:25,139
And I don't care how strings

3078
01:40:25,139 --> 01:40:26,189
are implemented as long as

3079
01:40:26,189 --> 01:40:28,588
I know that strings a reasonable type,

3080
01:40:28,588 --> 01:40:29,789
the cleans up after itself.

3081
01:40:29,789 --> 01:40:31,005
When strings go away.

3082
01:40:31,005 --> 01:40:32,849
Then I'll just use strings

3083
01:40:32,849 --> 01:40:33,899
and it'll take care

3084
01:40:33,899 --> 01:40:35,895
that the dynamic storage form.

3085
01:40:35,895 --> 01:40:38,399
So that's why this, this employee type

3086
01:40:38,399 --> 01:40:39,793
worked out fine without a memory leak,

3087
01:40:39,793 --> 01:40:41,368
even though the string for the name

3088
01:40:41,368 --> 01:40:43,333
might have had pointer dynamic storage.

3089
01:40:43,333 --> 01:40:44,970
The strain destructor took care of

3090
01:40:44,970 --> 01:40:46,319
that and the rules of destruction,

3091
01:40:46,319 --> 01:40:48,208
make sure the string destructor got called.

3092
01:40:48,208 --> 01:40:49,380
Even though we didn't mentioned

3093
01:40:49,380 --> 01:40:51,015
a destructor for employee at all.

3094
01:40:51,015 --> 01:40:52,798
Okay, So we have a destructor for

3095
01:40:52,798 --> 01:40:54,210
our string class, which is good.

3096
01:40:54,210 --> 01:40:55,649
But as I said before,

3097
01:40:55,649 --> 01:40:56,849
we still have some resource

3098
01:40:56,849 --> 01:40:58,215
management problems here.

3099
01:40:58,215 --> 01:41:00,404
And we'll take a look at that next time.

3100
01:41:00,404 --> 01:41:03,609
So let me end the recording here.
