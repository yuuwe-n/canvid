1
00:00:04,120 --> 00:00:07,139
Okay. Last time we started on the issue of

2
00:00:07,139 --> 00:00:09,580
resource management using it as an example,

3
00:00:09,580 --> 00:00:11,060
designing a string class,

4
00:00:11,060 --> 00:00:12,320
pretending we didn't already

5
00:00:12,320 --> 00:00:13,038
have such a class

6
00:00:13,038 --> 00:00:14,099
available in the standard

7
00:00:14,099 --> 00:00:15,399
C plus plus library.

8
00:00:15,399 --> 00:00:17,160
We decided that a string object will hold

9
00:00:17,160 --> 00:00:19,539
a pointer to a dynamically allocated array.

10
00:00:19,539 --> 00:00:21,338
We wrote a constructor that allocates

11
00:00:21,338 --> 00:00:22,839
C array when a string is created,

12
00:00:22,839 --> 00:00:24,059
and we realized that we needed to

13
00:00:24,059 --> 00:00:25,539
write a destructor to ensure that

14
00:00:25,539 --> 00:00:27,018
that array is deallocated

15
00:00:27,018 --> 00:00:28,678
when the string object goes away.

16
00:00:28,678 --> 00:00:29,638
If we didn't do that,

17
00:00:29,638 --> 00:00:30,980
we'd have a memory leak.

18
00:00:30,980 --> 00:00:33,238
Now, you might think, Okay, that was easy,

19
00:00:33,238 --> 00:00:34,539
grab storage at creation,

20
00:00:34,539 --> 00:00:35,719
give it back when the string

21
00:00:35,719 --> 00:00:37,219
goes away. We're done, right?

22
00:00:37,219 --> 00:00:39,503
If so, you'd be very wrong.

23
00:00:39,503 --> 00:00:42,668
So let me pose a new problem now and

24
00:00:42,668 --> 00:00:44,969
see where we fall flat

25
00:00:44,969 --> 00:00:46,109
on our faces with the

26
00:00:46,109 --> 00:00:47,749
string type as we defined it.

27
00:00:47,749 --> 00:00:49,270
What we've written is correct

28
00:00:49,270 --> 00:00:51,408
so far but not complete.

29
00:00:51,408 --> 00:00:54,929
So here's the new situation I want to set up.

30
00:00:54,929 --> 00:00:59,390
We have this function H. H creates a string,

31
00:00:59,390 --> 00:01:01,350
initializes it with hello.

32
00:01:01,350 --> 00:01:03,249
It calls the function F,

33
00:01:03,249 --> 00:01:04,989
passing it the string S,

34
00:01:04,989 --> 00:01:06,829
F receives the string

35
00:01:06,829 --> 00:01:08,769
and then does its thing.

36
00:01:08,769 --> 00:01:13,489
So let's see what is happening.

37
00:01:13,489 --> 00:01:17,028
So you've got this constructor code

38
00:01:17,028 --> 00:01:18,189
here and the destructor there.

39
00:01:18,189 --> 00:01:20,388
So remember, the destructor is basically

40
00:01:20,388 --> 00:01:21,590
setting up constructor is

41
00:01:21,590 --> 00:01:22,689
setting up the string,

42
00:01:22,689 --> 00:01:24,448
dynamically allocating the array

43
00:01:24,448 --> 00:01:25,969
of characters, putting the text in there.

44
00:01:25,969 --> 00:01:28,028
The destructor is deleting the storage.

45
00:01:28,028 --> 00:01:30,668
And so let's see what happens here.

46
00:01:30,668 --> 00:01:33,569
So let me go to the board on this again.

47
00:01:33,569 --> 00:01:36,730
All right. So if we enter the function H,

48
00:01:36,730 --> 00:01:37,930
H creates a string

49
00:01:37,930 --> 00:01:40,030
S. We know what that's going to do.

50
00:01:40,030 --> 00:01:41,590
The string length is five.

51
00:01:41,590 --> 00:01:42,849
We'll get a pointer to

52
00:01:42,849 --> 00:01:44,388
the dynamic storage before

53
00:01:44,388 --> 00:01:48,010
the hilo. Right there.

54
00:01:48,010 --> 00:01:50,189
Now we're going to call the function F

55
00:01:50,189 --> 00:01:52,709
passing at S. Now,

56
00:01:52,709 --> 00:01:55,090
look at the declaration of F.

57
00:01:55,090 --> 00:01:59,340
F's argument T is a type string.

58
00:01:59,340 --> 00:02:01,528
Not pointed to string,

59
00:02:01,528 --> 00:02:04,509
not reference to string, but string.

60
00:02:04,509 --> 00:02:07,590
So what are we doing here?

61
00:02:07,590 --> 00:02:09,229
We're not passing by reference.

62
00:02:09,229 --> 00:02:11,030
We're passing by value.

63
00:02:11,030 --> 00:02:13,210
Passing by value means copying.

64
00:02:13,210 --> 00:02:15,729
It means that T will be a copy of

65
00:02:15,729 --> 00:02:17,649
S. If you pass

66
00:02:17,649 --> 00:02:19,169
something to a function by value,

67
00:02:19,169 --> 00:02:20,990
the original object is copied

68
00:02:20,990 --> 00:02:22,710
into the parameter for the function,

69
00:02:22,710 --> 00:02:23,789
and then the function

70
00:02:23,789 --> 00:02:24,669
can do whatever it wants with

71
00:02:24,669 --> 00:02:27,090
that parameter has no effect on the original.

72
00:02:27,090 --> 00:02:30,473
That's what passing by value should be.

73
00:02:30,473 --> 00:02:32,680
Alright, so that means

74
00:02:32,680 --> 00:02:35,399
that here we are in the environment of H.

75
00:02:35,399 --> 00:02:36,079
We have this thing

76
00:02:36,079 --> 00:02:37,580
S. We're going to be entering

77
00:02:37,580 --> 00:02:41,459
the environment of T. I'm sorry, of F,

78
00:02:41,459 --> 00:02:44,659
and F has its own local variable

79
00:02:44,659 --> 00:02:46,379
T. It's a brand new object,

80
00:02:46,379 --> 00:02:49,258
and it's going to be constructed as a copy of

81
00:02:49,258 --> 00:02:54,848
S. So how's that going to work?

82
00:02:54,848 --> 00:03:00,150
Well, we didn't say how strings get copied.

83
00:03:00,150 --> 00:03:02,028
So the compiler says,

84
00:03:02,028 --> 00:03:05,270
If you don't tell me how to copy a type,

85
00:03:05,270 --> 00:03:09,810
I will just simply copy each member.

86
00:03:09,810 --> 00:03:12,709
So the compiler says,

87
00:03:12,709 --> 00:03:14,769
You didn't tell me how to copy strings.

88
00:03:14,769 --> 00:03:17,109
So to initialize T as a copy of S,

89
00:03:17,109 --> 00:03:18,808
I will just copy

90
00:03:18,808 --> 00:03:24,650
this pointer and copy this integer.

91
00:03:25,210 --> 00:03:27,710
Okay, so the pointer and the integer

92
00:03:27,710 --> 00:03:30,149
get copied, and T looks like that.

93
00:03:30,149 --> 00:03:31,429
So now,

94
00:03:31,429 --> 00:03:33,844
from the point of view of the function,

95
00:03:33,844 --> 00:03:36,419
Ts, it's got the text, hello.

96
00:03:36,419 --> 00:03:38,060
It's a five character string.

97
00:03:38,060 --> 00:03:41,000
Looks good. If the function

98
00:03:41,000 --> 00:03:42,778
does things like, Hey,

99
00:03:42,778 --> 00:03:43,558
I want to take a look

100
00:03:43,558 --> 00:03:45,239
at the third character in the string,

101
00:03:45,239 --> 00:03:45,618
maybe you have

102
00:03:45,618 --> 00:03:46,618
some member function to let you

103
00:03:46,618 --> 00:03:48,199
look at particular characters in the string.

104
00:03:48,199 --> 00:03:49,620
I'll find the right character.

105
00:03:49,620 --> 00:03:52,278
Okay looks great. But look

106
00:03:52,278 --> 00:03:55,120
at the weird things that could happen.

107
00:03:55,120 --> 00:03:57,439
If the function does something

108
00:03:57,439 --> 00:03:59,780
to modify the string,

109
00:03:59,780 --> 00:04:02,479
for example, let's say there's

110
00:04:02,479 --> 00:04:04,019
a member function of string that

111
00:04:04,019 --> 00:04:05,038
lets you modify some

112
00:04:05,038 --> 00:04:06,378
of the characters in the string.

113
00:04:06,378 --> 00:04:08,159
Maybe the function F decides

114
00:04:08,159 --> 00:04:09,938
to change the character,

115
00:04:09,938 --> 00:04:12,985
the beginning of the string from an H to a J.

116
00:04:12,985 --> 00:04:16,970
So hello becomes jello, right?

117
00:04:16,970 --> 00:04:18,749
It's taking T, it's saying,

118
00:04:18,749 --> 00:04:20,848
I'm going to modify the character

119
00:04:20,848 --> 00:04:22,730
beginning to a J, so it does.

120
00:04:22,730 --> 00:04:25,449
Well, that's a little weird, right?

121
00:04:25,449 --> 00:04:27,009
Cause that means the string

122
00:04:27,009 --> 00:04:29,509
S, the original object,

123
00:04:29,509 --> 00:04:32,569
now the text is different than it was before,

124
00:04:32,569 --> 00:04:35,029
but I thought passing by value means,

125
00:04:35,029 --> 00:04:36,490
the original object is

126
00:04:36,490 --> 00:04:37,468
not going to get modified,

127
00:04:37,468 --> 00:04:39,428
and yet it has been.

128
00:04:39,428 --> 00:04:41,110
So that's a little weird,

129
00:04:41,110 --> 00:04:42,730
but that's not the real problem.

130
00:04:42,730 --> 00:04:44,588
The real problem comes

131
00:04:44,588 --> 00:04:47,310
when we leave the function F,

132
00:04:47,310 --> 00:04:50,069
when we return from the function F,

133
00:04:50,069 --> 00:04:53,228
any local variables of F go away.

134
00:04:53,228 --> 00:04:57,509
T, the parameter T is a local variable of F.

135
00:04:57,509 --> 00:05:00,774
So this string is going to go away.

136
00:05:00,774 --> 00:05:02,899
Now, when a string goes away,

137
00:05:02,899 --> 00:05:04,680
the destructor is called.

138
00:05:04,680 --> 00:05:08,339
So the destructor is called on T.

139
00:05:08,339 --> 00:05:10,778
The destructor is told

140
00:05:10,778 --> 00:05:13,779
to delete the array this points to.

141
00:05:13,980 --> 00:05:18,699
So it goes away. And now

142
00:05:18,699 --> 00:05:21,060
that the destructors done his job,

143
00:05:21,060 --> 00:05:23,120
these are both built in types,

144
00:05:23,120 --> 00:05:25,740
nothing else happens, so T's gone.

145
00:05:26,240 --> 00:05:30,079
And so we return to the function,

146
00:05:30,079 --> 00:05:33,499
and S has been radically changed.

147
00:05:33,499 --> 00:05:35,740
Here, we thought that passing by

148
00:05:35,740 --> 00:05:36,319
value means

149
00:05:36,319 --> 00:05:37,980
our original object won't get modified.

150
00:05:37,980 --> 00:05:41,738
In fact, S is now in a horrible state.

151
00:05:41,738 --> 00:05:45,298
The array's gone. S has a dangling pointer.

152
00:05:45,298 --> 00:05:46,660
It's got a pointer to storage that

153
00:05:46,660 --> 00:05:48,560
no longer belongs to your program.

154
00:05:48,560 --> 00:05:51,899
So any attempt to follow

155
00:05:51,899 --> 00:05:54,298
that pointer in the rest

156
00:05:54,298 --> 00:05:57,199
of this code is undefined behavior.

157
00:05:57,199 --> 00:05:59,478
Now, maybe the rest of the code

158
00:05:59,478 --> 00:06:01,360
doesn't ever try to follow that plan.

159
00:06:01,360 --> 00:06:02,860
Maybe the only thing we do with

160
00:06:02,860 --> 00:06:05,980
F with S after this point is maybe say,

161
00:06:05,980 --> 00:06:08,279
Hey, S, how long is the string?

162
00:06:08,279 --> 00:06:10,279
And maybe our member function

163
00:06:10,279 --> 00:06:11,899
of string that tells you how long

164
00:06:11,899 --> 00:06:13,639
the string is simply looks at

165
00:06:13,639 --> 00:06:14,459
this number and gives it

166
00:06:14,459 --> 00:06:15,639
back to you and says,

167
00:06:15,639 --> 00:06:18,259
Oh, it's five characters. Okay, thank you.

168
00:06:18,259 --> 00:06:19,879
But we're going to run

169
00:06:19,879 --> 00:06:21,504
into trouble at some point.

170
00:06:21,504 --> 00:06:23,750
When we leave the function,

171
00:06:23,750 --> 00:06:25,990
when we leave the function H,

172
00:06:25,990 --> 00:06:27,089
the string is going to

173
00:06:27,089 --> 00:06:28,449
go S is going to go away,

174
00:06:28,449 --> 00:06:30,528
so the destructor is called,

175
00:06:30,528 --> 00:06:35,290
and the destructors going to

176
00:06:35,290 --> 00:06:37,709
call delete on a pointer

177
00:06:37,709 --> 00:06:40,108
to storage that's already been deleted.

178
00:06:40,108 --> 00:06:42,329
That's always undefined behavior.

179
00:06:42,329 --> 00:06:44,310
If you call delete with a pointer to

180
00:06:44,310 --> 00:06:45,509
storage that no longer

181
00:06:45,509 --> 00:06:46,408
belongs to your program,

182
00:06:46,408 --> 00:06:48,488
it's been given back to the operating system,

183
00:06:48,488 --> 00:06:50,348
that's undefined behavior,

184
00:06:50,348 --> 00:06:53,468
and on most systems will cause a crash.

185
00:06:54,069 --> 00:06:58,209
So we're totally messed up here.

186
00:06:58,209 --> 00:07:00,129
So again, the problem was

187
00:07:00,129 --> 00:07:07,689
that letting the compiler say how strings

188
00:07:07,689 --> 00:07:11,069
get copied is going to turn into simply copy

189
00:07:11,069 --> 00:07:17,610
the members and the essence

190
00:07:17,610 --> 00:07:19,589
of the problem is T

191
00:07:19,589 --> 00:07:23,108
and S are sharing the same array,

192
00:07:23,108 --> 00:07:25,709
and that's where the problem lies.

193
00:07:25,709 --> 00:07:28,569
Any changes through T to

194
00:07:28,569 --> 00:07:32,490
the array is going to be reflected in S. But,

195
00:07:32,490 --> 00:07:33,728
the real problem is going to

196
00:07:33,728 --> 00:07:34,848
be when T goes away,

197
00:07:34,848 --> 00:07:36,269
the array that's shared

198
00:07:36,269 --> 00:07:37,889
by both of them goes away.

199
00:07:37,889 --> 00:07:40,269
And so now S has a dangling pointer,

200
00:07:40,269 --> 00:07:41,709
and even if we don't come

201
00:07:41,709 --> 00:07:43,548
into run into trouble earlier,

202
00:07:43,548 --> 00:07:45,668
by the time the instructors called,

203
00:07:45,668 --> 00:07:48,329
we're going to be in bad shape.

204
00:07:48,329 --> 00:07:51,029
So that's the source of

205
00:07:51,029 --> 00:07:52,370
the problem that T is

206
00:07:52,370 --> 00:07:54,610
sharing the same array from S.

207
00:07:54,610 --> 00:07:58,389
Now, when I think of copying, uh you know,

208
00:07:58,389 --> 00:08:00,470
if I pass a copy of

209
00:08:00,470 --> 00:08:03,569
an integer parameter of

210
00:08:03,569 --> 00:08:05,089
a function, that'll be an integer.

211
00:08:05,089 --> 00:08:07,870
Then this gets copied here.

212
00:08:07,870 --> 00:08:11,430
This is entirely independent

213
00:08:11,430 --> 00:08:13,129
of this guy. There's nothing shared here.

214
00:08:13,129 --> 00:08:14,649
The copy of this integer is

215
00:08:14,649 --> 00:08:16,670
totally distinct from this integer here.

216
00:08:16,670 --> 00:08:18,730
That's what I want copying to do.

217
00:08:18,730 --> 00:08:21,189
I want the newly created object as

218
00:08:21,189 --> 00:08:22,569
a copy of the original to

219
00:08:22,569 --> 00:08:24,629
be totally independent of the original.

220
00:08:24,629 --> 00:08:26,889
So that means T should

221
00:08:26,889 --> 00:08:29,608
probably have its own array of characters,

222
00:08:29,608 --> 00:08:31,149
not share it with S, get

223
00:08:31,149 --> 00:08:33,289
its own array of character.

224
00:08:33,480 --> 00:08:35,759
So to make that happen,

225
00:08:35,759 --> 00:08:37,558
we have to tell the compiler,

226
00:08:37,558 --> 00:08:39,339
I don't want you to

227
00:08:39,339 --> 00:08:40,779
say how to copy something.

228
00:08:40,779 --> 00:08:42,559
I'm going to tell you how to copy.

229
00:08:42,559 --> 00:08:46,100
So to do that, we have to declare

230
00:08:46,100 --> 00:08:48,298
an appropriate way of

231
00:08:48,298 --> 00:08:50,080
creating a string from another string.

232
00:08:50,080 --> 00:08:50,558
Well,

233
00:08:50,558 --> 00:08:52,440
creating a string, that's a constructor.

234
00:08:52,440 --> 00:08:55,278
So let me provide a constructor for

235
00:08:55,278 --> 00:08:56,960
string that takes as

236
00:08:56,960 --> 00:08:58,919
its argument, another string.

237
00:08:58,919 --> 00:09:00,700
I'll pass it by constant reference.

238
00:09:00,700 --> 00:09:02,799
So I'm

239
00:09:02,799 --> 00:09:04,419
creating another constructor for string.

240
00:09:04,419 --> 00:09:05,379
It says, how to create

241
00:09:05,379 --> 00:09:07,695
a string from another string.

242
00:09:07,695 --> 00:09:10,009
And I'm passing it by constant reference for

243
00:09:10,009 --> 00:09:12,928
reasons that I'll get to later. So let's see.

244
00:09:12,928 --> 00:09:15,149
How do I create a string?

245
00:09:15,149 --> 00:09:16,869
How do I create a string from

246
00:09:16,869 --> 00:09:18,869
another string? Well, let's see.

247
00:09:18,869 --> 00:09:20,869
So I've got to make sure that

248
00:09:20,869 --> 00:09:24,389
I am properly initialized.

249
00:09:24,389 --> 00:09:26,509
So that means my LN

250
00:09:26,509 --> 00:09:29,029
and my text have to be properly set.

251
00:09:29,029 --> 00:09:31,789
So my MLN well,

252
00:09:31,789 --> 00:09:33,288
that'll just be the other guy's MLN.

253
00:09:33,288 --> 00:09:35,028
Okay, so if the other guys a

254
00:09:35,028 --> 00:09:37,070
five character string with the text hello,

255
00:09:37,070 --> 00:09:39,769
then I'll set my length to five.

256
00:09:39,769 --> 00:09:43,769
Now, my text should

257
00:09:43,769 --> 00:09:46,339
not just be a pointer

258
00:09:46,339 --> 00:09:47,440
to the other guy's storage.

259
00:09:47,440 --> 00:09:50,100
I need my own array of characters.

260
00:09:50,100 --> 00:09:51,779
So I will allocate

261
00:09:51,779 --> 00:09:52,818
my own array of

262
00:09:52,818 --> 00:09:54,120
characters of the right length.

263
00:09:54,120 --> 00:09:56,940
So now I have a dynamically allocated array

264
00:09:56,940 --> 00:09:58,499
of the right number of characters,

265
00:09:58,499 --> 00:09:59,979
but they're uninitialized.

266
00:09:59,979 --> 00:10:01,759
So let's copy

267
00:10:01,759 --> 00:10:04,289
the other guy's text into my text.

268
00:10:04,289 --> 00:10:06,298
Let's copy the C string from

269
00:10:06,298 --> 00:10:09,078
the other guy into me. And there we have it.

270
00:10:09,078 --> 00:10:10,539
There is a correct

271
00:10:10,539 --> 00:10:12,538
implementation of the constructor for

272
00:10:12,538 --> 00:10:14,840
a string that takes

273
00:10:14,840 --> 00:10:17,700
a string another string as its argument.

274
00:10:18,139 --> 00:10:20,799
And I know there's

275
00:10:20,799 --> 00:10:22,119
going to be people raising objections.

276
00:10:22,119 --> 00:10:23,159
I haven't seen if they already

277
00:10:23,159 --> 00:10:24,899
have raising some objections.

278
00:10:24,899 --> 00:10:27,340
Will this even compile? Yes, it will compile.

279
00:10:27,340 --> 00:10:29,899
I'll explain why. But let's

280
00:10:29,899 --> 00:10:31,099
see what it does to

281
00:10:31,099 --> 00:10:32,999
see how it solves the problem.

282
00:10:32,999 --> 00:10:34,938
So remember that code,

283
00:10:34,938 --> 00:10:37,259
and let me go back to the picture.

284
00:10:37,259 --> 00:10:38,659
So now we're saying,

285
00:10:38,659 --> 00:10:40,279
Okay, let's do the following.

286
00:10:40,279 --> 00:10:41,894
As is going to be copied into.

287
00:10:41,894 --> 00:10:43,730
So the compiler says,

288
00:10:43,730 --> 00:10:46,169
Oh, okay, we got to copy a string.

289
00:10:46,169 --> 00:10:48,168
Did you tell me how to do that?

290
00:10:48,168 --> 00:10:49,690
Did you tell me how to create

291
00:10:49,690 --> 00:10:51,730
a string from another string?

292
00:10:51,730 --> 00:10:54,090
And we did. We have a constructor

293
00:10:54,090 --> 00:10:55,190
that says how to construct

294
00:10:55,190 --> 00:10:56,610
a string from another string.

295
00:10:56,610 --> 00:10:57,970
Qu says, Oh, okay.

296
00:10:57,970 --> 00:10:59,349
Then instead of following what I would do,

297
00:10:59,349 --> 00:11:00,710
which is copy the data members,

298
00:11:00,710 --> 00:11:01,908
I'll do what you tell me.

299
00:11:01,908 --> 00:11:03,769
So what I told you to do was to

300
00:11:03,769 --> 00:11:06,668
take now now in the copy constructor,

301
00:11:06,668 --> 00:11:08,328
that's what that constructors called.

302
00:11:08,328 --> 00:11:09,490
In the constructor, it says,

303
00:11:09,490 --> 00:11:11,168
how to copy one string, how

304
00:11:11,168 --> 00:11:13,090
to create a string from another string,

305
00:11:13,090 --> 00:11:16,149
the object being constructed

306
00:11:16,149 --> 00:11:20,938
is the one that this pointer points to.

307
00:11:20,938 --> 00:11:22,740
Remember,

308
00:11:22,740 --> 00:11:25,919
every member function has a this pointer

309
00:11:25,919 --> 00:11:29,669
that points to the

310
00:11:29,669 --> 00:11:30,908
object the function is called on.

311
00:11:30,908 --> 00:11:32,469
So in this case, T is

312
00:11:32,469 --> 00:11:34,509
the one that's being constructed,

313
00:11:34,509 --> 00:11:36,889
so that this pointer is pointing to

314
00:11:36,889 --> 00:11:39,948
T. And the parameter,

315
00:11:39,948 --> 00:11:41,828
the thing we're copying from

316
00:11:41,828 --> 00:11:43,769
other let's go to be

317
00:11:43,769 --> 00:11:45,490
F. So other is a reference to a strain.

318
00:11:45,490 --> 00:11:47,448
So other will be another name for S.

319
00:11:47,448 --> 00:11:49,668
So copy in

320
00:11:49,668 --> 00:11:50,889
the constructor that I just written,

321
00:11:50,889 --> 00:11:52,610
that copy constructor,

322
00:11:52,610 --> 00:11:55,028
S plays the role of other.

323
00:11:55,028 --> 00:11:56,989
So what did we say to do? We said,

324
00:11:56,989 --> 00:11:58,928
set my own length to

325
00:11:58,928 --> 00:12:03,639
the other guy's length. Okay.

326
00:12:03,639 --> 00:12:06,918
Then I said, dynamically

327
00:12:06,918 --> 00:12:10,399
allocate an array of N plus one characters.

328
00:12:10,399 --> 00:12:12,519
So five plus one is six,

329
00:12:12,519 --> 00:12:14,038
dynamically allocate an array of

330
00:12:14,038 --> 00:12:16,240
six characters and store

331
00:12:16,240 --> 00:12:20,999
a position store the pointer into my text.

332
00:12:21,639 --> 00:12:25,938
Okay. Then the last thing I said was

333
00:12:25,938 --> 00:12:29,120
string copy into my text

334
00:12:29,120 --> 00:12:31,298
the other guy's text.

335
00:12:31,298 --> 00:12:33,639
And that'll copy the characters

336
00:12:33,639 --> 00:12:36,298
up to and including Zerobte.

337
00:12:36,298 --> 00:12:39,840
And so when that constructor finishes,

338
00:12:41,190 --> 00:12:44,548
when that constructor finishes,

339
00:12:44,669 --> 00:12:49,089
here's T. It looks like a copy of S,

340
00:12:49,089 --> 00:12:50,369
and in fact, it's totally

341
00:12:50,369 --> 00:12:51,850
independent of S now.

342
00:12:51,850 --> 00:12:54,028
So whatever we do to T has

343
00:12:54,028 --> 00:12:56,250
no effect on S. Perfect.

344
00:12:56,250 --> 00:12:58,369
That's exactly what copying should do.

345
00:12:58,369 --> 00:13:01,529
So now the function

346
00:13:01,529 --> 00:13:02,948
can do whatever it wants to T.

347
00:13:02,948 --> 00:13:04,389
If it wants to call some

348
00:13:04,389 --> 00:13:05,509
member function of string

349
00:13:05,509 --> 00:13:08,889
that'll let us change into a J, that's fine.

350
00:13:08,889 --> 00:13:12,688
Has no effect on S. Eventually,

351
00:13:12,688 --> 00:13:14,984
when we leave the function F,

352
00:13:14,984 --> 00:13:17,039
T will be destroyed.

353
00:13:17,039 --> 00:13:18,639
The destructor will be called on

354
00:13:18,639 --> 00:13:19,798
T. The destructor will

355
00:13:19,798 --> 00:13:21,600
get rid of that storage.

356
00:13:21,600 --> 00:13:24,139
So the body of the destructor for strength,

357
00:13:24,139 --> 00:13:25,859
gets rid of that storage, and

358
00:13:25,859 --> 00:13:28,259
then step two of destruction.

359
00:13:28,259 --> 00:13:29,379
Well, these are built in

360
00:13:29,379 --> 00:13:30,899
types, so nothing happens.

361
00:13:30,899 --> 00:13:33,460
And so then T can go away safely.

362
00:13:33,460 --> 00:13:35,119
And we're back here, and

363
00:13:35,119 --> 00:13:36,958
S is in perfectly good shape,

364
00:13:36,958 --> 00:13:39,979
unchanged, exactly what we want.

365
00:13:40,179 --> 00:13:43,979
So we have solved the problem of,

366
00:13:43,979 --> 00:13:46,839
you know, the undefined behavior that

367
00:13:46,839 --> 00:13:48,080
will happen if we don't

368
00:13:48,080 --> 00:13:50,340
properly copy the string.

369
00:13:50,340 --> 00:13:52,559
So let me go back and look at

370
00:13:52,559 --> 00:13:53,899
some terminology and address

371
00:13:53,899 --> 00:13:54,580
some of the issues

372
00:13:54,580 --> 00:13:56,818
that people

373
00:13:56,818 --> 00:14:00,580
are some people are no doubt thinking.

374
00:14:00,580 --> 00:14:02,460
So first of all, terminology,

375
00:14:02,460 --> 00:14:04,359
this constructor is

376
00:14:04,359 --> 00:14:07,320
called the copy constructor.

377
00:14:07,320 --> 00:14:10,519
So this is the copy constructor.

378
00:14:10,519 --> 00:14:12,639
The copy constructor is

379
00:14:12,639 --> 00:14:15,759
called whenever a string

380
00:14:15,759 --> 00:14:17,899
is being created from another string.

381
00:14:17,899 --> 00:14:23,879
So there's a a number

382
00:14:23,879 --> 00:14:26,059
of contexts where that happens.

383
00:14:26,419 --> 00:14:34,219
So if I create a string, X from S,

384
00:14:34,219 --> 00:14:35,759
there is creating

385
00:14:35,759 --> 00:14:37,159
a string from another string.

386
00:14:37,159 --> 00:14:39,580
That would call the copy constructor.

387
00:14:39,940 --> 00:14:41,879
Here's another way to create

388
00:14:41,879 --> 00:14:44,139
a string from another string.

389
00:14:44,139 --> 00:14:45,499
I'm creating a string X,

390
00:14:45,499 --> 00:14:46,419
and it's a copy

391
00:14:46,419 --> 00:14:48,200
of it's going to come from that string

392
00:14:48,200 --> 00:14:52,120
S. Also, passing by value.

393
00:14:52,120 --> 00:14:53,460
In this case, if we pass

394
00:14:53,460 --> 00:14:55,480
a string by value to a function,

395
00:14:55,480 --> 00:14:58,578
that will call the copying instructor.

396
00:14:59,149 --> 00:15:02,269
So that's built into the language.

397
00:15:02,269 --> 00:15:05,330
The language recognizes passing by value.

398
00:15:05,330 --> 00:15:06,668
If your parameter is

399
00:15:06,668 --> 00:15:08,490
a string, not a pointer to a string,

400
00:15:08,490 --> 00:15:09,808
not a reference to a string, if

401
00:15:09,808 --> 00:15:10,990
your parameter is a string

402
00:15:10,990 --> 00:15:12,450
and you're passing a string,

403
00:15:12,450 --> 00:15:14,048
call the copy constructor.

404
00:15:14,048 --> 00:15:16,529
Also, if you're returning

405
00:15:16,529 --> 00:15:17,629
a value from a function,

406
00:15:17,629 --> 00:15:19,629
a value, not a pointer or a reference.

407
00:15:19,629 --> 00:15:23,129
So in other words, I I I have

408
00:15:23,129 --> 00:15:25,379
some function blah if

409
00:15:25,379 --> 00:15:26,719
I have some function blah

410
00:15:26,719 --> 00:15:29,259
that declares a local variable

411
00:15:29,259 --> 00:15:31,019
for some string and builds

412
00:15:31,019 --> 00:15:32,639
up some answer in there and

413
00:15:32,639 --> 00:15:33,839
ultimately decides to

414
00:15:33,839 --> 00:15:35,440
return the value of that string.

415
00:15:35,440 --> 00:15:40,580
So notice blah is returning a string,

416
00:15:40,580 --> 00:15:41,899
not a pointer to a string,

417
00:15:41,899 --> 00:15:44,159
not a reference to a string, but a string.

418
00:15:44,159 --> 00:15:47,359
That means the expression here is value

419
00:15:47,359 --> 00:15:49,139
will be copied back

420
00:15:49,139 --> 00:15:50,779
to the caller of the function.

421
00:15:50,779 --> 00:15:53,399
So whoever calls the function blah gets

422
00:15:53,399 --> 00:15:54,658
a copy of the

423
00:15:54,658 --> 00:15:56,719
final value of this local variable.

424
00:15:56,719 --> 00:15:59,379
How is that copied from the function

425
00:15:59,379 --> 00:16:00,539
back to the caller

426
00:16:00,539 --> 00:16:02,399
through the copy constructor?

427
00:16:02,399 --> 00:16:04,538
So those are the circumstances

428
00:16:04,538 --> 00:16:06,899
where the copy constructor gets called.

429
00:16:06,899 --> 00:16:10,259
And whenever you have

430
00:16:10,259 --> 00:16:12,239
an object that has

431
00:16:12,239 --> 00:16:14,559
some resource that it holds,

432
00:16:14,559 --> 00:16:15,158
you got to think

433
00:16:15,158 --> 00:16:17,359
about the copying behavior there.

434
00:16:17,359 --> 00:16:19,019
You got to think, What do I want to

435
00:16:19,019 --> 00:16:21,220
do if one of these things gets copied?

436
00:16:21,220 --> 00:16:23,360
What do I do about the resource?

437
00:16:23,360 --> 00:16:25,379
Do I have both objects

438
00:16:25,379 --> 00:16:26,820
share the same resource?

439
00:16:26,820 --> 00:16:29,220
That usually leads to problems.

440
00:16:29,220 --> 00:16:31,418
So, you know,

441
00:16:31,418 --> 00:16:32,999
maybe somehow figuring out

442
00:16:32,999 --> 00:16:34,239
making a copy of the resource.

443
00:16:34,239 --> 00:16:35,419
Or if it doesn't make sense

444
00:16:35,419 --> 00:16:36,620
to make a copy of the resource,

445
00:16:36,620 --> 00:16:39,259
then maybe preventing copying entirely,

446
00:16:39,259 --> 00:16:41,078
which is something we're

447
00:16:41,078 --> 00:16:41,799
not going to do right now.

448
00:16:41,799 --> 00:16:43,720
We'll see how to do that later.

449
00:16:44,240 --> 00:16:46,078
Okay.

450
00:16:46,078 --> 00:16:48,418
Another question

451
00:16:48,418 --> 00:16:50,220
that often comes up at this point.

452
00:16:50,220 --> 00:16:51,279
I haven't been looking

453
00:16:51,279 --> 00:16:52,059
at the questions right now,

454
00:16:52,059 --> 00:16:54,538
but I'm sure it's been asked already is,

455
00:16:54,538 --> 00:16:57,899
you know, why am I passing this by reference?

456
00:16:57,899 --> 00:17:01,139
Could I also pass it by value?

457
00:17:01,139 --> 00:17:03,440
Well, let's see the variations.

458
00:17:03,879 --> 00:17:10,130
We could, if we want, declare

459
00:17:10,130 --> 00:17:14,049
the copy constructor this way.

460
00:17:14,049 --> 00:17:16,509
It's pretty rare, but you can do this

461
00:17:16,509 --> 00:17:17,769
where I'm creating

462
00:17:17,769 --> 00:17:19,630
a string from another string,

463
00:17:19,630 --> 00:17:21,929
but the copy constructor itself is

464
00:17:21,929 --> 00:17:23,509
allowed to modify the string

465
00:17:23,509 --> 00:17:25,348
that's being copied from.

466
00:17:25,348 --> 00:17:26,970
Well, it's kind of weird

467
00:17:26,970 --> 00:17:28,169
because usually when you think

468
00:17:28,169 --> 00:17:29,409
about making copies of

469
00:17:29,409 --> 00:17:31,009
something, you say, Well,

470
00:17:31,009 --> 00:17:32,588
the process of making a copy of

471
00:17:32,588 --> 00:17:34,828
something should not modify the original,

472
00:17:34,828 --> 00:17:36,309
and that's why it's usually

473
00:17:36,309 --> 00:17:37,808
passed by constant reference.

474
00:17:37,808 --> 00:17:40,348
But here's a circumstance where it might be.

475
00:17:40,348 --> 00:17:42,689
Suppose that string for

476
00:17:42,689 --> 00:17:44,989
some performance monitoring reasons or

477
00:17:44,989 --> 00:17:46,949
something is keeping track

478
00:17:46,949 --> 00:17:50,950
of the number of copies made from the string.

479
00:17:50,950 --> 00:17:52,888
So maybe we have some kind of

480
00:17:52,888 --> 00:17:56,289
variable member function data member

481
00:17:56,289 --> 00:17:57,288
that's going to be the number of

482
00:17:57,288 --> 00:17:58,788
copies that have been made from me.

483
00:17:58,788 --> 00:18:00,288
So when I'm first created,

484
00:18:00,288 --> 00:18:02,368
we'll initialize that to zero, let's say.

485
00:18:02,368 --> 00:18:07,288
And then anytime the string is copied.

486
00:18:07,288 --> 00:18:09,469
The copy constructor, in addition to

487
00:18:09,469 --> 00:18:11,950
copying what it's doing

488
00:18:11,950 --> 00:18:13,108
with the mtext, et cetera,

489
00:18:13,108 --> 00:18:16,669
is also adding one to the number of copies

490
00:18:16,669 --> 00:18:20,788
made from the object being copied from.

491
00:18:20,788 --> 00:18:22,489
So it is modifying

492
00:18:22,489 --> 00:18:24,349
the original object by saying,

493
00:18:24,349 --> 00:18:25,808
Hey, one more copy of you has

494
00:18:25,808 --> 00:18:28,348
been made. Record that for yourself.

495
00:18:28,380 --> 00:18:32,819
That's okay. It's uncommon, but it's okay.

496
00:18:32,819 --> 00:18:34,279
Usually, it's one of these things

497
00:18:34,279 --> 00:18:36,239
where notice that doesn't really

498
00:18:36,239 --> 00:18:38,098
conceptually modify

499
00:18:38,098 --> 00:18:40,219
the strings value in any significant way.

500
00:18:40,219 --> 00:18:41,519
The original guy still has

501
00:18:41,519 --> 00:18:43,380
the same text and the same length.

502
00:18:43,380 --> 00:18:45,298
It's just another little bit

503
00:18:45,298 --> 00:18:47,338
of information about it that,

504
00:18:47,338 --> 00:18:50,659
you know, we might want to keep track of.

505
00:18:51,460 --> 00:18:54,000
So this is okay,

506
00:18:54,000 --> 00:18:56,400
rather uncommon, but okay.

507
00:18:56,400 --> 00:18:59,380
What definitely is not legal,

508
00:18:59,380 --> 00:19:02,999
and I'll show you why is what

509
00:19:02,999 --> 00:19:04,640
if we have the copy constructor

510
00:19:04,640 --> 00:19:07,434
take its argument pass by value?

511
00:19:07,434 --> 00:19:09,949
That is, we decide,

512
00:19:09,949 --> 00:19:11,210
here's how you create a string

513
00:19:11,210 --> 00:19:12,529
from another string,

514
00:19:12,529 --> 00:19:14,989
and my copy instructor here or

515
00:19:14,989 --> 00:19:16,309
my supposed copy constructor

516
00:19:16,309 --> 00:19:16,989
here is going to take

517
00:19:16,989 --> 00:19:17,888
us argument passed by

518
00:19:17,888 --> 00:19:19,989
value, something like that.

519
00:19:19,989 --> 00:19:23,048
Well, this is illegal

520
00:19:23,048 --> 00:19:25,809
because it doesn't make sense.

521
00:19:25,809 --> 00:19:29,869
And let me show you why. So suppose

522
00:19:29,869 --> 00:19:31,410
that were my copy constructor.

523
00:19:31,410 --> 00:19:34,628
Then here's what happens. We got S created.

524
00:19:34,628 --> 00:19:35,548
We're calling the function

525
00:19:35,548 --> 00:19:37,788
F. S is being passed

526
00:19:37,788 --> 00:19:39,269
by value to create

527
00:19:39,269 --> 00:19:41,388
T. So this brand new object T

528
00:19:41,388 --> 00:19:44,689
is going to be created as a copy of S.

529
00:19:44,689 --> 00:19:47,358
So to

530
00:19:47,358 --> 00:19:48,719
create this brand new object

531
00:19:48,719 --> 00:19:49,979
T as a copy of S,

532
00:19:49,979 --> 00:19:51,940
we got to call the copy constructor.

533
00:19:51,940 --> 00:19:54,798
Now, in the copy constructor,

534
00:19:54,798 --> 00:19:58,519
the object being created is T,

535
00:19:58,519 --> 00:20:01,558
so that this pointer points to T.

536
00:20:02,359 --> 00:20:06,318
And the parameter

537
00:20:06,319 --> 00:20:09,778
that is going to come from S,

538
00:20:09,778 --> 00:20:14,459
the parameter is other passed by value.

539
00:20:14,459 --> 00:20:16,720
So it's a brand new string.

540
00:20:16,720 --> 00:20:17,479
So there's going to be

541
00:20:17,479 --> 00:20:19,959
this brand new string called O

542
00:20:22,059 --> 00:20:23,618
That's going to be

543
00:20:23,618 --> 00:20:26,419
initialized as a copy of S.

544
00:20:26,740 --> 00:20:28,878
Well, how is other going

545
00:20:28,878 --> 00:20:30,259
to be initialized as a copy of

546
00:20:30,259 --> 00:20:33,359
S by calling the copy constructor?

547
00:20:33,359 --> 00:20:35,499
So in order to get S

548
00:20:35,499 --> 00:20:38,939
passed to other so that then we can create T,

549
00:20:38,939 --> 00:20:41,279
we've got to call the copy constructor,

550
00:20:41,279 --> 00:20:42,979
which will say, Okay,

551
00:20:42,979 --> 00:20:46,959
this pointer will point to other,

552
00:20:46,959 --> 00:20:49,499
and S is going to be

553
00:20:49,499 --> 00:20:50,759
passed to the parameter to

554
00:20:50,759 --> 00:20:52,160
that call to the copy constructor,

555
00:20:52,160 --> 00:20:54,579
which is passed by value,

556
00:20:54,579 --> 00:20:58,588
which is a second instance of other,

557
00:20:58,588 --> 00:21:00,308
which has to be initialized from

558
00:21:00,308 --> 00:21:02,409
S. Once we have done that,

559
00:21:02,409 --> 00:21:04,128
then we can go to

560
00:21:04,128 --> 00:21:05,410
the copy constructor in order

561
00:21:05,410 --> 00:21:06,650
to copy that into here,

562
00:21:06,650 --> 00:21:07,989
and once that's done, we can go

563
00:21:07,989 --> 00:21:09,150
to the copying instructor and finish

564
00:21:09,150 --> 00:21:10,750
the copying instructive body to copy it into

565
00:21:10,750 --> 00:21:12,949
T. So you see where this is going.

566
00:21:12,949 --> 00:21:15,190
The copy constructor defines

567
00:21:15,190 --> 00:21:17,619
what it means to pass by value.

568
00:21:17,619 --> 00:21:19,430
How do you pass by value?

569
00:21:19,430 --> 00:21:20,449
You make a copy by

570
00:21:20,449 --> 00:21:21,829
calling the copy constructor.

571
00:21:21,829 --> 00:21:23,409
So if the copy constructor

572
00:21:23,409 --> 00:21:26,189
itself took its argument pass by value,

573
00:21:26,189 --> 00:21:28,710
you've got this infinite circular definition.

574
00:21:28,710 --> 00:21:30,628
Well, how do we get the argument to it by

575
00:21:30,628 --> 00:21:32,609
calling the copy constructor? Oh, okay.

576
00:21:32,609 --> 00:21:34,048
Well, how do we get the argument to

577
00:21:34,048 --> 00:21:35,529
that copy constructors argument

578
00:21:35,529 --> 00:21:37,230
by calling the copy constructor?

579
00:21:37,230 --> 00:21:40,749
It makes no sense. So for

580
00:21:40,749 --> 00:21:43,729
that reason, no, no, no, no, no.

581
00:21:43,890 --> 00:21:48,009
The other parameter is passed by reference.

582
00:21:48,009 --> 00:21:49,670
It's not going to be a brand new string

583
00:21:49,670 --> 00:21:51,548
as a copy of the original.

584
00:21:51,548 --> 00:21:54,638
It's another name for the original.

585
00:21:54,638 --> 00:21:57,568
So is another name for S,

586
00:21:57,568 --> 00:21:59,608
and that's why we don't go crazy here.

587
00:21:59,608 --> 00:22:01,068
So let me put this back here.

588
00:22:01,068 --> 00:22:03,209
We'll pass it by reference,

589
00:22:03,209 --> 00:22:04,890
and in fact, of course,

590
00:22:04,890 --> 00:22:06,328
it'll be constant reference

591
00:22:06,328 --> 00:22:08,888
because we don't modify the original object.

592
00:22:08,888 --> 00:22:10,469
So let's make that promise.

593
00:22:10,469 --> 00:22:12,128
So now we're good. Back to

594
00:22:12,128 --> 00:22:13,589
being a legal copy instructor.

595
00:22:13,589 --> 00:22:16,288
Okay. Now, the other question

596
00:22:16,288 --> 00:22:18,028
that people ask is,

597
00:22:18,028 --> 00:22:20,828
well, wait a minute.

598
00:22:20,828 --> 00:22:27,409
I'm talking about Men of O and

599
00:22:27,409 --> 00:22:34,169
text of other Not Mamnin Mam text,

600
00:22:34,169 --> 00:22:37,769
but the private members of the other string.

601
00:22:37,769 --> 00:22:40,329
Is that allowed?

602
00:22:40,329 --> 00:22:41,848
The answer is yes.

603
00:22:41,848 --> 00:22:43,569
You might say, Well, wait a minute.

604
00:22:43,569 --> 00:22:46,028
I thought that if

605
00:22:46,028 --> 00:22:48,128
a member is declared private,

606
00:22:48,128 --> 00:22:51,628
then the only place you can talk about them

607
00:22:51,628 --> 00:22:55,588
are in the member functions

608
00:22:55,588 --> 00:22:58,648
of the class they belong to.

609
00:22:58,648 --> 00:22:59,888
I'll say, Yes,

610
00:22:59,888 --> 00:23:01,588
that's exactly what's happening here.

611
00:23:01,588 --> 00:23:02,729
You say, but I

612
00:23:02,729 --> 00:23:04,249
thought you could only talk about

613
00:23:04,249 --> 00:23:05,469
the private members of

614
00:23:05,469 --> 00:23:08,328
the object that this pointer points to.

615
00:23:08,328 --> 00:23:12,910
No, I never said that. I've never in 31,

616
00:23:12,910 --> 00:23:14,469
never prior in 32.

617
00:23:14,469 --> 00:23:16,528
That is, you know, talking about

618
00:23:16,528 --> 00:23:18,689
MLN by itself is just shorthand for

619
00:23:18,689 --> 00:23:23,829
saying this arrow LN and this arrow text.

620
00:23:23,829 --> 00:23:25,328
So you know that

621
00:23:25,328 --> 00:23:26,288
for the object you

622
00:23:26,288 --> 00:23:27,409
called the member function on,

623
00:23:27,409 --> 00:23:28,689
of course, you could talk about the

624
00:23:28,689 --> 00:23:30,969
private members for that object.

625
00:23:30,969 --> 00:23:32,828
But you can actually also

626
00:23:32,828 --> 00:23:34,648
talk about the private members

627
00:23:34,648 --> 00:23:38,709
of this one means Emlen.

628
00:23:38,709 --> 00:23:40,328
You can also talk about

629
00:23:40,328 --> 00:23:42,888
the private members of any string.

630
00:23:42,888 --> 00:23:44,609
So it's not just the string

631
00:23:44,609 --> 00:23:46,128
that this pointer points to,

632
00:23:46,128 --> 00:23:47,568
but a member function

633
00:23:47,568 --> 00:23:48,709
of string can talk about

634
00:23:48,709 --> 00:23:51,130
the private members of any string.

635
00:23:51,130 --> 00:23:52,528
Why is that?

636
00:23:52,528 --> 00:23:55,589
Well, that wasn't Strostrp's original idea.

637
00:23:55,589 --> 00:23:57,749
He thought the idea should be

638
00:23:57,749 --> 00:23:59,230
that if I call

639
00:23:59,230 --> 00:24:00,949
a member function on this object,

640
00:24:00,949 --> 00:24:03,229
the member function can deal with

641
00:24:03,229 --> 00:24:06,128
the private members only of this object,

642
00:24:06,128 --> 00:24:07,949
not of other objects, not

643
00:24:07,949 --> 00:24:09,529
even other objects of the same type.

644
00:24:09,529 --> 00:24:11,148
That's what he originally planned to do.

645
00:24:11,148 --> 00:24:12,848
And then he realized

646
00:24:12,848 --> 00:24:15,209
the need for writing copy constructors,

647
00:24:15,209 --> 00:24:17,628
and then he realized that,

648
00:24:17,628 --> 00:24:19,548
oh, that can make

649
00:24:19,548 --> 00:24:21,849
copy constructors very hard to write.

650
00:24:21,849 --> 00:24:23,429
If I can't get at

651
00:24:23,429 --> 00:24:24,990
the internals of the other guy,

652
00:24:24,990 --> 00:24:27,069
then it might be hard

653
00:24:27,069 --> 00:24:28,269
or even impossible for me

654
00:24:28,269 --> 00:24:29,720
to write a copy constructor.

655
00:24:29,720 --> 00:24:32,068
Now, depending on how

656
00:24:32,068 --> 00:24:34,410
the string type is declared,

657
00:24:34,410 --> 00:24:36,490
it may or may not be possible

658
00:24:36,490 --> 00:24:37,909
to make a copy

659
00:24:37,909 --> 00:24:39,869
from it using the public interface.

660
00:24:39,869 --> 00:24:41,969
For example, if string has

661
00:24:41,969 --> 00:24:43,209
a public function to

662
00:24:43,209 --> 00:24:45,049
give you the length of the string,

663
00:24:45,049 --> 00:24:46,808
you wouldn't need to talk about the

664
00:24:46,808 --> 00:24:48,509
M Ln member or the other guy.

665
00:24:48,509 --> 00:24:50,210
This could be a little harder.

666
00:24:50,210 --> 00:24:51,909
How do you do a string copy from

667
00:24:51,909 --> 00:24:53,689
the other If string does not have

668
00:24:53,689 --> 00:24:56,230
a member function to give you back a pointer

669
00:24:56,230 --> 00:24:57,628
to its own internal

670
00:24:57,628 --> 00:24:59,769
representation, the character array,

671
00:24:59,769 --> 00:25:03,048
then that could be a problem, but,

672
00:25:03,048 --> 00:25:04,868
you know, maybe I could get

673
00:25:04,868 --> 00:25:07,449
around that problem by I don't know,

674
00:25:07,449 --> 00:25:10,750
maybe I could manually

675
00:25:10,750 --> 00:25:13,469
write a loop that would I don't know,

676
00:25:13,469 --> 00:25:18,169
my text is the other guys maybe I have

677
00:25:18,169 --> 00:25:20,189
a member function called

678
00:25:20,189 --> 00:25:22,869
give me the character at this position.

679
00:25:22,869 --> 00:25:24,410
If that's a public function,

680
00:25:24,410 --> 00:25:25,430
and then I got to make sure

681
00:25:25,430 --> 00:25:28,509
my text with the zero byte there.

682
00:25:28,509 --> 00:25:31,890
If there were public functions for the length

683
00:25:31,890 --> 00:25:34,150
and how to get the value

684
00:25:34,150 --> 00:25:34,828
of a character at

685
00:25:34,828 --> 00:25:36,369
a certain position of the string,

686
00:25:36,369 --> 00:25:38,929
then yeah, I could implement

687
00:25:38,929 --> 00:25:40,949
the copying instructor using

688
00:25:40,949 --> 00:25:43,109
only the public interface of the other guy.

689
00:25:43,109 --> 00:25:46,148
The thing is, in this case, I could do it,

690
00:25:46,148 --> 00:25:47,608
but look, it's more work for me

691
00:25:47,608 --> 00:25:49,990
and maybe not as efficient.

692
00:25:49,990 --> 00:25:53,390
Maybe the library string copy function

693
00:25:53,390 --> 00:25:55,368
is optimized to do

694
00:25:55,368 --> 00:25:57,390
all kinds of clever things very efficiently.

695
00:25:57,390 --> 00:25:59,388
Maybe character at is

696
00:25:59,388 --> 00:26:00,930
implemented to always check

697
00:26:00,930 --> 00:26:02,704
the subscript for validity.

698
00:26:02,704 --> 00:26:05,359
So if I write this myself,

699
00:26:05,359 --> 00:26:07,199
I am paying the cost of

700
00:26:07,199 --> 00:26:09,759
checking that K is always a valid subscript,

701
00:26:09,759 --> 00:26:11,159
even though from the structure of

702
00:26:11,159 --> 00:26:12,778
my loop, of course, it is.

703
00:26:12,778 --> 00:26:15,919
So my implementation might

704
00:26:15,919 --> 00:26:17,098
not be as efficient if I

705
00:26:17,098 --> 00:26:18,679
have to go through the public interface.

706
00:26:18,679 --> 00:26:19,578
And maybe there are

707
00:26:19,578 --> 00:26:21,078
some data members that don't have

708
00:26:21,078 --> 00:26:23,200
a direct public way

709
00:26:23,200 --> 00:26:24,538
of accessing their values.

710
00:26:24,538 --> 00:26:26,739
So, in general, he said, you know,

711
00:26:26,739 --> 00:26:29,670
it's much easier to say, now,

712
00:26:29,670 --> 00:26:32,009
now we will allow

713
00:26:32,009 --> 00:26:33,989
a member function of a class to

714
00:26:33,989 --> 00:26:35,588
access private members of

715
00:26:35,588 --> 00:26:39,108
any other object of that type,

716
00:26:39,108 --> 00:26:40,788
not just the one that this pointer points to.

717
00:26:40,788 --> 00:26:42,150
I'll get rid of these redundant

718
00:26:42,150 --> 00:26:44,328
this arrows that I don't need.

719
00:26:45,289 --> 00:26:49,279
And so that's why, that's

720
00:26:49,279 --> 00:26:50,798
why the copy constructor for

721
00:26:50,798 --> 00:26:54,078
string can actually access and can

722
00:26:54,078 --> 00:26:56,179
talk about and access the private members

723
00:26:56,179 --> 00:26:57,898
of other string objects.

724
00:26:57,898 --> 00:27:01,398
So let me write that. Okay.

725
00:27:01,398 --> 00:27:05,259
So it looks like we're out of the woods.

726
00:27:05,259 --> 00:27:06,440
We had a little issue

727
00:27:06,440 --> 00:27:07,680
we hadn't thought about before,

728
00:27:07,680 --> 00:27:09,239
and we fixed that.

729
00:27:09,239 --> 00:27:11,419
So now our resource management

730
00:27:11,419 --> 00:27:12,858
for string is perfect.

731
00:27:12,858 --> 00:27:15,959
Everything's great. No, we

732
00:27:15,959 --> 00:27:17,638
have yet another problem

733
00:27:17,638 --> 00:27:19,500
that has a bunch of complications.

734
00:27:19,500 --> 00:27:22,819
We're handling copying, creating

735
00:27:22,819 --> 00:27:24,378
a brand new string as

736
00:27:24,378 --> 00:27:27,009
a copy of an existing string.

737
00:27:27,009 --> 00:27:30,979
What we have not handled is assignment,

738
00:27:30,979 --> 00:27:33,880
taking an already existing string,

739
00:27:33,880 --> 00:27:36,000
not a newly constructed string,

740
00:27:36,000 --> 00:27:38,359
a string that we're constructing

741
00:27:38,359 --> 00:27:40,578
an already existing string and

742
00:27:40,578 --> 00:27:41,819
giving it a new value,

743
00:27:41,819 --> 00:27:43,380
giving it a different value.

744
00:27:43,380 --> 00:27:45,440
That's different

745
00:27:45,440 --> 00:27:48,059
from creating a brand new string.

746
00:27:48,059 --> 00:27:49,719
The main way it's different is

747
00:27:49,719 --> 00:27:51,219
the starting conditions are different.

748
00:27:51,219 --> 00:27:53,539
When you create a brand new string as

749
00:27:53,539 --> 00:27:57,259
a when you create a brand new string,

750
00:27:57,259 --> 00:27:58,660
you create a brand new string

751
00:27:58,660 --> 00:28:00,200
as a copy of another string,

752
00:28:00,200 --> 00:28:02,078
this storage has nothing in it.

753
00:28:02,078 --> 00:28:02,920
You can do whatever

754
00:28:02,920 --> 00:28:03,638
you want with the storage.

755
00:28:03,638 --> 00:28:04,818
There's nothing in it, so we

756
00:28:04,818 --> 00:28:06,460
can make our copy just fine.

757
00:28:06,460 --> 00:28:08,159
If you're assigning to

758
00:28:08,159 --> 00:28:10,159
this string this already created

759
00:28:10,159 --> 00:28:12,118
already existing string from

760
00:28:12,118 --> 00:28:14,719
another string, that's different.

761
00:28:14,719 --> 00:28:16,078
This guys not starting out

762
00:28:16,078 --> 00:28:17,419
with uninitialized storage.

763
00:28:17,419 --> 00:28:19,199
This guy has, you know, a pointer dynamic

764
00:28:19,199 --> 00:28:21,460
storage and already has a value.

765
00:28:21,460 --> 00:28:23,138
And you can't just assume,

766
00:28:23,138 --> 00:28:24,959
Oh, I can just put whatever I want in it.

767
00:28:24,959 --> 00:28:26,858
Well, what about the old stuff it has?

768
00:28:26,858 --> 00:28:28,980
Yeah. It's a different problem.

769
00:28:28,980 --> 00:28:32,000
So assignment is different from copying.

770
00:28:32,000 --> 00:28:34,818
The end result is kind of the same in that,

771
00:28:34,818 --> 00:28:35,240
hey,

772
00:28:35,240 --> 00:28:37,219
this object looks like a copy of that one.

773
00:28:37,219 --> 00:28:39,338
The starting conditions are different.

774
00:28:39,338 --> 00:28:42,719
And to take care of assignment properly,

775
00:28:42,719 --> 00:28:44,220
we need to learn something new.

776
00:28:44,220 --> 00:28:46,318
The copy constructor only takes care of

777
00:28:46,318 --> 00:28:48,038
creating brand new objects

778
00:28:48,038 --> 00:28:49,259
as a copy of another one.

779
00:28:49,259 --> 00:28:50,640
Assigning is a different story,

780
00:28:50,640 --> 00:28:53,980
but we'll have to take a look at that later.

781
00:28:53,980 --> 00:28:55,919
Um Okay,

782
00:28:55,919 --> 00:28:57,380
there is a misconception

783
00:28:57,380 --> 00:28:58,398
that some people have.

784
00:28:58,398 --> 00:28:59,980
This is clearly assignment.

785
00:28:59,980 --> 00:29:01,480
I mean, that's clearly assignment.

786
00:29:01,480 --> 00:29:02,819
We're not creating a brand new object.

787
00:29:02,819 --> 00:29:04,298
We're taking an already existing object

788
00:29:04,298 --> 00:29:05,439
and assigning something to it.

789
00:29:05,439 --> 00:29:07,118
That's assignment. This is

790
00:29:07,118 --> 00:29:08,940
clearly instruction.

791
00:29:08,940 --> 00:29:11,319
We're creating a brand new object X

792
00:29:11,319 --> 00:29:13,618
that did not exist before and

793
00:29:13,618 --> 00:29:16,279
copying it from S. But then there's

794
00:29:16,279 --> 00:29:19,179
the question of this holdover syntax from C.

795
00:29:19,179 --> 00:29:21,439
So, this syntax for

796
00:29:21,439 --> 00:29:24,199
C in a declaration is allowed.

797
00:29:24,199 --> 00:29:26,724
And what's going on here?

798
00:29:26,724 --> 00:29:28,828
And the answer is

799
00:29:28,828 --> 00:29:31,308
It's copy construction. It's not assignment.

800
00:29:31,308 --> 00:29:33,828
And you say, but there's an equals sign here.

801
00:29:33,828 --> 00:29:35,950
That's not the assignment operator.

802
00:29:35,950 --> 00:29:37,489
This is construction because

803
00:29:37,489 --> 00:29:39,750
we are creating a brand new.

804
00:29:39,750 --> 00:29:42,269
We're creating a brand new object

805
00:29:42,269 --> 00:29:44,150
that did not exist before.

806
00:29:44,150 --> 00:29:45,890
Why did not exist before.

807
00:29:45,890 --> 00:29:47,890
We're declaring Y is a brand new string.

808
00:29:47,890 --> 00:29:49,669
We're giving its very first value

809
00:29:49,669 --> 00:29:52,160
copied from S. It's

810
00:29:52,160 --> 00:29:54,239
not that Y is an existing object that

811
00:29:54,239 --> 00:29:55,400
we are now giving a new value

812
00:29:55,400 --> 00:29:56,638
to, it's getting creative.

813
00:29:56,638 --> 00:30:00,439
That's construction. So be careful.

814
00:30:00,439 --> 00:30:02,858
The meaning of this symbol

815
00:30:02,858 --> 00:30:05,818
here and this symbol here are different.

816
00:30:05,818 --> 00:30:07,378
That's the assignment operator.

817
00:30:07,378 --> 00:30:09,059
This is just a little bit of syntax

818
00:30:09,059 --> 00:30:10,799
that separates the variable you're

819
00:30:10,799 --> 00:30:15,180
declaring from the initialization expression.

820
00:30:15,180 --> 00:30:18,838
So we've seen how to deal with this stuff.

821
00:30:18,838 --> 00:30:20,359
We've written the copy constructor.

822
00:30:20,359 --> 00:30:23,259
We haven't done the assignment operator yet.

823
00:30:23,259 --> 00:30:27,740
So let's say now here, Uh oh.

824
00:30:27,740 --> 00:30:29,319
I spilled coffee on my shirt again.

825
00:30:29,319 --> 00:30:31,500
Give me a second to change.

826
00:30:33,400 --> 00:30:36,798
Okay, where was I?

827
00:30:37,519 --> 00:30:41,179
Let's say now here in the function H,

828
00:30:41,179 --> 00:30:43,338
let's say we have a string,

829
00:30:43,338 --> 00:30:45,440
say initialized to WOW.

830
00:30:45,440 --> 00:30:48,999
And then later on, we assign S to U.

831
00:30:48,999 --> 00:30:50,378
Okay, so you look at it and say,

832
00:30:50,378 --> 00:30:51,798
well, all right,

833
00:30:51,798 --> 00:30:53,180
the goal of assignment

834
00:30:53,180 --> 00:30:54,759
is to make the left hand side

835
00:30:54,759 --> 00:30:55,818
look like a copy of

836
00:30:55,818 --> 00:30:58,058
the right hand side, right?

837
00:30:58,058 --> 00:30:59,680
That's certainly true for integers.

838
00:30:59,680 --> 00:31:02,919
I I I have an integer K and an integer N,

839
00:31:02,919 --> 00:31:05,038
and I say K equals N,

840
00:31:05,038 --> 00:31:06,939
the goal is to take the value of N,

841
00:31:06,939 --> 00:31:07,679
store it in K,

842
00:31:07,679 --> 00:31:09,604
so K looks like a copy of M.

843
00:31:09,604 --> 00:31:11,469
That's what everybody expects

844
00:31:11,469 --> 00:31:12,969
the assignment operator to do.

845
00:31:12,969 --> 00:31:16,048
So it's your job as a class designer to make

846
00:31:16,048 --> 00:31:17,490
sure that assignment works

847
00:31:17,490 --> 00:31:20,409
properly for your class and has that effect?

848
00:31:20,409 --> 00:31:24,989
Well, again, we have a problem here.

849
00:31:24,989 --> 00:31:26,548
If we don't declare

850
00:31:26,548 --> 00:31:27,689
an assignment operator and

851
00:31:27,689 --> 00:31:28,929
implement an assignment operator,

852
00:31:28,929 --> 00:31:30,509
we don't declare an assignment operator,

853
00:31:30,509 --> 00:31:32,709
the compiler writes one for us that

854
00:31:32,709 --> 00:31:36,650
simply assigns each data member.

855
00:31:37,410 --> 00:31:39,568
And that's not going to be right here.

856
00:31:39,568 --> 00:31:40,930
Now you might say, Well, wait a minute

857
00:31:40,930 --> 00:31:42,910
I thought we defined a copy constructor.

858
00:31:42,910 --> 00:31:44,970
The copy constructor only

859
00:31:44,970 --> 00:31:46,909
applies when you are

860
00:31:46,909 --> 00:31:49,210
creating only comes into effect when you're

861
00:31:49,210 --> 00:31:51,169
creating a brand new object

862
00:31:51,169 --> 00:31:52,609
that didn't exist before,

863
00:31:52,609 --> 00:31:54,269
you're constructing a new object,

864
00:31:54,269 --> 00:31:57,209
giving it its very first value.

865
00:31:57,809 --> 00:32:00,769
That's what happens when T gets

866
00:32:00,769 --> 00:32:04,930
created as a copy of S when we call FS.

867
00:32:04,930 --> 00:32:08,529
T didn't exist before we made this call,

868
00:32:08,529 --> 00:32:10,369
and so now we're making the call

869
00:32:10,369 --> 00:32:11,749
and T is getting created for

870
00:32:11,749 --> 00:32:13,670
the very first time is being

871
00:32:13,670 --> 00:32:15,230
created for S. That's

872
00:32:15,230 --> 00:32:16,750
going to be construction.

873
00:32:16,750 --> 00:32:18,589
T will be constructed

874
00:32:18,589 --> 00:32:19,710
by the copying instructor.

875
00:32:19,710 --> 00:32:21,628
But assignment is different.

876
00:32:21,628 --> 00:32:24,130
U is not being

877
00:32:24,130 --> 00:32:27,169
created in this statement. U already exists.

878
00:32:27,169 --> 00:32:29,429
The previous statement created.

879
00:32:29,429 --> 00:32:32,128
So assignments different because

880
00:32:32,128 --> 00:32:33,888
the starting condition is different.

881
00:32:33,888 --> 00:32:35,529
The end result is, yeah,

882
00:32:35,529 --> 00:32:37,909
yeah, U is going to look like a copy of S,

883
00:32:37,909 --> 00:32:39,430
just like T looked like a copy

884
00:32:39,430 --> 00:32:41,069
of S when we use the copying instructor,

885
00:32:41,069 --> 00:32:43,108
passing over to T. But

886
00:32:43,108 --> 00:32:44,868
the starting condition is different.

887
00:32:44,868 --> 00:32:47,140
T did not exist before.

888
00:32:47,140 --> 00:32:49,209
Whatever was in the data member was

889
00:32:49,209 --> 00:32:51,430
uninitialized garbage before

890
00:32:51,430 --> 00:32:52,970
the constructor started executing.

891
00:32:52,970 --> 00:32:54,589
But with the assignment operator,

892
00:32:54,589 --> 00:32:56,868
you already has a value,

893
00:32:56,868 --> 00:32:59,009
and there's already stuff inside you.

894
00:32:59,009 --> 00:33:01,028
It's already been initialized

895
00:33:01,028 --> 00:33:02,128
through a constructor at

896
00:33:02,128 --> 00:33:03,190
sometime in the past,

897
00:33:03,190 --> 00:33:05,430
and now we're giving it a new value.

898
00:33:05,430 --> 00:33:07,390
And that situation is very different.

899
00:33:07,390 --> 00:33:10,265
So let me go to the board again.

900
00:33:10,265 --> 00:33:13,759
This time I'll do it, right? Let me

901
00:33:13,759 --> 00:33:14,559
go to the board again

902
00:33:14,559 --> 00:33:16,159
and see what the story is here.

903
00:33:16,159 --> 00:33:18,598
So we created you

904
00:33:18,598 --> 00:33:20,219
by calling the constructor

905
00:33:20,219 --> 00:33:21,680
that took the C string WOW.

906
00:33:21,680 --> 00:33:23,378
So the length of that is three.

907
00:33:23,378 --> 00:33:25,219
It allocated an array of

908
00:33:25,219 --> 00:33:30,778
four items and started pointering there,

909
00:33:30,778 --> 00:33:33,459
and then copied the text WOW into there.

910
00:33:33,459 --> 00:33:35,199
So after creating you,

911
00:33:35,199 --> 00:33:36,699
the situation looks like that.

912
00:33:36,699 --> 00:33:38,778
So now what we're going to do is

913
00:33:38,778 --> 00:33:40,479
assign, we said,

914
00:33:40,479 --> 00:33:43,579
U gets S. Now,

915
00:33:43,579 --> 00:33:44,660
we didn't say anything

916
00:33:44,660 --> 00:33:45,819
about how to do assignment.

917
00:33:45,819 --> 00:33:47,278
We only said how to do copying,

918
00:33:47,278 --> 00:33:49,098
and assignment is not the same as

919
00:33:49,098 --> 00:33:50,499
copying because the

920
00:33:50,499 --> 00:33:51,919
starting condition is different.

921
00:33:51,919 --> 00:33:54,779
So if we don't say how to do assignment,

922
00:33:54,779 --> 00:33:56,398
the compiler says, Okay,

923
00:33:56,398 --> 00:33:59,499
I will simply assign each data member.

924
00:33:59,499 --> 00:34:04,239
So it assigns the pointer.

925
00:34:04,239 --> 00:34:08,139
So the pointer and tex data member

926
00:34:08,139 --> 00:34:09,278
of U gets assigned from the

927
00:34:09,278 --> 00:34:10,438
tex data member of

928
00:34:10,438 --> 00:34:16,659
S. So that pointer gets assigned over here,

929
00:34:16,659 --> 00:34:19,798
and the five gets assigned over here.

930
00:34:21,800 --> 00:34:26,179
So now you has the text

931
00:34:26,179 --> 00:34:30,349
hello and the length five well,

932
00:34:30,349 --> 00:34:32,548
that looks like a copy of S. Well,

933
00:34:32,548 --> 00:34:34,248
but no, look at the whole picture.

934
00:34:34,248 --> 00:34:36,168
No, it's not a copy of S.

935
00:34:36,168 --> 00:34:38,829
It's sharing the same text as S,

936
00:34:38,829 --> 00:34:41,188
same problem we had with copy constructor.

937
00:34:41,188 --> 00:34:42,648
And so we're certainly going to have

938
00:34:42,648 --> 00:34:44,849
the same problem later on.

939
00:34:44,849 --> 00:34:47,608
W U gets destroyed,

940
00:34:47,608 --> 00:34:51,248
the destructor will get rid of this storage.

941
00:34:51,248 --> 00:34:53,088
And so when S gets destroyed,

942
00:34:53,088 --> 00:34:56,188
we try to call the delete

943
00:34:56,188 --> 00:34:58,349
on already deleted storage.

944
00:34:58,349 --> 00:34:59,028
So it's got

945
00:34:59,028 --> 00:35:00,929
that same problem as copy constructor,

946
00:35:00,929 --> 00:35:02,489
all those same problems, plus

947
00:35:02,489 --> 00:35:04,128
one more a memory leak.

948
00:35:04,128 --> 00:35:06,514
We never got rid of the WOW.

949
00:35:06,514 --> 00:35:09,478
So the old value of you is linked here.

950
00:35:09,478 --> 00:35:10,679
That's what makes assignment

951
00:35:10,679 --> 00:35:12,219
different from copying.

952
00:35:12,219 --> 00:35:14,099
The starting condition is different.

953
00:35:14,099 --> 00:35:17,679
You already had a pointer to dynamic storage,

954
00:35:17,679 --> 00:35:20,318
and so if you were to

955
00:35:20,318 --> 00:35:22,119
even if you applied

956
00:35:22,119 --> 00:35:24,099
the copy constructor to somehow say,

957
00:35:24,099 --> 00:35:26,139
Well, you know, let's

958
00:35:26,139 --> 00:35:29,378
first bring over the length,

959
00:35:29,378 --> 00:35:30,840
then let's allocate new storage

960
00:35:30,840 --> 00:35:31,559
for you to point to.

961
00:35:31,559 --> 00:35:33,659
Even if you were pointing to new storage,

962
00:35:33,659 --> 00:35:35,619
we wiped out the old storage.

963
00:35:35,619 --> 00:35:38,239
So if the assignment operator

964
00:35:38,239 --> 00:35:39,739
simply called the copy constructor,

965
00:35:39,739 --> 00:35:41,599
which it does not, but if it

966
00:35:41,599 --> 00:35:44,998
did, we'd still have a problem.

967
00:35:44,998 --> 00:35:47,079
So we cannot let the compiler

968
00:35:47,079 --> 00:35:48,219
write the assignment operator

969
00:35:48,219 --> 00:35:49,643
for us in this case.

970
00:35:49,643 --> 00:35:53,228
Now, why didn't we have this problem before?

971
00:35:53,228 --> 00:35:55,228
Well, look at the

972
00:35:55,228 --> 00:35:57,369
kinds of things we had before.

973
00:35:57,369 --> 00:36:02,429
We had, for example, a circle object,

974
00:36:02,429 --> 00:36:05,048
and a circle had a radius, I'm sorry,

975
00:36:05,048 --> 00:36:06,349
had an X and Y coordinate in

976
00:36:06,349 --> 00:36:08,409
the center and a radius.

977
00:36:08,409 --> 00:36:10,789
And if I had another circle

978
00:36:10,789 --> 00:36:13,429
that already had a value,

979
00:36:16,000 --> 00:36:17,998
so here's another circle

980
00:36:17,998 --> 00:36:19,059
that already has a value.

981
00:36:19,059 --> 00:36:22,498
If I assign this circle to this circle, now,

982
00:36:22,498 --> 00:36:23,938
we'd never declared an

983
00:36:23,938 --> 00:36:25,358
assignment operator for circle,

984
00:36:25,358 --> 00:36:26,679
so the compiler simply

985
00:36:26,679 --> 00:36:28,438
did member by member assignment.

986
00:36:28,438 --> 00:36:30,139
It assigned the negative two over

987
00:36:30,139 --> 00:36:32,159
to here, the five over to here,

988
00:36:32,159 --> 00:36:34,298
the ten over to here, and

989
00:36:34,298 --> 00:36:35,918
now this circle has negative two,

990
00:36:35,918 --> 00:36:38,219
five and ten. That's fine.

991
00:36:38,219 --> 00:36:42,059
That works. No memory leak, no problem here.

992
00:36:42,059 --> 00:36:44,778
So member my member assignment

993
00:36:44,778 --> 00:36:46,878
works in the case of,

994
00:36:46,878 --> 00:36:49,719
all you have is simple types

995
00:36:49,719 --> 00:36:51,340
that don't hold any resources.

996
00:36:51,340 --> 00:36:52,998
So if you just wipe out the old value by

997
00:36:52,998 --> 00:36:56,199
assigning over the new value, not a problem.

998
00:36:57,599 --> 00:37:00,679
Okay, but now we face something different.

999
00:37:00,679 --> 00:37:02,739
So how do we solve the problem?

1000
00:37:02,739 --> 00:37:05,179
So the way Str Stip decided to

1001
00:37:05,179 --> 00:37:07,259
do it was say, All right,

1002
00:37:07,259 --> 00:37:09,219
assignment will

1003
00:37:09,219 --> 00:37:12,739
be a member function of a class.

1004
00:37:12,739 --> 00:37:13,739
And if you don't write one,

1005
00:37:13,739 --> 00:37:14,978
the compiler writes one for you,

1006
00:37:14,978 --> 00:37:16,679
that does member by member assignment.

1007
00:37:16,679 --> 00:37:19,219
But if you want to change it, you've

1008
00:37:19,219 --> 00:37:20,358
got to write your own

1009
00:37:20,358 --> 00:37:22,519
version of the assignment operator.

1010
00:37:22,519 --> 00:37:28,838
What that means is the assignment U equals S

1011
00:37:28,838 --> 00:37:32,179
is really just a convenient shorthand like

1012
00:37:32,179 --> 00:37:33,840
any other operator

1013
00:37:33,840 --> 00:37:36,079
defined as a member function.

1014
00:37:36,820 --> 00:37:40,619
It's really just a shorthand for take

1015
00:37:40,619 --> 00:37:42,639
you call some member function

1016
00:37:42,639 --> 00:37:44,338
with S as an argument.

1017
00:37:44,338 --> 00:37:47,619
And the name of that member function

1018
00:37:47,619 --> 00:37:50,358
is operator equal.

1019
00:37:50,358 --> 00:37:52,259
It's a funny looking name

1020
00:37:52,259 --> 00:37:53,318
for a function, but again,

1021
00:37:53,318 --> 00:37:54,800
this is what happens when you overload

1022
00:37:54,800 --> 00:37:56,458
functions of C plus plus.

1023
00:37:56,458 --> 00:37:59,579
You do so by creating functions whose name is

1024
00:37:59,579 --> 00:38:01,358
the word operator followed

1025
00:38:01,358 --> 00:38:01,458
by

1026
00:38:01,458 --> 00:38:04,039
the operator symbol that you're overloading.

1027
00:38:04,039 --> 00:38:07,119
So assigning STU is

1028
00:38:07,119 --> 00:38:09,099
done by calling a member function on you

1029
00:38:09,099 --> 00:38:11,539
named operator equals with the argument S.

1030
00:38:11,539 --> 00:38:13,099
It's just that we're allowed to

1031
00:38:13,099 --> 00:38:14,938
simplify that and write it this way.

1032
00:38:14,938 --> 00:38:16,338
So our goal is to write

1033
00:38:16,338 --> 00:38:18,134
this operator equal function.

1034
00:38:18,134 --> 00:38:20,409
So that we get the correct behavior.

1035
00:38:20,409 --> 00:38:23,268
Okay, so let's see

1036
00:38:23,268 --> 00:38:25,048
what that function would have to do.

1037
00:38:25,048 --> 00:38:27,130
So we start with a condition

1038
00:38:27,130 --> 00:38:31,608
where points has some old value,

1039
00:38:31,608 --> 00:38:32,268
say it points to

1040
00:38:32,268 --> 00:38:34,349
WOW and it has a length of three.

1041
00:38:34,349 --> 00:38:38,409
Let me get this out of the way. Now, in

1042
00:38:38,409 --> 00:38:39,590
this called operator equal,

1043
00:38:39,590 --> 00:38:41,528
so let me write it up here.

1044
00:38:42,409 --> 00:38:44,789
Is the object being modified,

1045
00:38:44,789 --> 00:38:47,969
so is the object that this pointer points to.

1046
00:38:49,650 --> 00:38:53,349
And S will be the other guy.

1047
00:38:53,349 --> 00:38:54,748
We'll pass S by

1048
00:38:54,748 --> 00:38:57,050
reference to this member function.

1049
00:38:57,050 --> 00:38:58,929
We'll show that in a minute.

1050
00:39:04,170 --> 00:39:07,889
Okay, so let's see what would have to happen.

1051
00:39:07,889 --> 00:39:10,188
Now, we know the goal

1052
00:39:10,188 --> 00:39:11,989
is to make you look like a copy of S.

1053
00:39:11,989 --> 00:39:14,268
So what are we doing

1054
00:39:14,268 --> 00:39:15,469
the copy constructor to make

1055
00:39:15,469 --> 00:39:16,829
you look like a copy of S?

1056
00:39:16,829 --> 00:39:19,969
Well, we have signed over the length.

1057
00:39:19,969 --> 00:39:23,108
So if we change the three to a five,

1058
00:39:23,108 --> 00:39:25,030
that's making progress.

1059
00:39:25,030 --> 00:39:26,889
That seems reasonable.

1060
00:39:27,460 --> 00:39:30,838
Then we dynamically allocated

1061
00:39:30,838 --> 00:39:32,938
an array and stored the pointer in here.

1062
00:39:32,938 --> 00:39:34,818
Oh, but wait, we've got the old one here.

1063
00:39:34,818 --> 00:39:36,400
So we better delete

1064
00:39:36,400 --> 00:39:40,159
the storage that you points to.

1065
00:39:40,159 --> 00:39:43,338
So somewhere in here before we

1066
00:39:43,338 --> 00:39:44,619
replace the pointer here with

1067
00:39:44,619 --> 00:39:46,360
a pointer to the new storage,

1068
00:39:46,360 --> 00:39:47,759
we need to call Delete on

1069
00:39:47,759 --> 00:39:50,380
this pointer to get rid of that storage.

1070
00:39:50,380 --> 00:39:52,298
So if we do that, we call

1071
00:39:52,298 --> 00:39:53,179
Delete on this pointer,

1072
00:39:53,179 --> 00:39:54,579
get rid of that storage.

1073
00:39:54,579 --> 00:39:57,018
Now the WOW is gone.

1074
00:39:57,018 --> 00:39:58,438
We're not going to have a memory leak

1075
00:39:58,438 --> 00:39:59,119
anymore if we do

1076
00:39:59,119 --> 00:40:00,418
everything right from here on.

1077
00:40:00,418 --> 00:40:02,760
So now we can dynamically allocate

1078
00:40:02,760 --> 00:40:06,458
a new array and set you to point to it.

1079
00:40:07,929 --> 00:40:13,188
Copy over the text. And when

1080
00:40:13,188 --> 00:40:15,889
we're done, we're in great shape.

1081
00:40:15,889 --> 00:40:17,969
You looks like a copy of S,

1082
00:40:17,969 --> 00:40:20,048
which is what assignment ought to do.

1083
00:40:20,048 --> 00:40:22,768
We properly cleaned up the old value of you.

1084
00:40:22,768 --> 00:40:26,228
There's no memory leak. And you has

1085
00:40:26,228 --> 00:40:28,028
a nice independent copy of S.

1086
00:40:28,028 --> 00:40:31,068
So does whatever we do to you,

1087
00:40:31,068 --> 00:40:33,269
has no effect on S. Perfect.

1088
00:40:33,269 --> 00:40:35,130
That's what we want to have happen.

1089
00:40:35,130 --> 00:40:37,849
So the traditional way of

1090
00:40:37,849 --> 00:40:39,309
writing the assignment operator

1091
00:40:39,309 --> 00:40:41,329
essentially does those steps.

1092
00:40:41,329 --> 00:40:43,409
I say traditional because I'll show

1093
00:40:43,409 --> 00:40:45,489
you the modern way later.

1094
00:40:45,489 --> 00:40:48,088
So the traditional way

1095
00:40:49,289 --> 00:40:53,590
Is going to look like this. So almost,

1096
00:40:53,590 --> 00:40:55,048
I'm not quite there yet,

1097
00:40:55,048 --> 00:40:56,489
but we're getting there.

1098
00:40:56,489 --> 00:41:06,469
So we'll have the right hand side,

1099
00:41:06,469 --> 00:41:07,949
RHS, or the right hand side of

1100
00:41:07,949 --> 00:41:10,329
the operator, the assignment operator.

1101
00:41:10,329 --> 00:41:11,969
It's not quite I

1102
00:41:11,969 --> 00:41:13,389
mean, it's technically legal,

1103
00:41:13,389 --> 00:41:15,469
but it's not quite the conventional way

1104
00:41:15,469 --> 00:41:16,769
you write an assignment operator.

1105
00:41:16,769 --> 00:41:18,528
I will fix it later, but it's

1106
00:41:18,528 --> 00:41:20,670
not quite following the conventions.

1107
00:41:20,670 --> 00:41:21,969
I will get to that later.

1108
00:41:21,969 --> 00:41:23,449
But the basic idea is

1109
00:41:23,449 --> 00:41:25,550
the argument to the assignment operator

1110
00:41:25,550 --> 00:41:28,210
will be passed by constant reference.

1111
00:41:28,210 --> 00:41:31,869
And so let me write it.

1112
00:41:31,869 --> 00:41:33,588
I'll put it here so the code

1113
00:41:33,588 --> 00:41:36,148
will be nearby. Okay.

1114
00:41:36,148 --> 00:41:38,429
Again, I will fix the signature

1115
00:41:38,429 --> 00:41:40,009
to the function later.

1116
00:41:40,009 --> 00:41:44,168
So Okay. It's not

1117
00:41:44,168 --> 00:41:45,570
quite following the convention.

1118
00:41:45,570 --> 00:41:49,108
So we want to clean up the left hand side.

1119
00:41:49,108 --> 00:41:51,170
In a call to the operator equal,

1120
00:41:51,170 --> 00:41:53,648
that means you gets S means

1121
00:41:53,648 --> 00:41:55,789
you were calling the operator

1122
00:41:55,789 --> 00:41:57,188
equal member function on S,

1123
00:41:57,188 --> 00:42:00,668
which means so this pointer points to U,

1124
00:42:00,668 --> 00:42:04,289
and the parameter RHS is a reference to

1125
00:42:04,289 --> 00:42:06,108
S. So the this pointer

1126
00:42:06,108 --> 00:42:07,630
points to the left hand side object,

1127
00:42:07,630 --> 00:42:09,849
the one that we're assigning to,

1128
00:42:09,849 --> 00:42:12,690
and RHS is another name for the parameter.

1129
00:42:12,690 --> 00:42:14,110
That's the argument we passed.

1130
00:42:14,110 --> 00:42:15,570
So we want to delete

1131
00:42:15,570 --> 00:42:17,768
the old text of the left hand side.

1132
00:42:17,768 --> 00:42:21,190
And now that we've done that, basically,

1133
00:42:21,190 --> 00:42:24,949
we would just make

1134
00:42:24,949 --> 00:42:26,548
the left hand side look like a copy of

1135
00:42:26,548 --> 00:42:28,068
the right hand side by doing

1136
00:42:28,068 --> 00:42:29,829
the same thing we did to the right hand side.

1137
00:42:29,829 --> 00:42:30,748
But let me note that

1138
00:42:30,748 --> 00:42:33,708
this implementation is not quite right.

1139
00:42:34,630 --> 00:42:36,489
We'll fix it later,

1140
00:42:36,489 --> 00:42:37,588
but I want to make sure I put that

1141
00:42:37,588 --> 00:42:38,648
there for people who,

1142
00:42:38,648 --> 00:42:40,148
you know, look at this slide.

1143
00:42:40,148 --> 00:42:41,568
Look at this text at

1144
00:42:41,568 --> 00:42:43,110
some point in the future

1145
00:42:43,110 --> 00:42:44,409
and think that this code is correct.

1146
00:42:44,409 --> 00:42:46,148
So as long as these labels are here,

1147
00:42:46,148 --> 00:42:47,248
this is not correct.

1148
00:42:47,248 --> 00:42:49,548
Whoops, pretend the two occurrences of

1149
00:42:49,548 --> 00:42:52,630
the word other are really RHS.

1150
00:42:52,630 --> 00:42:54,548
It's going to take another 13 minutes

1151
00:42:54,548 --> 00:42:56,963
before the guy in the video recognizes that.

1152
00:42:56,963 --> 00:42:58,998
So this was the code that I

1153
00:42:58,998 --> 00:43:01,298
essentially executed on the board.

1154
00:43:01,298 --> 00:43:02,778
I got rid of the WOW

1155
00:43:02,778 --> 00:43:04,338
that you used to point to.

1156
00:43:04,338 --> 00:43:05,998
And once I did that, I was

1157
00:43:05,998 --> 00:43:07,699
free to go ahead and assign

1158
00:43:07,699 --> 00:43:09,239
the length and assign something

1159
00:43:09,239 --> 00:43:11,039
new to the text to the left hand side.

1160
00:43:11,039 --> 00:43:12,679
No problem. Okay.

1161
00:43:12,679 --> 00:43:14,378
So now let me

1162
00:43:14,378 --> 00:43:16,458
go through and fix up a few things.

1163
00:43:16,458 --> 00:43:19,309
Well, first of all, there's something

1164
00:43:19,309 --> 00:43:22,568
that's not required for us to do,

1165
00:43:22,568 --> 00:43:24,489
but is a convention,

1166
00:43:24,489 --> 00:43:27,769
and that is to make o the assignment operator

1167
00:43:27,769 --> 00:43:29,369
usable in a similar way

1168
00:43:29,369 --> 00:43:32,108
to the way it is for built in types.

1169
00:43:32,108 --> 00:43:35,949
So for built in types, like say integers,

1170
00:43:35,949 --> 00:43:39,309
if I have an integer K that has the value

1171
00:43:39,309 --> 00:43:41,208
three and I have

1172
00:43:41,208 --> 00:43:44,728
some integer M that has the value five,

1173
00:43:44,728 --> 00:43:47,748
and let's say I have some integer M,

1174
00:43:48,019 --> 00:43:50,900
Now, for built in types,

1175
00:43:50,900 --> 00:43:53,619
assignment returns a value.

1176
00:43:53,619 --> 00:43:55,358
We normally don't use it that way, right?

1177
00:43:55,358 --> 00:43:56,679
Normally, we might say something

1178
00:43:56,679 --> 00:43:58,438
like after doing this,

1179
00:43:58,438 --> 00:44:02,798
K gets N. So that assigns N to K,

1180
00:44:02,798 --> 00:44:04,478
replacing the value of K

1181
00:44:04,478 --> 00:44:05,338
that was three with

1182
00:44:05,338 --> 00:44:06,639
the value of N, which is five.

1183
00:44:06,639 --> 00:44:09,039
So this makes K have the value five.

1184
00:44:09,039 --> 00:44:11,579
And as it turns out,

1185
00:44:12,150 --> 00:44:15,048
this expression returns a value

1186
00:44:15,048 --> 00:44:17,228
as well, the new value K.

1187
00:44:17,228 --> 00:44:19,009
But we don't use it, right?

1188
00:44:19,009 --> 00:44:20,809
We're not using that value as

1189
00:44:20,809 --> 00:44:22,190
part of a bigger expression

1190
00:44:22,190 --> 00:44:24,710
in most uses the way we write assignment.

1191
00:44:24,710 --> 00:44:26,469
But you can if you want.

1192
00:44:26,469 --> 00:44:32,608
So for example, if I say M K gets N.

1193
00:44:32,608 --> 00:44:36,449
Now, the associativity

1194
00:44:36,449 --> 00:44:37,730
of the assignment operator,

1195
00:44:37,730 --> 00:44:39,030
unlike every other operator

1196
00:44:39,030 --> 00:44:39,648
for the most part,

1197
00:44:39,648 --> 00:44:41,648
is right to left, not left to right.

1198
00:44:41,648 --> 00:44:43,568
So I didn't write

1199
00:44:43,568 --> 00:44:45,568
any parentheses here because I don't have to,

1200
00:44:45,568 --> 00:44:47,128
but if I wanted

1201
00:44:47,128 --> 00:44:48,690
to be clear about what was happening,

1202
00:44:48,690 --> 00:44:50,668
I would put the parentheses here.

1203
00:44:50,668 --> 00:44:51,989
In other words, N

1204
00:44:51,989 --> 00:44:53,548
is going to be assigned to K,

1205
00:44:53,548 --> 00:44:55,068
and then the result of this

1206
00:44:55,068 --> 00:44:56,510
expression will be assigned

1207
00:44:56,510 --> 00:44:59,369
to M. So the five in N gets assigned to K,

1208
00:44:59,369 --> 00:45:01,588
so K will have the value five,

1209
00:45:01,588 --> 00:45:03,429
and the result of the assignment

1210
00:45:03,429 --> 00:45:04,989
is the new value of

1211
00:45:04,989 --> 00:45:07,949
K. N gets assigned

1212
00:45:07,949 --> 00:45:08,750
to K and the result

1213
00:45:08,750 --> 00:45:09,688
of the expression is five,

1214
00:45:09,688 --> 00:45:11,809
the new value of K, and the new value of

1215
00:45:11,809 --> 00:45:12,969
K will then also get

1216
00:45:12,969 --> 00:45:14,728
assigned to M. So in other words,

1217
00:45:14,728 --> 00:45:16,208
the five in N got

1218
00:45:16,208 --> 00:45:18,949
assigned to K which got assigned to M.

1219
00:45:18,949 --> 00:45:20,630
So you can string together

1220
00:45:20,630 --> 00:45:21,929
assignments this way or use

1221
00:45:21,929 --> 00:45:23,510
assignments in other contexts

1222
00:45:23,510 --> 00:45:25,449
where it'll return a value,

1223
00:45:25,449 --> 00:45:26,869
which will be the new value

1224
00:45:26,869 --> 00:45:28,454
of the left hand side.

1225
00:45:28,454 --> 00:45:30,119
That's not a feature

1226
00:45:30,119 --> 00:45:31,679
that's used tremendously much,

1227
00:45:31,679 --> 00:45:33,719
but it is part

1228
00:45:33,719 --> 00:45:35,918
of the language in C and C plus plus.

1229
00:45:35,918 --> 00:45:37,259
So the style for

1230
00:45:37,259 --> 00:45:38,518
writing assignment operator for

1231
00:45:38,518 --> 00:45:41,318
your own types is to follow the same idea.

1232
00:45:41,318 --> 00:45:43,298
Do the same thing, make it so that

1233
00:45:43,298 --> 00:45:44,559
your assignment of strings

1234
00:45:44,559 --> 00:45:46,219
could be strung together this way.

1235
00:45:46,219 --> 00:45:48,440
That is, if I had three strings,

1236
00:45:48,440 --> 00:45:50,318
let's have some other string.

1237
00:45:50,318 --> 00:45:52,400
So, let's say, these were all strings.

1238
00:45:52,400 --> 00:45:54,579
We want the same effect.

1239
00:45:54,579 --> 00:45:56,918
So the language says

1240
00:45:56,918 --> 00:45:58,699
the precedence of the assignment operator

1241
00:45:58,699 --> 00:45:59,338
is right to left,

1242
00:45:59,338 --> 00:46:00,878
so this will be treated this way.

1243
00:46:00,878 --> 00:46:02,938
So in other words, the goal is

1244
00:46:02,938 --> 00:46:05,039
to assign S to U and

1245
00:46:05,039 --> 00:46:07,159
then use the result

1246
00:46:07,159 --> 00:46:10,143
of the assignment and assign it to.

1247
00:46:10,143 --> 00:46:12,070
So what should the result

1248
00:46:12,070 --> 00:46:13,329
of the assignment be?

1249
00:46:13,329 --> 00:46:15,610
Well, following the pattern

1250
00:46:15,610 --> 00:46:17,728
with integers or other built in types,

1251
00:46:17,728 --> 00:46:20,628
I guess, the new value of U. So that's it.

1252
00:46:20,628 --> 00:46:22,248
The convention in C plus

1253
00:46:22,248 --> 00:46:23,268
plus is when you

1254
00:46:23,268 --> 00:46:24,610
overload the assignment operator,

1255
00:46:24,610 --> 00:46:27,128
you declare it as a function that will

1256
00:46:27,128 --> 00:46:30,608
return the new value of the left hand side.

1257
00:46:30,608 --> 00:46:33,449
So if the new value of U gets returned,

1258
00:46:33,449 --> 00:46:34,969
and that gets assigned to V, well,

1259
00:46:34,969 --> 00:46:36,128
then this has the same

1260
00:46:36,128 --> 00:46:37,849
effect as it does for integers.

1261
00:46:37,849 --> 00:46:39,628
The current value of S, which is

1262
00:46:39,628 --> 00:46:41,809
let's say hello gets assigned to U,

1263
00:46:41,809 --> 00:46:45,199
and that hello then gets assigned over to V.

1264
00:46:45,199 --> 00:46:47,989
Okay, so it's the convention you ought

1265
00:46:47,989 --> 00:46:50,429
to follow because everybody does it that way.

1266
00:46:50,429 --> 00:46:53,250
So let me see what that looks like in code.

1267
00:46:53,250 --> 00:46:55,530
So that would say, apparently,

1268
00:46:55,530 --> 00:46:57,648
the assignment operator is going to

1269
00:46:57,648 --> 00:46:59,409
return the new value

1270
00:46:59,409 --> 00:47:01,168
of the left hand side, which is a string.

1271
00:47:01,168 --> 00:47:02,869
So I'll say string for now.

1272
00:47:02,869 --> 00:47:04,449
That's not quite again,

1273
00:47:04,449 --> 00:47:05,710
it's not quite conventional,

1274
00:47:05,710 --> 00:47:07,909
so I'll fix this in a minute.

1275
00:47:07,909 --> 00:47:09,989
And this is still not quite

1276
00:47:09,989 --> 00:47:11,768
conventional. I'll fix that in a minute.

1277
00:47:11,768 --> 00:47:14,248
But the idea would be when we're all done,

1278
00:47:14,248 --> 00:47:16,510
we're going to return the new value

1279
00:47:16,510 --> 00:47:18,068
of the left hand side.

1280
00:47:18,068 --> 00:47:20,608
Now, when we do this assignment,

1281
00:47:20,608 --> 00:47:22,489
the left hand side

1282
00:47:22,489 --> 00:47:25,449
is you. So this points to you.

1283
00:47:25,449 --> 00:47:28,869
So do we say return this no,

1284
00:47:28,869 --> 00:47:30,568
we don't say return this.

1285
00:47:30,568 --> 00:47:33,929
This is of type pointer to string.

1286
00:47:33,929 --> 00:47:35,949
So if we said return this,

1287
00:47:35,949 --> 00:47:37,409
we would be returning

1288
00:47:37,409 --> 00:47:40,108
a pointer to the left hand side.

1289
00:47:40,108 --> 00:47:41,628
That's not what we want to return.

1290
00:47:41,628 --> 00:47:42,909
We want to return the

1291
00:47:42,909 --> 00:47:44,829
actual new value of the left hand side.

1292
00:47:44,829 --> 00:47:47,269
So we have to follow the pointer.

1293
00:47:47,269 --> 00:47:48,809
We want to return the

1294
00:47:48,809 --> 00:47:50,548
object that this points to.

1295
00:47:50,548 --> 00:47:52,309
Star this means the object

1296
00:47:52,309 --> 00:47:53,268
that this points to.

1297
00:47:53,268 --> 00:47:54,648
Star of any pointer means

1298
00:47:54,648 --> 00:47:56,009
the object the pointer points to.

1299
00:47:56,009 --> 00:47:58,409
So that's now correct.

1300
00:47:58,409 --> 00:48:02,789
We want to return the object

1301
00:48:02,789 --> 00:48:04,188
this pointer points to.

1302
00:48:04,188 --> 00:48:05,789
Okay, that would work.

1303
00:48:05,789 --> 00:48:08,009
It's a bit inefficient,

1304
00:48:08,009 --> 00:48:09,869
and it will always be a bit

1305
00:48:09,869 --> 00:48:11,568
inefficient for almost any type

1306
00:48:11,568 --> 00:48:12,208
you do this for.

1307
00:48:12,208 --> 00:48:14,309
So let's see where the inefficiency is.

1308
00:48:14,309 --> 00:48:17,610
The problem is, we're returning a value.

1309
00:48:17,610 --> 00:48:20,349
We're returning a brand new string,

1310
00:48:20,349 --> 00:48:23,168
a copy of star this.

1311
00:48:23,168 --> 00:48:26,088
So when a function returns a value,

1312
00:48:26,088 --> 00:48:27,750
it's going to return

1313
00:48:27,750 --> 00:48:29,409
a temporary object that's

1314
00:48:29,409 --> 00:48:31,530
a copy of your return expression.

1315
00:48:31,530 --> 00:48:34,909
So return star this is going to say,

1316
00:48:34,909 --> 00:48:36,849
Okay, take the left hand side,

1317
00:48:36,849 --> 00:48:39,268
which in our case is U and

1318
00:48:39,268 --> 00:48:40,869
make a copy of it to return to

1319
00:48:40,869 --> 00:48:43,909
the caller so that in an expression

1320
00:48:43,909 --> 00:48:47,469
like V gets the result of U gets S,

1321
00:48:47,469 --> 00:48:49,608
we assign S over to U,

1322
00:48:49,608 --> 00:48:51,690
and then we would be returning

1323
00:48:51,690 --> 00:48:54,329
a copy of the new value of U,

1324
00:48:54,329 --> 00:48:57,244
a copy of you as

1325
00:48:57,244 --> 00:48:59,898
the argument to the

1326
00:48:59,898 --> 00:49:02,039
assignment operator for V. In other words,

1327
00:49:02,039 --> 00:49:03,898
this thing means take V,

1328
00:49:03,898 --> 00:49:07,438
call the operator equal function on U gets S,

1329
00:49:07,438 --> 00:49:10,480
but gets S means,

1330
00:49:10,480 --> 00:49:13,099
call the operator equal function on

1331
00:49:13,099 --> 00:49:16,278
S. Assigning S to U

1332
00:49:16,278 --> 00:49:17,778
and then assigning the result to V

1333
00:49:17,778 --> 00:49:19,858
is really just two function calls.

1334
00:49:19,858 --> 00:49:22,599
Call the member function operator equal on U,

1335
00:49:22,599 --> 00:49:24,298
passing it S and

1336
00:49:24,298 --> 00:49:26,898
then call the operator equal function on V,

1337
00:49:26,898 --> 00:49:30,103
passing it the result of this first call.

1338
00:49:30,103 --> 00:49:33,648
So if the results of this first call is

1339
00:49:33,648 --> 00:49:37,168
a copy of the new value of you.

1340
00:49:37,168 --> 00:49:38,309
It's a copy of you,

1341
00:49:38,309 --> 00:49:41,268
then that's going to be used.

1342
00:49:41,550 --> 00:49:43,768
The copy of is going to be

1343
00:49:43,768 --> 00:49:45,949
used as the argument

1344
00:49:45,949 --> 00:49:47,769
to V's assignment operator.

1345
00:49:47,769 --> 00:49:49,789
And basically, what we did was we

1346
00:49:49,789 --> 00:49:53,068
took the already existing object, right?

1347
00:49:53,068 --> 00:49:54,469
The already existing object

1348
00:49:54,469 --> 00:49:55,610
that this pointer pointed

1349
00:49:55,610 --> 00:49:57,309
to and made a copy of

1350
00:49:57,309 --> 00:49:59,989
it for V to assign from.

1351
00:49:59,989 --> 00:50:01,548
Well, why not just let V

1352
00:50:01,548 --> 00:50:03,250
assign from directly?

1353
00:50:03,250 --> 00:50:05,048
Well, how do we do that?

1354
00:50:05,048 --> 00:50:06,469
How do we make this function,

1355
00:50:06,469 --> 00:50:08,628
not return a copy of

1356
00:50:08,628 --> 00:50:13,338
you but you itself, another name for you.

1357
00:50:13,338 --> 00:50:15,278
Oh, another name for you.

1358
00:50:15,278 --> 00:50:16,679
That's what a reference is.

1359
00:50:16,679 --> 00:50:20,338
So the convention is you have

1360
00:50:20,338 --> 00:50:22,599
the assignment operator return

1361
00:50:22,599 --> 00:50:24,498
a reference to and

1362
00:50:24,498 --> 00:50:27,219
now that's the conventional way to write it.

1363
00:50:27,219 --> 00:50:29,780
You have the assignment operator return

1364
00:50:29,780 --> 00:50:32,860
a reference to the left hand side object.

1365
00:50:32,860 --> 00:50:34,759
So returning Star this says,

1366
00:50:34,759 --> 00:50:36,778
return the object to this pointer

1367
00:50:36,778 --> 00:50:39,199
we're not going to return a copy of it.

1368
00:50:39,199 --> 00:50:40,998
We're going to return another name for it.

1369
00:50:40,998 --> 00:50:42,259
We're going to return a reference to it.

1370
00:50:42,259 --> 00:50:43,639
We don't make a copy of it.

1371
00:50:43,639 --> 00:50:46,018
We'll just return another name for it,

1372
00:50:46,018 --> 00:50:49,059
which will be immediately then passed

1373
00:50:49,059 --> 00:50:52,619
over to the assignment operator here,

1374
00:50:52,619 --> 00:50:55,260
which will have RHS

1375
00:50:55,260 --> 00:50:58,458
be another name for this other name for you.

1376
00:50:58,458 --> 00:51:00,228
It's another name for you.

1377
00:51:00,228 --> 00:51:02,639
So no copy of you is being made.

1378
00:51:02,639 --> 00:51:04,418
A reference to you is being passed from

1379
00:51:04,418 --> 00:51:06,500
the assignment operator back to the caller,

1380
00:51:06,500 --> 00:51:08,219
which is then immediately being passed

1381
00:51:08,219 --> 00:51:09,739
over to the second call

1382
00:51:09,739 --> 00:51:11,179
of operator equal over here.

1383
00:51:11,179 --> 00:51:11,739
Again,

1384
00:51:11,739 --> 00:51:13,719
don't worry so much about the detail there.

1385
00:51:13,719 --> 00:51:15,998
Just remember the convention is

1386
00:51:15,998 --> 00:51:18,199
the assignment operator returns

1387
00:51:18,199 --> 00:51:19,659
a reference to the

1388
00:51:19,659 --> 00:51:21,039
kind of thing you're assigning to,

1389
00:51:21,039 --> 00:51:22,500
and the assignment

1390
00:51:22,500 --> 00:51:24,559
operators the last statement

1391
00:51:24,559 --> 00:51:26,318
the assignment operator should execute should

1392
00:51:26,318 --> 00:51:28,759
be a return of star this,

1393
00:51:28,759 --> 00:51:31,108
a return on the left hand side.

1394
00:51:31,108 --> 00:51:34,079
Okay, so that we

1395
00:51:34,079 --> 00:51:36,860
think is something that works.

1396
00:51:36,860 --> 00:51:38,898
I'm still leaving up the not quite

1397
00:51:38,898 --> 00:51:41,079
right because it's still not quite right.

1398
00:51:41,079 --> 00:51:44,400
But it looks like it works.

1399
00:51:44,400 --> 00:51:47,298
It cleans up the left hand side,

1400
00:51:47,298 --> 00:51:50,898
and then makes the left hand side

1401
00:51:50,898 --> 00:51:53,184
look like a copy of the right hand side.

1402
00:51:53,184 --> 00:51:56,028
And then by convention, return star this.

1403
00:51:56,028 --> 00:51:58,208
So what's wrong there?

1404
00:51:58,208 --> 00:52:00,329
Isn't that what should happen?

1405
00:52:00,329 --> 00:52:01,409
Well, let's see.

1406
00:52:01,409 --> 00:52:03,469
What that code does in

1407
00:52:03,469 --> 00:52:06,309
the context of the call of Gs S,

1408
00:52:06,309 --> 00:52:08,068
this pointer points to U

1409
00:52:08,068 --> 00:52:09,748
and RHS is another name for

1410
00:52:09,748 --> 00:52:12,030
S. So it deletes

1411
00:52:12,030 --> 00:52:14,889
the mtext of the left hand side object,

1412
00:52:14,889 --> 00:52:16,628
then it brings over the length,

1413
00:52:16,628 --> 00:52:18,150
then it dynamically allocates

1414
00:52:18,150 --> 00:52:19,489
a new array at the right

1415
00:52:19,489 --> 00:52:21,088
of this length plus one

1416
00:52:21,088 --> 00:52:22,969
and stores a pointer in here,

1417
00:52:22,969 --> 00:52:25,228
so the old values gone here,

1418
00:52:25,228 --> 00:52:26,748
and then it copies the text.

1419
00:52:26,748 --> 00:52:28,449
And then it returns a reference to you.

1420
00:52:28,449 --> 00:52:32,454
Okay, that's correct behavior in this case.

1421
00:52:32,454 --> 00:52:34,358
Here's the problem. Let's say

1422
00:52:34,358 --> 00:52:36,260
we have an array of strings.

1423
00:52:36,260 --> 00:52:38,518
So here's some string array,

1424
00:52:38,518 --> 00:52:40,898
and there's a bunch of strings in this array.

1425
00:52:40,898 --> 00:52:43,699
Each one of these is a string object,

1426
00:52:43,699 --> 00:52:45,539
and I have

1427
00:52:45,539 --> 00:52:47,159
some algorithm that's going through

1428
00:52:47,159 --> 00:52:48,920
this array and rearranging

1429
00:52:48,920 --> 00:52:49,958
things and doing all kinds

1430
00:52:49,958 --> 00:52:51,079
of stuff with things.

1431
00:52:51,079 --> 00:52:54,000
And so in this algorithm,

1432
00:52:54,000 --> 00:52:55,179
we're looping around for

1433
00:52:55,179 --> 00:52:56,778
various values of I and J.

1434
00:52:56,778 --> 00:52:59,159
And so if I is this element,

1435
00:52:59,159 --> 00:53:00,539
if I is indicating this element

1436
00:53:00,539 --> 00:53:01,958
and J's indicating that element,

1437
00:53:01,958 --> 00:53:02,938
then this element is going to

1438
00:53:02,938 --> 00:53:04,059
be assigned over to this one.

1439
00:53:04,059 --> 00:53:05,838
And so strings get

1440
00:53:05,838 --> 00:53:06,739
assigned around from

1441
00:53:06,739 --> 00:53:08,599
one array element to another.

1442
00:53:08,599 --> 00:53:13,079
Now, every so often in this algorithm,

1443
00:53:13,079 --> 00:53:16,219
I and J happen to have the same value.

1444
00:53:16,219 --> 00:53:18,539
So we're assigning a string to itself.

1445
00:53:18,539 --> 00:53:20,260
Now, what do you expect

1446
00:53:20,260 --> 00:53:22,900
happens when you assign an object to itself?

1447
00:53:22,900 --> 00:53:24,539
Well, again, you know,

1448
00:53:24,539 --> 00:53:26,579
think about plain old types like integers.

1449
00:53:26,579 --> 00:53:28,978
So I have an integer K with a value three,

1450
00:53:28,978 --> 00:53:32,338
and if I were to ever say K gets K,

1451
00:53:32,338 --> 00:53:33,739
which would be a silly thing to say,

1452
00:53:33,739 --> 00:53:35,018
but if I did,

1453
00:53:35,018 --> 00:53:36,998
maybe less silly would be

1454
00:53:36,998 --> 00:53:39,579
imagine an array of integers and

1455
00:53:39,579 --> 00:53:42,099
AsmI is being assigned AJ for

1456
00:53:42,099 --> 00:53:43,539
various values of I&J and

1457
00:53:43,539 --> 00:53:45,298
every so often, I and J are the same.

1458
00:53:45,298 --> 00:53:47,019
So AsmI gets ASI.

1459
00:53:47,019 --> 00:53:48,318
Anyway, let's just do

1460
00:53:48,318 --> 00:53:49,478
it with simple integer variable

1461
00:53:49,478 --> 00:53:52,329
K. Well, let's see then.

1462
00:53:52,329 --> 00:53:53,768
We take the value of

1463
00:53:53,768 --> 00:53:55,849
the right hand side, which is three.

1464
00:53:55,849 --> 00:53:58,228
We start in K,

1465
00:53:58,228 --> 00:54:00,469
wiping out the old value.

1466
00:54:00,469 --> 00:54:02,650
K is unchanged.

1467
00:54:02,650 --> 00:54:04,650
That's what people expect

1468
00:54:04,650 --> 00:54:05,949
self assignment to do.

1469
00:54:05,949 --> 00:54:08,369
If an object's being assigned to itself,

1470
00:54:08,369 --> 00:54:10,268
for one reason or another,

1471
00:54:10,268 --> 00:54:12,409
usually never is anything as silly

1472
00:54:12,409 --> 00:54:14,969
as this with the same variable on both sides,

1473
00:54:14,969 --> 00:54:16,309
but it happens a lot in

1474
00:54:16,309 --> 00:54:19,148
situations like this where you have

1475
00:54:19,739 --> 00:54:23,338
two expressions that sometimes

1476
00:54:23,338 --> 00:54:25,519
will end up indicating

1477
00:54:25,519 --> 00:54:27,059
actually the same object.

1478
00:54:27,059 --> 00:54:28,840
So when it happens,

1479
00:54:28,840 --> 00:54:31,920
the effect should be like nothing happened.

1480
00:54:31,920 --> 00:54:33,280
I mean, there should be no effect.

1481
00:54:33,280 --> 00:54:35,039
Assigning value an object to

1482
00:54:35,039 --> 00:54:36,599
itself should have no effect.

1483
00:54:36,599 --> 00:54:38,139
That's our goal.

1484
00:54:38,139 --> 00:54:42,539
So let's see what happens with our strings.

1485
00:54:42,539 --> 00:54:44,619
So let's say for example,

1486
00:54:44,619 --> 00:54:47,858
I have some string U and U has the value WOW

1487
00:54:47,858 --> 00:54:51,179
and I for one reason

1488
00:54:51,179 --> 00:54:53,519
or another, assign to itself.

1489
00:54:53,519 --> 00:54:57,748
So you gets. Again, we

1490
00:54:57,748 --> 00:54:58,329
never do it in

1491
00:54:58,329 --> 00:54:59,668
any way that's as silly as that.

1492
00:54:59,668 --> 00:55:01,349
I'd probably be some array of strings,

1493
00:55:01,349 --> 00:55:02,548
and we're assigning an object to it.

1494
00:55:02,548 --> 00:55:03,309
So I'm just using with

1495
00:55:03,309 --> 00:55:05,088
one particular variable here.

1496
00:55:05,088 --> 00:55:06,028
Okay.

1497
00:55:06,028 --> 00:55:09,349
Now remember that means take you and

1498
00:55:09,349 --> 00:55:11,889
call Opera requal with

1499
00:55:11,889 --> 00:55:14,188
the right hand side as an argument.

1500
00:55:14,219 --> 00:55:16,659
Okay, so the left hand side is

1501
00:55:16,659 --> 00:55:19,018
the objects that this pointer points to.

1502
00:55:19,018 --> 00:55:22,378
The right hand side is another name for you.

1503
00:55:22,460 --> 00:55:25,458
So what we have is

1504
00:55:25,458 --> 00:55:27,860
a pointer and a reference

1505
00:55:27,860 --> 00:55:29,960
both indicating the same objects.

1506
00:55:29,960 --> 00:55:31,739
So what does our code do?

1507
00:55:31,739 --> 00:55:35,159
Well, the first thing our code did was

1508
00:55:35,159 --> 00:55:39,489
get rid of the left hand sides old value.

1509
00:55:39,489 --> 00:55:40,989
So delete the text of

1510
00:55:40,989 --> 00:55:42,469
the object that this pointer points to.

1511
00:55:42,469 --> 00:55:44,489
Get rid of the left hand side is old value.

1512
00:55:44,489 --> 00:55:46,449
So call Delete on this pointer,

1513
00:55:46,449 --> 00:55:48,048
and that gets rid of that story.

1514
00:55:48,048 --> 00:55:51,289
Well, you can imagine that nothing

1515
00:55:51,289 --> 00:55:52,648
could work after that

1516
00:55:52,648 --> 00:55:54,748
because we lost the WOW.

1517
00:55:54,748 --> 00:55:55,909
If the whole point of

1518
00:55:55,909 --> 00:55:57,429
self assignment, I'm sorry,

1519
00:55:57,429 --> 00:55:58,309
I the whole result of

1520
00:55:58,309 --> 00:55:59,449
self assignment is supposed

1521
00:55:59,449 --> 00:56:01,909
to be that it looks like nothing changed,

1522
00:56:01,909 --> 00:56:05,148
something changed, we lost that text.

1523
00:56:05,148 --> 00:56:08,208
So so starting off by doing

1524
00:56:08,208 --> 00:56:11,068
the delete square bracket text

1525
00:56:11,068 --> 00:56:13,608
is going to lead us into Trump.

1526
00:56:13,608 --> 00:56:15,548
Now, let's see what we did after that.

1527
00:56:15,548 --> 00:56:16,969
The next statement we did was

1528
00:56:16,969 --> 00:56:18,748
to set the MLM to

1529
00:56:18,748 --> 00:56:20,329
the other guys to the right hand side

1530
00:56:20,329 --> 00:56:22,108
of MM. Oh, I'm sorry.

1531
00:56:22,108 --> 00:56:23,489
I'm sure somebody probably commented

1532
00:56:23,489 --> 00:56:24,929
on this and nobody told me.

1533
00:56:24,929 --> 00:56:28,068
I'm sorry. My parameters called RHS.

1534
00:56:28,068 --> 00:56:32,248
So, this should be RHS.

1535
00:56:32,539 --> 00:56:36,139
And this thing here should be RHS.

1536
00:56:36,139 --> 00:56:38,199
I copied and pasted and forgot

1537
00:56:38,199 --> 00:56:38,898
that I used

1538
00:56:38,898 --> 00:56:40,478
a different name for the variable.

1539
00:56:40,478 --> 00:56:42,559
So we assigned over the length,

1540
00:56:42,559 --> 00:56:43,759
so we'll take the right hand

1541
00:56:43,759 --> 00:56:45,579
side length, which is three,

1542
00:56:45,579 --> 00:56:48,039
store it in the len member

1543
00:56:48,039 --> 00:56:50,659
of the object that this pointer points to,

1544
00:56:50,659 --> 00:56:52,338
which is right here.

1545
00:56:52,338 --> 00:56:54,599
So we pick up three and store it back there.

1546
00:56:54,599 --> 00:56:57,259
Okay. That's harmless.

1547
00:56:57,259 --> 00:57:00,298
Then we set text

1548
00:57:00,298 --> 00:57:02,179
to a new array

1549
00:57:02,179 --> 00:57:04,079
of the appropriate number of characters.

1550
00:57:04,079 --> 00:57:06,478
Three plus one is four. So a brand new array

1551
00:57:06,478 --> 00:57:08,219
of four characters is allocated,

1552
00:57:08,219 --> 00:57:10,978
and we set this pointer to point to it.

1553
00:57:11,480 --> 00:57:12,679
Now,

1554
00:57:12,679 --> 00:57:14,159
these are uninitialized characters,

1555
00:57:14,159 --> 00:57:14,818
of course.

1556
00:57:14,818 --> 00:57:17,938
Then we did stir copy to

1557
00:57:17,938 --> 00:57:22,518
text of the right hand sides text.

1558
00:57:22,518 --> 00:57:24,798
Well, the right hand sides text

1559
00:57:24,798 --> 00:57:27,139
is this array.

1560
00:57:27,139 --> 00:57:30,358
And the left hand side text sorry,

1561
00:57:30,358 --> 00:57:32,818
and then Mtext is also that array.

1562
00:57:32,818 --> 00:57:35,059
Basically, we're string copying

1563
00:57:35,059 --> 00:57:37,985
this array into itself.

1564
00:57:37,985 --> 00:57:41,148
And that's going to be undefined behavior.

1565
00:57:41,148 --> 00:57:43,829
What's likeliest to happen

1566
00:57:43,829 --> 00:57:47,489
is your runtime system will simply say,

1567
00:57:47,489 --> 00:57:49,409
Okay, tell me where to copy from.

1568
00:57:49,409 --> 00:57:51,289
Tell me where to copy to, and I'll just copy

1569
00:57:51,289 --> 00:57:53,728
bytes until I copy a zero byte.

1570
00:57:53,728 --> 00:57:56,148
So what it will probably do is say,

1571
00:57:56,148 --> 00:58:00,340
Okay, I will copy

1572
00:58:00,340 --> 00:58:02,619
this bite into

1573
00:58:02,619 --> 00:58:04,619
the destination, which is the same place.

1574
00:58:04,619 --> 00:58:06,358
I'll copy this bite to itself,

1575
00:58:06,358 --> 00:58:08,579
and I'll stop if it's the zero byte.

1576
00:58:08,579 --> 00:58:10,639
If not, I'll go on to the next one and

1577
00:58:10,639 --> 00:58:11,559
copy it to itself and

1578
00:58:11,559 --> 00:58:12,878
stop if it's the zero byte,

1579
00:58:12,878 --> 00:58:14,278
then this one, then this one.

1580
00:58:14,278 --> 00:58:15,599
And I'll keep on going until I

1581
00:58:15,599 --> 00:58:17,398
happen to pick up and store a zero byte.

1582
00:58:17,398 --> 00:58:18,798
Maybe that'll happen in here.

1583
00:58:18,798 --> 00:58:20,539
Maybe that'll happen out of bounds with

1584
00:58:20,539 --> 00:58:22,119
the array because we

1585
00:58:22,119 --> 00:58:23,719
don't know what's in the storage here.

1586
00:58:23,719 --> 00:58:26,224
It's definitely undefined behavior.

1587
00:58:26,224 --> 00:58:29,048
It's not likely to crash.

1588
00:58:29,048 --> 00:58:31,128
It'll probably just pick up and

1589
00:58:31,128 --> 00:58:32,708
store bytes here and

1590
00:58:32,708 --> 00:58:33,748
run off the end of the array,

1591
00:58:33,748 --> 00:58:35,110
but keep on going until it happens

1592
00:58:35,110 --> 00:58:36,849
to come to a zero byte and store it.

1593
00:58:36,849 --> 00:58:40,369
So the assignment operator will probably not

1594
00:58:40,369 --> 00:58:41,909
crash and probably not

1595
00:58:41,909 --> 00:58:44,349
probably will return, okay.

1596
00:58:44,349 --> 00:58:46,849
But we're left in this weird state

1597
00:58:46,849 --> 00:58:50,068
where the old value of you was Wow.

1598
00:58:50,068 --> 00:58:51,909
Now it's not WOW and

1599
00:58:51,909 --> 00:58:53,568
that's not a valid C string.

1600
00:58:53,568 --> 00:58:55,409
And so, yeah, bad things

1601
00:58:55,409 --> 00:58:57,534
are going to happen surely from here on.

1602
00:58:57,534 --> 00:58:59,139
So we totally have

1603
00:58:59,139 --> 00:59:00,659
to prevent this from happening.

1604
00:59:00,659 --> 00:59:02,998
And let's see how we can do that.

1605
00:59:02,998 --> 00:59:04,998
So again, the original situation

1606
00:59:04,998 --> 00:59:07,260
was we had our Wow,

1607
00:59:07,260 --> 00:59:11,099
and we went wrong right away.

1608
00:59:11,099 --> 00:59:12,458
I mean, what's going to lead to trouble

1609
00:59:12,458 --> 00:59:14,938
right away is getting rid of the Wow.

1610
00:59:15,179 --> 00:59:19,228
And so, but

1611
00:59:19,228 --> 00:59:20,688
that's what we normally want to do,

1612
00:59:20,688 --> 00:59:22,969
except when

1613
00:59:22,969 --> 00:59:24,929
the objects being assigned to itself,

1614
00:59:24,929 --> 00:59:27,469
when an object is being assigned to itself,

1615
00:59:27,469 --> 00:59:30,409
we want to do one thing, and otherwise,

1616
00:59:30,409 --> 00:59:32,289
this code could work okay.

1617
00:59:32,289 --> 00:59:34,248
So we need to test for that.

1618
00:59:34,248 --> 00:59:35,309
And if we're going to

1619
00:59:35,309 --> 00:59:36,228
test for that, we discover

1620
00:59:36,228 --> 00:59:38,949
the object is going to be assigned to itself.

1621
00:59:38,949 --> 00:59:40,989
Well, then let's just return

1622
00:59:40,989 --> 00:59:42,568
immediately because it already

1623
00:59:42,568 --> 00:59:44,409
has the value we want to we

1624
00:59:44,409 --> 00:59:46,268
want it to end up having.

1625
00:59:46,268 --> 00:59:50,030
So the patterns going to be the object

1626
00:59:50,030 --> 00:59:51,389
if the left hand side object is

1627
00:59:51,389 --> 00:59:52,148
the same object as

1628
00:59:52,148 --> 00:59:53,509
the right hand side object,

1629
00:59:53,509 --> 00:59:57,143
then we can just return immediately.

1630
00:59:57,143 --> 00:59:58,478
Okay.

1631
00:59:58,478 --> 00:59:59,898
Okay. Let's try that.

1632
00:59:59,898 --> 01:00:03,759
So, now, how do I tell

1633
01:00:03,759 --> 01:00:05,059
if the left hand side object is

1634
01:00:05,059 --> 01:00:07,818
the right hand side object? Well, let's see.

1635
01:00:07,818 --> 01:00:13,369
Uh, The left hand

1636
01:00:13,369 --> 01:00:15,028
side object, the right hand side object.

1637
01:00:15,028 --> 01:00:17,309
So the right hand side object.

1638
01:00:20,389 --> 01:00:26,588
Well, Can I say that?

1639
01:00:26,588 --> 01:00:28,809
Well, that's not quite right because

1640
01:00:28,809 --> 01:00:31,028
this is a pointer to a string,

1641
01:00:31,028 --> 01:00:32,489
and that's a string,

1642
01:00:32,489 --> 01:00:34,208
and that's another name for a string.

1643
01:00:34,208 --> 01:00:35,528
The types aren't right.

1644
01:00:35,528 --> 01:00:36,909
That's a pointer to a string,

1645
01:00:36,909 --> 01:00:38,748
and that's a string.

1646
01:00:39,829 --> 01:00:42,429
Okay, so what I really want to say, Well,

1647
01:00:42,429 --> 01:00:43,588
how do I know if

1648
01:00:43,588 --> 01:00:47,333
the two strings are so this is not right.

1649
01:00:47,333 --> 01:00:50,918
Not quite right. How do

1650
01:00:50,918 --> 01:00:52,360
I know if these two strings

1651
01:00:52,360 --> 01:00:53,918
are really the same string?

1652
01:00:53,918 --> 01:00:55,079
Well, let's see.

1653
01:00:55,079 --> 01:00:56,938
If there are two strings,

1654
01:00:56,938 --> 01:00:59,039
it's like that, if

1655
01:00:59,039 --> 01:01:00,739
the left hand side is the same strength,

1656
01:01:00,739 --> 01:01:02,739
the same string, it looks like that.

1657
01:01:02,739 --> 01:01:05,179
If they're in the same place,

1658
01:01:05,179 --> 01:01:09,443
they must be the same string. Um,

1659
01:01:09,443 --> 01:01:11,829
Oh, okay. So let's look

1660
01:01:11,829 --> 01:01:13,909
at where they are. That's their address.

1661
01:01:13,909 --> 01:01:15,289
Oh, okay.

1662
01:01:15,289 --> 01:01:18,188
So if the address

1663
01:01:18,188 --> 01:01:20,088
of the left hand side string is this,

1664
01:01:20,088 --> 01:01:21,969
the address of the right hand string

1665
01:01:21,969 --> 01:01:25,610
is Ampersand RHS.

1666
01:01:25,929 --> 01:01:28,148
So that's how you ask if

1667
01:01:28,148 --> 01:01:30,628
the two strings are the same string.

1668
01:01:30,628 --> 01:01:33,028
If this pointer is

1669
01:01:33,028 --> 01:01:34,730
the same value as that pointer,

1670
01:01:34,730 --> 01:01:36,509
Ampersand or RHS would be

1671
01:01:36,509 --> 01:01:38,748
a pointer to this string here.

1672
01:01:38,748 --> 01:01:40,309
Are these pointer values the same?

1673
01:01:40,309 --> 01:01:42,523
Yeah, because they point to the same ojle.

1674
01:01:42,523 --> 01:01:45,338
Okay. So that'll work.

1675
01:01:45,338 --> 01:01:47,099
So all I have to do

1676
01:01:47,099 --> 01:01:53,259
here to make this at least correctly,

1677
01:01:53,259 --> 01:01:56,393
would be something like that.

1678
01:01:56,393 --> 01:01:58,469
I will now change my comment too.

1679
01:01:58,469 --> 01:02:00,608
This is now not the modern way to do it.

1680
01:02:00,608 --> 01:02:03,489
So this is an implementation

1681
01:02:03,489 --> 01:02:05,748
that will do the job,

1682
01:02:05,748 --> 01:02:07,268
but it's not the modern way to write it,

1683
01:02:07,268 --> 01:02:09,188
but I'll get to that in a second.

1684
01:02:09,188 --> 01:02:13,548
So the idea here is that, all right,

1685
01:02:13,548 --> 01:02:16,188
if the objects are not the same object,

1686
01:02:16,188 --> 01:02:17,068
then we have to do

1687
01:02:17,068 --> 01:02:18,369
the work that we did before.

1688
01:02:18,369 --> 01:02:20,489
If they are the same object,

1689
01:02:20,489 --> 01:02:22,188
then we skip all that.

1690
01:02:22,188 --> 01:02:25,268
And in all cases, we return Star T.

1691
01:02:27,590 --> 01:02:29,148
Okay.

1692
01:02:29,148 --> 01:02:32,068
So this is the way that

1693
01:02:32,068 --> 01:02:34,309
the assignment operator is

1694
01:02:34,309 --> 01:02:35,809
sort of the classic model for

1695
01:02:35,809 --> 01:02:37,250
how to write an assignment operator.

1696
01:02:37,250 --> 01:02:38,628
If you look at any C plus

1697
01:02:38,628 --> 01:02:41,909
plus text written before,

1698
01:02:41,949 --> 01:02:48,199
say, about 2000 2001, 2002.

1699
01:02:48,480 --> 01:02:51,139
And you still see it sometimes

1700
01:02:51,139 --> 01:02:54,039
in older C plus plus tutorials.

1701
01:02:54,039 --> 01:02:55,898
They give this is the pattern for

1702
01:02:55,898 --> 01:02:58,639
writing an assignment operator.

1703
01:02:58,639 --> 01:03:01,059
You verify

1704
01:03:01,059 --> 01:03:03,219
that the objects are not the same object.

1705
01:03:03,219 --> 01:03:04,679
If they are the same object,

1706
01:03:04,679 --> 01:03:05,980
you just return immediately.

1707
01:03:05,980 --> 01:03:07,960
But if they aren't the same object,

1708
01:03:07,960 --> 01:03:09,619
you do something to

1709
01:03:09,619 --> 01:03:11,418
clean up the left hand side.

1710
01:03:11,418 --> 01:03:13,099
In our case, it was to get rid of

1711
01:03:13,099 --> 01:03:15,039
the dynamically allocated text,

1712
01:03:15,039 --> 01:03:16,938
and then you do something to make

1713
01:03:16,938 --> 01:03:18,099
the left hand side look like

1714
01:03:18,099 --> 01:03:19,978
a copy of the right hand side.

1715
01:03:19,978 --> 01:03:22,559
So that was the classic model

1716
01:03:22,559 --> 01:03:24,920
for how to write an assignment operator.

1717
01:03:24,920 --> 01:03:27,278
It has an issue, and

1718
01:03:27,278 --> 01:03:28,498
I'll talk about that in a bit,

1719
01:03:28,498 --> 01:03:30,300
but let me just hit the questions

1720
01:03:30,300 --> 01:03:31,699
that almost always I mean,

1721
01:03:31,699 --> 01:03:32,960
without even looking at the questions,

1722
01:03:32,960 --> 01:03:33,659
I know what some of

1723
01:03:33,659 --> 01:03:35,018
the more common questions here are.

1724
01:03:35,018 --> 01:03:37,938
So let me address those.

1725
01:03:37,938 --> 01:03:40,059
So, again, this is the classic code,

1726
01:03:40,059 --> 01:03:41,139
and here are the kind

1727
01:03:41,139 --> 01:03:42,958
of questions that come up.

1728
01:03:43,360 --> 01:03:46,079
One of them is, well,

1729
01:03:46,079 --> 01:03:47,699
that test to see if

1730
01:03:47,699 --> 01:03:49,639
the strings are different.

1731
01:03:49,639 --> 01:03:52,978
I wrote that test as if this

1732
01:03:52,978 --> 01:03:56,780
is equal not equal to Ampersand RHS.

1733
01:03:56,780 --> 01:04:00,539
If the pointer to the left hand side object

1734
01:04:00,539 --> 01:04:03,679
is pointing to a different place

1735
01:04:03,679 --> 01:04:05,119
than the pointer to

1736
01:04:05,119 --> 01:04:06,260
the right hand side object.

1737
01:04:06,260 --> 01:04:07,460
If they point to different

1738
01:04:07,460 --> 01:04:08,860
places, they're different objects.

1739
01:04:08,860 --> 01:04:10,139
If they point to the same place,

1740
01:04:10,139 --> 01:04:12,059
they're the same object.

1741
01:04:12,059 --> 01:04:16,900
How do I know if the phrase

1742
01:04:17,539 --> 01:04:21,179
the governor of California and the phrase

1743
01:04:21,179 --> 01:04:22,898
Gavin Newsom are

1744
01:04:22,898 --> 01:04:25,039
talking about the same person.

1745
01:04:25,039 --> 01:04:27,278
One way to do it would be,

1746
01:04:27,278 --> 01:04:28,858
I'm going to go find where

1747
01:04:28,858 --> 01:04:31,039
the governor of California is, okay?

1748
01:04:31,039 --> 01:04:32,340
I go up Sacramento

1749
01:04:32,340 --> 01:04:33,858
and look at the state house, okay?

1750
01:04:33,858 --> 01:04:35,518
And there in the governor's office sitting in

1751
01:04:35,518 --> 01:04:38,199
his chair is some person.

1752
01:04:38,199 --> 01:04:40,224
That's the governor of California.

1753
01:04:40,224 --> 01:04:42,710
Now let's see. Where's Gavin Newsom?

1754
01:04:42,710 --> 01:04:44,489
Look around. Hey, where's Gavin Newsom?

1755
01:04:44,489 --> 01:04:45,588
Oh, he's over there.

1756
01:04:45,588 --> 01:04:47,088
Lo and they're sitting in

1757
01:04:47,088 --> 01:04:48,289
the same chair at

1758
01:04:48,289 --> 01:04:50,449
the same time is Gavin Newsom.

1759
01:04:50,449 --> 01:04:53,188
So since the governor of California is there

1760
01:04:53,188 --> 01:04:54,528
and Gavin Newsom is

1761
01:04:54,528 --> 01:04:56,568
there, they are the same person.

1762
01:04:56,568 --> 01:04:58,989
Okay. So that's checking

1763
01:04:58,989 --> 01:05:00,889
this exactly the same object.

1764
01:05:00,889 --> 01:05:05,409
Now, some people say, Well, okay, well,

1765
01:05:05,409 --> 01:05:06,688
how is that different from

1766
01:05:06,688 --> 01:05:10,449
saying if the object that this pointer

1767
01:05:10,449 --> 01:05:13,048
points to is not

1768
01:05:13,048 --> 01:05:16,510
equal to the right hand side object.

1769
01:05:18,309 --> 01:05:21,909
Well, that's asking a different question.

1770
01:05:22,670 --> 01:05:27,568
That's assuming this is a type string,

1771
01:05:27,568 --> 01:05:30,088
and this is a type string

1772
01:05:30,088 --> 01:05:33,469
or this was a type string pointer.

1773
01:05:34,380 --> 01:05:37,940
And this was a type string pointer.

1774
01:05:37,940 --> 01:05:40,018
That's a different question.

1775
01:05:40,018 --> 01:05:41,800
This question is comparing

1776
01:05:41,800 --> 01:05:43,539
two pointers to see if they

1777
01:05:43,539 --> 01:05:45,798
point to a different place or the same place.

1778
01:05:45,798 --> 01:05:47,880
This is comparing two strings,

1779
01:05:47,880 --> 01:05:51,559
and this will not compile unless you have

1780
01:05:51,559 --> 01:05:54,039
defined operator not equal

1781
01:05:54,039 --> 01:05:56,460
to let you compare two string objects.

1782
01:05:56,460 --> 01:05:58,659
This is actually comparing the values of

1783
01:05:58,659 --> 01:06:00,099
the strings if we

1784
01:06:00,099 --> 01:06:02,005
had defined such an operator.

1785
01:06:02,005 --> 01:06:03,208
That would not be

1786
01:06:03,208 --> 01:06:04,228
an unreasonable thing to do,

1787
01:06:04,228 --> 01:06:05,409
by the way, for the string type.

1788
01:06:05,409 --> 01:06:06,789
We could define an operator

1789
01:06:06,789 --> 01:06:07,909
double equal that takes

1790
01:06:07,909 --> 01:06:11,489
two strings and say compares their values.

1791
01:06:11,489 --> 01:06:14,889
The two strings are equal if say, you know,

1792
01:06:14,889 --> 01:06:17,048
their lengths are equal and if they have

1793
01:06:17,048 --> 01:06:18,248
the same characters up

1794
01:06:18,248 --> 01:06:20,068
to and including the zero byte.

1795
01:06:20,068 --> 01:06:21,989
That could be our implementation

1796
01:06:21,989 --> 01:06:23,668
of an operator double equal to string.

1797
01:06:23,668 --> 01:06:25,349
An operator not equal for strings,

1798
01:06:25,349 --> 01:06:26,668
two strings would give

1799
01:06:26,668 --> 01:06:28,190
you the opposite result.

1800
01:06:28,190 --> 01:06:30,668
So if we had such a thing,

1801
01:06:30,668 --> 01:06:33,289
this would compile, but it's not

1802
01:06:33,289 --> 01:06:35,929
testing are the two objects the same object?

1803
01:06:35,929 --> 01:06:37,469
It's saying, you know,

1804
01:06:37,469 --> 01:06:39,208
whether they're the same object or not,

1805
01:06:39,208 --> 01:06:42,195
do the two strings have the same value?

1806
01:06:42,195 --> 01:06:45,159
You might say, well, that's

1807
01:06:45,159 --> 01:06:46,318
not bad because if they

1808
01:06:46,318 --> 01:06:48,139
do have the same value,

1809
01:06:48,139 --> 01:06:49,498
if this is the string

1810
01:06:49,498 --> 01:06:51,278
hello and that's the string hello,

1811
01:06:51,278 --> 01:06:53,199
then there's no reason to actually

1812
01:06:53,199 --> 01:06:55,199
go through the work of doing the assignment.

1813
01:06:55,199 --> 01:06:56,998
You know, why do you need to

1814
01:06:56,998 --> 01:06:58,858
get rid of the old hello here,

1815
01:06:58,858 --> 01:07:00,298
copy over the length five

1816
01:07:00,298 --> 01:07:01,958
to replace this length five,

1817
01:07:01,958 --> 01:07:04,159
allocate a new array of six characters,

1818
01:07:04,159 --> 01:07:06,818
copy hello with a zero byte into there.

1819
01:07:06,818 --> 01:07:09,260
And now this has a pointer

1820
01:07:09,260 --> 01:07:11,818
to hello with the length five,

1821
01:07:11,818 --> 01:07:12,958
just like it was before

1822
01:07:12,958 --> 01:07:14,278
It's just like it was before.

1823
01:07:14,278 --> 01:07:16,358
So you could say,

1824
01:07:16,358 --> 01:07:17,820
if I replace

1825
01:07:17,820 --> 01:07:19,659
this condition with this condition,

1826
01:07:19,659 --> 01:07:21,019
assuming I have defined

1827
01:07:21,019 --> 01:07:22,873
a not equal operator for string,

1828
01:07:22,873 --> 01:07:24,728
this will still be correct code.

1829
01:07:24,728 --> 01:07:26,590
In fact, it will bypass

1830
01:07:26,590 --> 01:07:28,349
this work in more cases.

1831
01:07:28,349 --> 01:07:29,909
It will not only bypass

1832
01:07:29,909 --> 01:07:32,309
the work if two strings the two objects are

1833
01:07:32,309 --> 01:07:34,009
the same object because of course

1834
01:07:34,009 --> 01:07:36,708
they would have the same value,

1835
01:07:36,708 --> 01:07:38,708
but it would also bypass the work if

1836
01:07:38,708 --> 01:07:40,150
two different strings happen

1837
01:07:40,150 --> 01:07:41,548
to have the same value.

1838
01:07:41,548 --> 01:07:43,469
Then there's no reason to do any work

1839
01:07:43,469 --> 01:07:45,228
because this one already

1840
01:07:45,228 --> 01:07:47,608
looks like a copy of that one.

1841
01:07:47,608 --> 01:07:49,469
So you might say, maybe that's

1842
01:07:49,469 --> 01:07:50,369
a better thing because it

1843
01:07:50,369 --> 01:07:52,268
bypasses the work more often.

1844
01:07:52,268 --> 01:07:57,550
I would disagree because the cost of checking

1845
01:07:57,550 --> 01:07:59,048
two strings to see if they have

1846
01:07:59,048 --> 01:08:04,048
the same value is not totally trivial, right?

1847
01:08:04,048 --> 01:08:06,728
If two strings start off the same, you know,

1848
01:08:06,728 --> 01:08:07,648
they have the same length,

1849
01:08:07,648 --> 01:08:08,668
and they start off the same,

1850
01:08:08,668 --> 01:08:10,150
but then they differ somehow.

1851
01:08:10,150 --> 01:08:11,268
Well, you've gone through

1852
01:08:11,268 --> 01:08:12,869
a loop partway through the string to

1853
01:08:12,869 --> 01:08:15,809
check those characters and partway through,

1854
01:08:15,809 --> 01:08:17,668
you said, Oh, okay, they're different.

1855
01:08:17,668 --> 01:08:19,389
So the problem is, you did

1856
01:08:19,389 --> 01:08:21,509
a lot of work to find out, Oh, guess what?

1857
01:08:21,509 --> 01:08:23,009
They are different. And so

1858
01:08:23,009 --> 01:08:24,609
I'll go ahead and do this anyway.

1859
01:08:24,609 --> 01:08:27,378
So so you have to balance,

1860
01:08:27,378 --> 01:08:28,418
how often is it

1861
01:08:28,418 --> 01:08:29,918
the case that the two strings you're

1862
01:08:29,918 --> 01:08:31,179
assigning actually have the same

1863
01:08:31,179 --> 01:08:32,798
value versus,

1864
01:08:32,798 --> 01:08:34,338
you know, you have to balance

1865
01:08:34,338 --> 01:08:35,838
that against the cost of Yeah,

1866
01:08:35,838 --> 01:08:37,019
but how much does it cost to see

1867
01:08:37,019 --> 01:08:38,578
if two strings have the same value?

1868
01:08:38,578 --> 01:08:40,759
If it turns out it's not very common that

1869
01:08:40,759 --> 01:08:41,599
you do assignment with

1870
01:08:41,599 --> 01:08:43,418
two strings having the same value.

1871
01:08:43,418 --> 01:08:44,998
And you figure out the cost of

1872
01:08:44,998 --> 01:08:46,679
this work and how frequently that occurs,

1873
01:08:46,679 --> 01:08:50,069
you may find it's not worth that check.

1874
01:08:50,069 --> 01:08:51,828
It's not worth the check to see if

1875
01:08:51,828 --> 01:08:53,588
two strings have the same value so

1876
01:08:53,588 --> 01:08:55,208
that you could bypass this work

1877
01:08:55,208 --> 01:08:57,748
even if they were in different places.

1878
01:08:57,748 --> 01:09:00,529
Simply because that doesn't

1879
01:09:00,529 --> 01:09:02,069
happen often enough to make the cost

1880
01:09:02,069 --> 01:09:03,208
of doing that check every

1881
01:09:03,208 --> 01:09:06,128
time you assign two strings worthwhile.

1882
01:09:06,128 --> 01:09:09,128
So generally, we'll leave it this way.

1883
01:09:09,128 --> 01:09:11,429
We'll compare the pointers,

1884
01:09:12,630 --> 01:09:18,349
not the actual values of the string. Okay.

1885
01:09:18,349 --> 01:09:20,349
Another common thing people

1886
01:09:20,349 --> 01:09:22,408
wonder about is, Hey, you know,

1887
01:09:22,408 --> 01:09:28,208
I noticed that the the body

1888
01:09:28,208 --> 01:09:30,609
of this if statement is,

1889
01:09:30,609 --> 01:09:32,948
do what the destructor does,

1890
01:09:32,948 --> 01:09:34,689
followed by do what

1891
01:09:34,689 --> 01:09:36,668
the copy constructor does.

1892
01:09:36,668 --> 01:09:40,088
So could I somehow

1893
01:09:40,088 --> 01:09:41,748
in my implementation of

1894
01:09:41,748 --> 01:09:43,849
the assignment operator, you know,

1895
01:09:43,849 --> 01:09:46,368
call the destructor for the left hand side,

1896
01:09:46,368 --> 01:09:48,189
and then call the copy constructor

1897
01:09:48,189 --> 01:09:50,448
somehow to make the left hand side

1898
01:09:50,448 --> 01:09:52,788
look like a copy of the right hand side?

1899
01:09:52,788 --> 01:09:59,988
And the answer is technically, yes,

1900
01:09:59,988 --> 01:10:02,048
you could do that,

1901
01:10:02,048 --> 01:10:08,048
but have to do it exactly the right way,

1902
01:10:08,048 --> 01:10:09,368
and the way people think of

1903
01:10:09,368 --> 01:10:10,948
doing it is not the right way.

1904
01:10:10,948 --> 01:10:14,009
In other words, there are

1905
01:10:14,009 --> 01:10:16,769
language constructs in C plus plus you would

1906
01:10:16,769 --> 01:10:19,389
have to use to do this. We don't know them.

1907
01:10:19,389 --> 01:10:23,488
And so if you tried to do this way,

1908
01:10:23,488 --> 01:10:25,208
tried to do it that way, you

1909
01:10:25,208 --> 01:10:26,448
would probably get it wrong.

1910
01:10:26,448 --> 01:10:27,288
You might be able to

1911
01:10:27,288 --> 01:10:28,649
write something that compiles,

1912
01:10:28,649 --> 01:10:30,908
but it would not do the right thing.

1913
01:10:30,908 --> 01:10:32,908
The most common thing people try

1914
01:10:32,908 --> 01:10:34,248
to do is somehow, Oh,

1915
01:10:34,248 --> 01:10:35,389
I'm going to call the copy

1916
01:10:35,389 --> 01:10:36,809
instructor just by saying,

1917
01:10:36,809 --> 01:10:40,429
you know, string, open friend, whatever.

1918
01:10:40,429 --> 01:10:43,469
No, no, that's not going to work.

1919
01:10:43,469 --> 01:10:44,429
You

1920
01:10:44,429 --> 01:10:47,399
would constructing a temporary object that

1921
01:10:47,399 --> 01:10:48,819
gets immediately destroyed and having

1922
01:10:48,819 --> 01:10:49,779
no effect on the object

1923
01:10:49,779 --> 01:10:50,979
that this pointer points to.

1924
01:10:50,979 --> 01:10:52,779
So really,

1925
01:10:52,779 --> 01:10:54,418
the way you might try to

1926
01:10:54,418 --> 01:10:56,139
do this is not going to work.

1927
01:10:56,139 --> 01:10:59,359
So don't bother trying to

1928
01:10:59,359 --> 01:11:00,998
implement the assignment operator

1929
01:11:00,998 --> 01:11:03,059
by calling the copy constructor.

1930
01:11:03,059 --> 01:11:08,099
That's wrong. Calling the copy instructor

1931
01:11:08,099 --> 01:11:09,618
to directly do something to

1932
01:11:09,618 --> 01:11:11,519
the left hand side object.

1933
01:11:11,519 --> 01:11:14,238
That's not going to work out, right.

1934
01:11:14,720 --> 01:11:16,939
Oh, well, but I

1935
01:11:16,939 --> 01:11:17,679
don't like the fact

1936
01:11:17,679 --> 01:11:18,618
that the code is the same.

1937
01:11:18,618 --> 01:11:19,319
Do I have to write

1938
01:11:19,319 --> 01:11:21,219
the same code in two places?

1939
01:11:21,219 --> 01:11:23,878
No. I mean, one way, again,

1940
01:11:23,878 --> 01:11:25,319
an old classic way was,

1941
01:11:25,319 --> 01:11:26,338
well, maybe you have

1942
01:11:26,338 --> 01:11:27,798
a private helper function.

1943
01:11:27,798 --> 01:11:29,979
Maybe you have a private member function that

1944
01:11:29,979 --> 01:11:31,298
both the copy constructor

1945
01:11:31,298 --> 01:11:32,918
and the assignment operator call

1946
01:11:32,918 --> 01:11:35,198
and the private function does

1947
01:11:35,198 --> 01:11:39,439
this dirty work. That could work.

1948
01:11:39,489 --> 01:11:42,269
But the modern way is

1949
01:11:42,269 --> 01:11:44,868
actually solving another problem,

1950
01:11:44,868 --> 01:11:47,229
which unfortunately we don't

1951
01:11:47,229 --> 01:11:48,149
know enough to know

1952
01:11:48,149 --> 01:11:49,250
the implications

1953
01:11:49,250 --> 01:11:53,149
of the classical way of doing it.

1954
01:11:53,149 --> 01:11:56,469
But let me just briefly mention it.

1955
01:11:56,469 --> 01:11:58,189
So one of

1956
01:11:58,189 --> 01:12:00,048
the problems with the assignment operator,

1957
01:12:00,048 --> 01:12:01,149
one of the problems with

1958
01:12:01,149 --> 01:12:02,469
both the copy constructor

1959
01:12:02,469 --> 01:12:05,509
and the assignment operator is at some point,

1960
01:12:05,509 --> 01:12:09,639
we dynamically allocate some new storage.

1961
01:12:09,639 --> 01:12:11,408
What if that fails?

1962
01:12:11,408 --> 01:12:12,828
What if there's not enough

1963
01:12:12,828 --> 01:12:14,088
memory to make a copy

1964
01:12:14,088 --> 01:12:17,668
of the right hand side for the new object?

1965
01:12:17,670 --> 01:12:20,868
Well, then an exception is thrown.

1966
01:12:20,868 --> 01:12:23,729
Okay, now, we don't

1967
01:12:23,729 --> 01:12:25,328
know how to deal with exceptions,

1968
01:12:25,328 --> 01:12:26,649
so this is not going to be something

1969
01:12:26,649 --> 01:12:28,389
that we'd have to face.

1970
01:12:28,389 --> 01:12:30,769
But there are programs

1971
01:12:30,769 --> 01:12:34,309
that do know how to deal with exceptions,

1972
01:12:34,309 --> 01:12:36,069
and they might discover, Oh,

1973
01:12:36,069 --> 01:12:37,809
if an exception was thrown we tried

1974
01:12:37,809 --> 01:12:38,569
to do something because

1975
01:12:38,569 --> 01:12:39,908
there was limited memory,

1976
01:12:39,908 --> 01:12:41,889
maybe we could do something to clean

1977
01:12:41,889 --> 01:12:44,988
up memory and try the operation again.

1978
01:12:45,800 --> 01:12:48,979
But for that to work right, you'd

1979
01:12:48,979 --> 01:12:50,599
really like it to be the case

1980
01:12:50,599 --> 01:12:54,189
that if some operation like

1981
01:12:54,189 --> 01:12:56,128
your assignment operator or cop constructor

1982
01:12:56,128 --> 01:12:58,548
fails and throws an exception,

1983
01:12:58,548 --> 01:13:02,889
ideally, it should leave

1984
01:13:02,889 --> 01:13:05,208
all the variables that you will

1985
01:13:05,208 --> 01:13:06,948
still exist after the function

1986
01:13:06,948 --> 01:13:08,448
leaves from the exception,

1987
01:13:08,448 --> 01:13:10,828
leave all those variables unchanged,

1988
01:13:10,828 --> 01:13:12,969
or at least, in a valid state.

1989
01:13:12,969 --> 01:13:14,408
And with this implementation

1990
01:13:14,408 --> 01:13:15,689
of the assignment operator,

1991
01:13:15,689 --> 01:13:17,689
that's not going to happen.

1992
01:13:17,689 --> 01:13:20,529
So very briefly because

1993
01:13:20,529 --> 01:13:21,889
it's not really within

1994
01:13:21,889 --> 01:13:23,328
the scope of the class,

1995
01:13:23,328 --> 01:13:26,849
the issue is, if and I said,

1996
01:13:26,849 --> 01:13:31,689
UGS, And so we tried this,

1997
01:13:31,689 --> 01:13:32,889
and if we were to

1998
01:13:32,889 --> 01:13:34,048
go through this code here, we'd say,

1999
01:13:34,048 --> 01:13:35,288
well, let's see, the

2000
01:13:35,288 --> 01:13:36,689
objects have different objects.

2001
01:13:36,689 --> 01:13:38,828
So let's delete the old value of

2002
01:13:38,828 --> 01:13:44,849
you Let's assign over the five to here.

2003
01:13:45,409 --> 01:13:48,849
So use length is now five.

2004
01:13:48,970 --> 01:13:52,009
Let's now give you its own text.

2005
01:13:52,009 --> 01:13:53,769
So let's dynamically allocate an array of

2006
01:13:53,769 --> 01:13:56,088
six characters. Let's say that fails.

2007
01:13:56,088 --> 01:13:58,109
There's not enough memory.

2008
01:13:58,109 --> 01:13:59,248
I mean, there could be

2009
01:13:59,248 --> 01:14:00,628
plenty for other types,

2010
01:14:00,628 --> 01:14:01,769
there could be plenty of other reasons

2011
01:14:01,769 --> 01:14:03,128
why somebody could throw an exception.

2012
01:14:03,128 --> 01:14:03,988
Ours is going to be

2013
01:14:03,988 --> 01:14:05,609
running out of memory here.

2014
01:14:05,609 --> 01:14:07,288
We run out of memory,

2015
01:14:07,288 --> 01:14:09,229
so an exception is thrown.

2016
01:14:09,229 --> 01:14:12,770
Now, what that does is it says, essentially,

2017
01:14:12,770 --> 01:14:14,609
further execution of the assignment

2018
01:14:14,609 --> 01:14:16,949
operator code is abandoned,

2019
01:14:16,949 --> 01:14:18,828
and the exception comes back

2020
01:14:18,828 --> 01:14:21,838
up to this level of code,

2021
01:14:21,838 --> 01:14:23,038
and maybe this level of

2022
01:14:23,038 --> 01:14:24,279
code will catch it or deal with it.

2023
01:14:24,279 --> 01:14:26,179
If not, send it up to something higher.

2024
01:14:26,179 --> 01:14:27,578
But anyway, when we come

2025
01:14:27,578 --> 01:14:29,878
back up to this level of code,

2026
01:14:30,000 --> 01:14:33,698
look what happens. Look what we've got.

2027
01:14:33,698 --> 01:14:35,679
We've got a variable U,

2028
01:14:35,679 --> 01:14:37,798
remember, U was declared here.

2029
01:14:37,798 --> 01:14:42,179
We've got a variable U, a string variable,

2030
01:14:42,179 --> 01:14:44,618
but its value is bizarre.

2031
01:14:44,618 --> 01:14:46,578
U has a dangling pointer here.

2032
01:14:46,578 --> 01:14:49,259
And the problem is, for example,

2033
01:14:49,259 --> 01:14:51,038
if this code doesn't

2034
01:14:51,038 --> 01:14:52,859
handle the exception either,

2035
01:14:52,859 --> 01:14:54,559
and so the exception has to go

2036
01:14:54,559 --> 01:14:56,673
up to some higher level code,

2037
01:14:56,673 --> 01:14:58,389
local variables

2038
01:14:58,389 --> 01:14:59,729
still have their destructors call.

2039
01:14:59,729 --> 01:15:00,828
As an exception, it's going to

2040
01:15:00,828 --> 01:15:02,029
be passed up to a higher level,

2041
01:15:02,029 --> 01:15:04,269
local variables have their destructors call.

2042
01:15:04,269 --> 01:15:05,929
When the destructor for you is

2043
01:15:05,929 --> 01:15:07,889
called on this dangling pointer,

2044
01:15:07,889 --> 01:15:09,189
undefined behavior,

2045
01:15:09,189 --> 01:15:11,128
our program probably crashes.

2046
01:15:11,128 --> 01:15:14,909
So the problem is this implementation

2047
01:15:14,909 --> 01:15:17,628
of the assignment operator makes

2048
01:15:17,628 --> 01:15:19,389
some serious changes to

2049
01:15:19,389 --> 01:15:21,029
the left hand side object

2050
01:15:21,029 --> 01:15:22,548
before it can be

2051
01:15:22,548 --> 01:15:26,430
sure I'll finish successfully.

2052
01:15:26,470 --> 01:15:29,368
We might throw an exception later on,

2053
01:15:29,368 --> 01:15:31,269
leaving the left hand side object

2054
01:15:31,269 --> 01:15:33,094
in a horrible state.

2055
01:15:33,094 --> 01:15:36,439
So so again, fixing

2056
01:15:36,439 --> 01:15:39,698
that is beyond the scope

2057
01:15:39,698 --> 01:15:41,559
of the class to

2058
01:15:41,559 --> 01:15:42,998
worry about all the exception details,

2059
01:15:42,998 --> 01:15:44,519
but we can show you a fix

2060
01:15:44,519 --> 01:15:46,519
that is something that will fix

2061
01:15:46,519 --> 01:15:47,878
the problem and will also be

2062
01:15:47,878 --> 01:15:49,158
a nice simple way

2063
01:15:49,158 --> 01:15:50,458
to write an assignment operator.

2064
01:15:50,458 --> 01:15:53,719
So we're going to do this by

2065
01:15:53,719 --> 01:15:55,519
essentially causing the order

2066
01:15:55,519 --> 01:15:57,698
of these things to be rearranged somehow.

2067
01:15:57,698 --> 01:15:59,078
We don't get rid of the old

2068
01:15:59,078 --> 01:16:00,679
guys text until we

2069
01:16:00,679 --> 01:16:04,189
have a we're sure

2070
01:16:04,189 --> 01:16:05,488
that we got the new storage.

2071
01:16:05,488 --> 01:16:07,128
We're not going to make changes to

2072
01:16:07,128 --> 01:16:08,408
the left hand side until we're

2073
01:16:08,408 --> 01:16:09,168
sure that we're not going

2074
01:16:09,168 --> 01:16:10,788
to throw an exception.

2075
01:16:10,788 --> 01:16:14,429
To do that we'll introduce

2076
01:16:14,429 --> 01:16:16,828
a new function to help us.

2077
01:16:16,828 --> 01:16:18,649
I'm going to show you the modern way

2078
01:16:18,649 --> 01:16:20,708
to write an assignment operator.

2079
01:16:20,708 --> 01:16:26,088
It's going to make use of one more function.

2080
01:16:26,088 --> 01:16:30,590
So let me go back up here to the declaration

2081
01:16:30,590 --> 01:16:32,569
of the string type

2082
01:16:32,569 --> 01:16:35,649
and introduce that function.

2083
01:16:35,649 --> 01:16:38,469
It's a swap function.

2084
01:16:39,210 --> 01:16:42,429
And basically, it allows you

2085
01:16:42,429 --> 01:16:45,288
to swap one string with another string.

2086
01:16:45,288 --> 01:16:48,890
And its implementation.

2087
01:16:48,890 --> 01:16:52,529
I won't go through the full implementation.

2088
01:16:52,779 --> 01:16:55,418
It's pretty straightforward.

2089
01:16:55,418 --> 01:17:00,698
Now, the goal of the swap function is if

2090
01:17:00,698 --> 01:17:03,458
one string has one text in

2091
01:17:03,458 --> 01:17:04,918
its length and another string

2092
01:17:04,918 --> 01:17:06,439
has another text in its length,

2093
01:17:06,439 --> 01:17:07,819
after the swap function,

2094
01:17:07,819 --> 01:17:09,479
those should have changed places.

2095
01:17:09,479 --> 01:17:12,359
So all we need to do is really

2096
01:17:12,359 --> 01:17:14,918
just swap the text pointers

2097
01:17:14,918 --> 01:17:17,679
and swap the lengths.

2098
01:17:17,679 --> 01:17:20,618
So some code to swap

2099
01:17:20,618 --> 01:17:23,338
the pointers and swap the lengths.

2100
01:17:23,338 --> 01:17:26,759
So let me illustrate the swap function

2101
01:17:26,759 --> 01:17:28,059
first and then see how it

2102
01:17:28,059 --> 01:17:30,738
solves our assignment problem.

2103
01:17:30,738 --> 01:17:32,878
If I have two strings,

2104
01:17:32,878 --> 01:17:34,998
let's say A and B.

2105
01:17:34,998 --> 01:17:38,019
And let's say A has the text, hello.

2106
01:17:38,019 --> 01:17:39,979
And it's five characters long,

2107
01:17:39,979 --> 01:17:41,698
and B has the text,

2108
01:17:41,698 --> 01:17:44,538
Wow and it's three characters long.

2109
01:17:44,538 --> 01:17:46,418
And I want to swap those strings.

2110
01:17:46,418 --> 01:17:47,658
I want B to end up

2111
01:17:47,658 --> 01:17:49,418
having the five character string hello,

2112
01:17:49,418 --> 01:17:52,019
and A having the three character string. Wow.

2113
01:17:52,019 --> 01:17:53,319
Okay.

2114
01:17:53,319 --> 01:17:54,679
Let me do the thing

2115
01:17:54,679 --> 01:17:56,559
that's pictorially easiest first.

2116
01:17:56,559 --> 01:17:58,878
My implementation of swaps said

2117
01:17:58,878 --> 01:18:00,019
we just swap the pointers

2118
01:18:00,019 --> 01:18:01,099
and swap the integers.

2119
01:18:01,099 --> 01:18:02,679
So how do you swap integers?

2120
01:18:02,679 --> 01:18:04,359
If I have two integers and I want to

2121
01:18:04,359 --> 01:18:07,139
swap their values, how do I do it?

2122
01:18:07,139 --> 01:18:10,059
Well, I don't just assign this one over

2123
01:18:10,059 --> 01:18:11,378
here and then this one over here because

2124
01:18:11,378 --> 01:18:12,958
if this were three and this were five,

2125
01:18:12,958 --> 01:18:15,019
if I assign the three to the five,

2126
01:18:15,019 --> 01:18:16,658
and then that's now three,

2127
01:18:16,658 --> 01:18:18,899
assign it back to the three, I lost the five.

2128
01:18:18,899 --> 01:18:20,738
So, of course, we know, oh,

2129
01:18:20,738 --> 01:18:22,439
to swap two integers,

2130
01:18:22,439 --> 01:18:24,238
we need a third variable,

2131
01:18:24,238 --> 01:18:26,498
and we will simply

2132
01:18:27,149 --> 01:18:29,229
set up that third variable,

2133
01:18:29,229 --> 01:18:30,809
say as a copy of this one, and

2134
01:18:30,809 --> 01:18:32,109
then assign the five over here,

2135
01:18:32,109 --> 01:18:32,769
and then assign

2136
01:18:32,769 --> 01:18:34,248
that temporary variable over here.

2137
01:18:34,248 --> 01:18:36,769
And now we've swapped the five into three.

2138
01:18:36,769 --> 01:18:39,149
So swapping two values,

2139
01:18:39,149 --> 01:18:41,948
simple built in types is really easy.

2140
01:18:41,948 --> 01:18:43,509
You just have another variable that type and

2141
01:18:43,509 --> 01:18:45,469
just do this little three way exchange.

2142
01:18:45,469 --> 01:18:46,368
So we do that.

2143
01:18:46,368 --> 01:18:48,168
I have a temporary integer

2144
01:18:48,168 --> 01:18:50,609
and I initialize it say to the three,

2145
01:18:50,609 --> 01:18:53,429
then I can assign the five over to here,

2146
01:18:53,429 --> 01:18:54,708
and then I can assign

2147
01:18:54,708 --> 01:18:56,208
the temporary over to here.

2148
01:18:56,208 --> 01:18:58,849
And I swap the integers. Three statements.

2149
01:18:58,849 --> 01:19:01,048
The simple statements swap the integers.

2150
01:19:01,048 --> 01:19:03,309
I'll do the same thing for pointers.

2151
01:19:03,309 --> 01:19:05,609
I'll have a temporary pointer to character,

2152
01:19:05,609 --> 01:19:07,029
a temporary pointer to character,

2153
01:19:07,029 --> 01:19:08,988
and I'll initialize it with this pointer,

2154
01:19:08,988 --> 01:19:10,868
and then I'll assign this pointer over to

2155
01:19:10,868 --> 01:19:14,128
here so that B no longer

2156
01:19:14,128 --> 01:19:16,948
points to WOW but

2157
01:19:16,948 --> 01:19:18,769
gets a copy of A's pointer,

2158
01:19:18,769 --> 01:19:20,729
we assign that to there.

2159
01:19:20,729 --> 01:19:24,469
Then I'll assign the temporary over to A.

2160
01:19:24,469 --> 01:19:26,189
Same thing I did with the integers

2161
01:19:26,189 --> 01:19:28,208
except this time we do it with the pointers.

2162
01:19:28,208 --> 01:19:31,429
That value gets assigned over to here.

2163
01:19:32,349 --> 01:19:36,109
I'm doing this badly. Okay. All right.

2164
01:19:36,109 --> 01:19:38,088
So this pointer got assigned over to here,

2165
01:19:38,088 --> 01:19:39,588
so A now points to WOW.

2166
01:19:39,588 --> 01:19:42,168
And when we leave our swap function,

2167
01:19:42,168 --> 01:19:43,849
the local variables go away,

2168
01:19:43,849 --> 01:19:47,488
the local integer, the local pointer go away.

2169
01:19:47,488 --> 01:19:52,708
And A points to WOW with a length of three,

2170
01:19:52,708 --> 01:19:56,229
and B points to hello with a length of five.

2171
01:19:56,229 --> 01:19:58,168
They have indeed been swapped.

2172
01:19:58,168 --> 01:20:00,149
Notice, all we did

2173
01:20:00,149 --> 01:20:03,088
was three statements to switch two integers,

2174
01:20:03,088 --> 01:20:05,029
three statements to switch two pointers.

2175
01:20:05,029 --> 01:20:08,170
Was there any new dynamic allocation?

2176
01:20:08,170 --> 01:20:10,128
No. Was there any deletion?

2177
01:20:10,128 --> 01:20:14,309
No. So operations involving

2178
01:20:14,309 --> 01:20:16,009
simple built in types

2179
01:20:16,009 --> 01:20:18,168
like this can't throw exceptions.

2180
01:20:18,168 --> 01:20:20,628
So swapping two strings with

2181
01:20:20,628 --> 01:20:23,088
our swap function will

2182
01:20:23,088 --> 01:20:25,009
correctly swap their values

2183
01:20:25,009 --> 01:20:26,748
and not throw any exceptions.

2184
01:20:26,748 --> 01:20:29,448
Okay, so we got the swap function.

2185
01:20:29,448 --> 01:20:31,628
So now what I want to do is figure out,

2186
01:20:31,628 --> 01:20:34,569
how do I do assignment in

2187
01:20:34,569 --> 01:20:38,029
a way that's going to work out nicely.

2188
01:20:38,029 --> 01:20:39,509
A, you don't have to know anything

2189
01:20:39,509 --> 01:20:40,788
about exceptions or anything like that.

2190
01:20:40,788 --> 01:20:41,788
I'm just going through

2191
01:20:41,788 --> 01:20:42,988
the thought process that

2192
01:20:42,988 --> 01:20:44,649
led to the modern way

2193
01:20:44,649 --> 01:20:46,538
to write an assignment operator.

2194
01:20:46,538 --> 01:20:49,948
Okay. So here's the idea.

2195
01:20:49,948 --> 01:20:51,288
The first thing we

2196
01:20:51,288 --> 01:20:53,309
do in our assignment operator,

2197
01:20:53,309 --> 01:20:54,229
once we know that they're not

2198
01:20:54,229 --> 01:20:56,128
the same object is

2199
01:20:56,128 --> 01:21:00,448
we create a temporary string

2200
01:21:00,448 --> 01:21:02,729
as a copy of the right hand side.

2201
01:21:02,729 --> 01:21:04,328
So we're going to

2202
01:21:04,328 --> 01:21:05,429
create a new string as

2203
01:21:05,429 --> 01:21:06,708
a copy of the right hand side.

2204
01:21:06,708 --> 01:21:08,288
Well, that's okay.

2205
01:21:08,288 --> 01:21:11,849
So here's say a temporary string

2206
01:21:11,849 --> 01:21:14,144
as a copy of the right hand side.

2207
01:21:14,144 --> 01:21:16,338
It's a copy of the right hand side.

2208
01:21:16,338 --> 01:21:18,779
Notice that that's going

2209
01:21:18,779 --> 01:21:20,458
to call the copy constructor somehow,

2210
01:21:20,458 --> 01:21:21,399
and that's going to

2211
01:21:21,399 --> 01:21:23,198
dynamically allocate storage here.

2212
01:21:23,198 --> 01:21:25,538
If it can't get the storage,

2213
01:21:25,538 --> 01:21:27,819
if an exception is thrown because we can't

2214
01:21:27,819 --> 01:21:30,158
get the storage from the dynamic allocation,

2215
01:21:30,158 --> 01:21:32,238
then we never got this far.

2216
01:21:32,238 --> 01:21:34,139
We never got the storage, and we leave

2217
01:21:34,139 --> 01:21:35,819
the assignment operator and

2218
01:21:35,819 --> 01:21:38,519
notice is unchanged.

2219
01:21:38,519 --> 01:21:40,059
So unlike the classic way

2220
01:21:40,059 --> 01:21:41,479
to write the assignment operator,

2221
01:21:41,479 --> 01:21:42,479
if we can't get

2222
01:21:42,479 --> 01:21:45,878
the storage as a copy of the hello,

2223
01:21:46,020 --> 01:21:48,819
we leave the function, and there's

2224
01:21:48,819 --> 01:21:51,479
no dangling pointer anywhere. We're fine.

2225
01:21:51,479 --> 01:21:53,918
If we succeed in

2226
01:21:53,918 --> 01:21:55,838
getting the storage for the temporary,

2227
01:21:55,838 --> 01:21:58,059
we're now going to finish the job

2228
01:21:58,059 --> 01:21:59,838
without doing

2229
01:21:59,838 --> 01:22:01,759
anything that could throw an exception.

2230
01:22:01,759 --> 01:22:04,439
And how are we going to do that? Very simple.

2231
01:22:04,439 --> 01:22:06,238
We're going to swap the value

2232
01:22:06,238 --> 01:22:08,578
of Temp and the value of.

2233
01:22:08,578 --> 01:22:14,479
So after swapping, so again,

2234
01:22:14,479 --> 01:22:16,578
you know, the swap function we go,

2235
01:22:16,578 --> 01:22:19,554
we'll exchange the integers.

2236
01:22:19,554 --> 01:22:21,969
And exchange the pointers.

2237
01:22:21,969 --> 01:22:25,309
No new dynamic allocation, exchanges here.

2238
01:22:25,309 --> 01:22:30,689
So ten points to WOW and points to Hello.

2239
01:22:30,689 --> 01:22:33,529
So after doing the swap,

2240
01:22:33,609 --> 01:22:35,809
has the old value of Temp,

2241
01:22:35,809 --> 01:22:37,649
which is a copy of the right hand side,

2242
01:22:37,649 --> 01:22:40,128
and Temp has the old value of HU.

2243
01:22:40,128 --> 01:22:43,128
Well, we've achieved the goal of assignment.

2244
01:22:43,128 --> 01:22:47,288
Y now has its own copy of the text of S and

2245
01:22:47,288 --> 01:22:49,288
the old looks like a copy of

2246
01:22:49,288 --> 01:22:52,288
S and has its own storage.

2247
01:22:52,288 --> 01:22:54,988
And that's great.

2248
01:22:54,988 --> 01:22:56,988
So all that has to happen is

2249
01:22:56,988 --> 01:23:00,069
for the local temp to be destroyed,

2250
01:23:00,069 --> 01:23:01,769
'cause when temp is destroyed,

2251
01:23:01,769 --> 01:23:03,724
that will get rid of the WOW

2252
01:23:03,724 --> 01:23:05,719
and then Tep goes away.

2253
01:23:05,719 --> 01:23:06,639
That works.

2254
01:23:06,639 --> 01:23:11,259
So, the implementation there says, All right.

2255
01:23:11,259 --> 01:23:14,748
Let's go look at the modern way to do this.

2256
01:23:14,748 --> 01:23:17,498
Let's create a temporary string

2257
01:23:17,498 --> 01:23:19,198
as a copy of the right hand side.

2258
01:23:19,198 --> 01:23:22,298
And on the left hand side object,

2259
01:23:22,298 --> 01:23:23,719
let's call the swap function

2260
01:23:23,719 --> 01:23:25,498
to swap it with the temporary.

2261
01:23:25,498 --> 01:23:27,939
And this closed curly

2262
01:23:27,939 --> 01:23:31,399
brace leaves the scope of the I statement,

2263
01:23:31,399 --> 01:23:32,838
which will cause when

2264
01:23:32,838 --> 01:23:34,479
we leave the scope of the if statement,

2265
01:23:34,479 --> 01:23:36,259
the temporary will be destroyed,

2266
01:23:36,259 --> 01:23:38,078
so that causes the destructor.

2267
01:23:38,078 --> 01:23:40,998
And there we go. That's it.

2268
01:23:40,998 --> 01:23:43,538
That is the modern way

2269
01:23:43,538 --> 01:23:45,359
to write an assignment operator.

2270
01:23:45,359 --> 01:23:50,219
This is the so called copy and swap approach.

2271
01:23:50,219 --> 01:23:53,019
It's really amazing. It's beautiful.

2272
01:23:53,019 --> 01:23:56,359
You've always wanted to, you know,

2273
01:23:56,359 --> 01:23:57,819
have the assignment operator

2274
01:23:57,819 --> 01:23:59,899
call the copy constructor somehow.

2275
01:23:59,899 --> 01:24:01,899
Well, it does it by

2276
01:24:01,899 --> 01:24:04,439
constructing a temporary string

2277
01:24:04,439 --> 01:24:05,998
as a copy of the right hand size.

2278
01:24:05,998 --> 01:24:07,639
So that does, in fact,

2279
01:24:07,639 --> 01:24:09,439
get the copy constructor called.

2280
01:24:09,439 --> 01:24:11,498
We don't have to have the I'm sorry,

2281
01:24:11,498 --> 01:24:12,979
the copy constructors down here.

2282
01:24:12,979 --> 01:24:14,439
We don't have to have this key code

2283
01:24:14,439 --> 01:24:15,819
written in more than one place.

2284
01:24:15,819 --> 01:24:17,599
That's the code for the copy constructor,

2285
01:24:17,599 --> 01:24:19,139
and that's the only place we write it.

2286
01:24:19,139 --> 01:24:21,738
And then our assignment operator will make

2287
01:24:21,738 --> 01:24:24,969
use of that to create the temporary object.

2288
01:24:24,969 --> 01:24:27,418
And that will try to

2289
01:24:27,418 --> 01:24:29,838
acquire storage to make a copy.

2290
01:24:29,838 --> 01:24:31,158
And if it fails and throws

2291
01:24:31,158 --> 01:24:33,338
an exception, we haven't changed anything.

2292
01:24:33,338 --> 01:24:36,238
If it succeeds, then all we have to do is put

2293
01:24:36,238 --> 01:24:38,319
the copied right hand side in

2294
01:24:38,319 --> 01:24:39,259
the proper place and

2295
01:24:39,259 --> 01:24:41,158
we do that by swapping it.

2296
01:24:41,158 --> 01:24:44,059
And the swap doesn't

2297
01:24:44,059 --> 01:24:45,559
do anything that can throw an exception

2298
01:24:45,559 --> 01:24:48,099
because it's just moving integers

2299
01:24:48,099 --> 01:24:49,538
around and moving pointers around.

2300
01:24:49,538 --> 01:24:51,359
There's nothing harmful there.

2301
01:24:51,359 --> 01:24:52,899
So there we go.

2302
01:24:52,899 --> 01:24:54,259
The modern pattern for

2303
01:24:54,259 --> 01:24:55,618
writing an assignment operator for

2304
01:24:55,618 --> 01:24:57,378
any type follows

2305
01:24:57,378 --> 01:25:00,038
pretty much exactly this approach.

2306
01:25:00,349 --> 01:25:02,609
For whatever type, in this case,

2307
01:25:02,609 --> 01:25:03,769
it happens to be string.

2308
01:25:03,769 --> 01:25:07,168
The signature of your function is you take

2309
01:25:07,168 --> 01:25:09,029
a constant reference to the right hand side

2310
01:25:09,029 --> 01:25:10,149
because you promise not to

2311
01:25:10,149 --> 01:25:11,628
modify the right hand side,

2312
01:25:11,628 --> 01:25:13,649
and you're going to return a reference,

2313
01:25:13,649 --> 01:25:15,429
which will be the return star this,

2314
01:25:15,429 --> 01:25:16,988
a reference to the left hand side,

2315
01:25:16,988 --> 01:25:19,769
and the body pretty much looks like this.

2316
01:25:19,769 --> 01:25:21,809
If the objects are different objects,

2317
01:25:21,809 --> 01:25:23,748
then we'll copy the right hand side

2318
01:25:23,748 --> 01:25:24,469
to a temp and then

2319
01:25:24,469 --> 01:25:25,868
swap it into the right place.

2320
01:25:25,868 --> 01:25:26,948
And the destructor will

2321
01:25:26,948 --> 01:25:27,948
get rid of the old value of

2322
01:25:27,948 --> 01:25:29,988
the left hand side because the old value of

2323
01:25:29,988 --> 01:25:31,809
the left hand side is sitting in the temp at

2324
01:25:31,809 --> 01:25:34,634
the time we destroy TEM.

2325
01:25:34,634 --> 01:25:36,698
If the objects are the same type

2326
01:25:36,698 --> 01:25:38,298
the same object,

2327
01:25:38,298 --> 01:25:39,559
then we skip all that and

2328
01:25:39,559 --> 01:25:41,759
just return star this.

2329
01:25:41,759 --> 01:25:44,019
But actually, if the objects are

2330
01:25:44,019 --> 01:25:46,319
the same object, this would still work.

2331
01:25:46,319 --> 01:25:48,939
So this if test is

2332
01:25:48,939 --> 01:25:51,000
not necessary for correctness.

2333
01:25:51,000 --> 01:25:53,800
It's just a bit of an optimization.

2334
01:25:53,800 --> 01:25:56,319
Because if the objects are the same object,

2335
01:25:56,319 --> 01:25:58,279
if you work through the code,

2336
01:25:58,279 --> 01:26:00,698
if I have the left hand side

2337
01:26:00,698 --> 01:26:02,639
and the right hand side object are the same,

2338
01:26:02,639 --> 01:26:06,259
then I simply copy the right hand side into a

2339
01:26:06,259 --> 01:26:08,849
temporary and then swap

2340
01:26:08,849 --> 01:26:10,649
it back in with the left hand side,

2341
01:26:10,649 --> 01:26:12,189
which is also the right hand side.

2342
01:26:12,189 --> 01:26:13,929
So we basically made a copy of

2343
01:26:13,929 --> 01:26:14,609
the value and then

2344
01:26:14,609 --> 01:26:16,208
swapped it back into itself.

2345
01:26:16,208 --> 01:26:17,828
So that was, you know,

2346
01:26:17,828 --> 01:26:19,969
wasteful, but at least it works.

2347
01:26:19,969 --> 01:26:23,389
So the test for

2348
01:26:23,389 --> 01:26:25,908
self assignments not

2349
01:26:25,908 --> 01:26:27,488
so necessary in this case.

2350
01:26:27,488 --> 01:26:29,288
But this is the pattern that people

2351
01:26:29,288 --> 01:26:32,009
these days now write assignment operators.

2352
01:26:32,009 --> 01:26:35,384
It requires having a swap function,

2353
01:26:35,384 --> 01:26:39,338
that itself does not well,

2354
01:26:39,338 --> 01:26:41,338
the swap function for string should not

2355
01:26:41,338 --> 01:26:43,779
call the assignment operator for string,

2356
01:26:43,779 --> 01:26:45,458
should not call the

2357
01:26:45,458 --> 01:26:47,059
copy constructor for string.

2358
01:26:47,059 --> 01:26:48,798
Swap should simply work

2359
01:26:48,798 --> 01:26:51,679
itself on the data members itself.

2360
01:26:51,679 --> 01:26:54,038
It defeats the purpose if

2361
01:26:54,038 --> 01:26:56,259
SWAP calls assignment for string

2362
01:26:56,259 --> 01:26:56,918
because string

2363
01:26:56,918 --> 01:26:58,279
is the assignment for strings is

2364
01:26:58,279 --> 01:26:59,279
going to be calling Swap.

2365
01:26:59,279 --> 01:27:01,059
So that's kind of silly.

2366
01:27:01,059 --> 01:27:03,298
And it defeats the purpose

2367
01:27:03,298 --> 01:27:04,979
of SWAP calls the copy constructor for

2368
01:27:04,979 --> 01:27:06,658
string because that's going to try to

2369
01:27:06,658 --> 01:27:08,759
dynamically allocate stuff that might fail,

2370
01:27:08,759 --> 01:27:10,779
and the whole point is we don't

2371
01:27:10,779 --> 01:27:12,498
want we don't want

2372
01:27:12,498 --> 01:27:13,418
the SWAP function to

2373
01:27:13,418 --> 01:27:15,094
do anything that might fail.

2374
01:27:15,094 --> 01:27:18,229
So the swap function should be written

2375
01:27:18,229 --> 01:27:23,088
to simply do the swaps on the data members.

2376
01:27:25,729 --> 01:27:27,809
And then we've got a pattern

2377
01:27:27,809 --> 01:27:29,088
that works very nicely for writing

2378
01:27:29,088 --> 01:27:31,408
an assignment operator that leverages

2379
01:27:31,408 --> 01:27:32,609
the code of the copy constructor

2380
01:27:32,609 --> 01:27:33,109
without having to

2381
01:27:33,109 --> 01:27:34,529
actually duplicate that code.

2382
01:27:34,529 --> 01:27:38,969
Okay, so that is

2383
01:27:38,969 --> 01:27:41,208
the last bit of the resource

2384
01:27:41,208 --> 01:27:42,988
management stuff I wanted to get into.

2385
01:27:42,988 --> 01:27:44,828
You know, the basic ideas

2386
01:27:44,828 --> 01:27:46,908
here carry over for lots of other types.

2387
01:27:46,908 --> 01:27:49,208
As I said, for our purposes,

2388
01:27:49,208 --> 01:27:50,649
the main resource we're going to be

2389
01:27:50,649 --> 01:27:52,509
managing when we write our own types,

2390
01:27:52,509 --> 01:27:54,168
it tends to be memory,

2391
01:27:54,168 --> 01:27:56,828
but it could be all kinds of other things

2392
01:27:56,828 --> 01:27:59,368
like open file descriptors or locks on

2393
01:27:59,368 --> 01:28:02,628
database records or any other sort

2394
01:28:02,628 --> 01:28:04,009
of resource that you might have

2395
01:28:04,009 --> 01:28:06,369
to allocate and deallocate,

2396
01:28:06,369 --> 01:28:08,889
which means you'd have to write a destructor.

2397
01:28:08,889 --> 01:28:10,128
And if you need to write

2398
01:28:10,128 --> 01:28:12,189
a destructor for a type,

2399
01:28:12,189 --> 01:28:14,069
you quite often will have to write

2400
01:28:14,069 --> 01:28:15,189
a copy constructor and an

2401
01:28:15,189 --> 01:28:17,429
assignment operator to get correct behavior.

2402
01:28:17,429 --> 01:28:19,689
Because the reason to write a destructor is

2403
01:28:19,689 --> 01:28:22,474
usually there's a resource I want to release.

2404
01:28:22,474 --> 01:28:24,279
But then that also means, well,

2405
01:28:24,279 --> 01:28:25,939
then how do I copy the

2406
01:28:25,939 --> 01:28:27,939
object if it holds a resource?

2407
01:28:27,939 --> 01:28:31,498
Do I want the compiler just to do a member by

2408
01:28:31,498 --> 01:28:33,418
member copy of the data members

2409
01:28:33,418 --> 01:28:35,998
or do I need to take control myself?

2410
01:28:35,998 --> 01:28:37,679
So generally,

2411
01:28:37,679 --> 01:28:41,380
these three functions, the destructor,

2412
01:28:41,380 --> 01:28:43,099
the assignment operator,

2413
01:28:43,099 --> 01:28:44,859
destructor, the copy constructor,

2414
01:28:44,859 --> 01:28:47,279
and the assignment operator tend

2415
01:28:47,279 --> 01:28:48,439
to all travel together.

2416
01:28:48,439 --> 01:28:49,899
If you need one, you're

2417
01:28:49,899 --> 01:28:51,779
generally going to need the other two.

2418
01:28:51,779 --> 01:28:53,338
There are some exceptions, but

2419
01:28:53,338 --> 01:28:54,338
that's generally going to

2420
01:28:54,338 --> 01:28:55,404
be the way it works.

2421
01:28:55,404 --> 01:28:58,168
Now, what that tells you, for example,

2422
01:28:58,168 --> 01:28:59,988
although I think we mentioned it

2423
01:28:59,988 --> 01:29:02,689
in a footnote in the Project one spec,

2424
01:29:02,689 --> 01:29:05,208
is that project one is kind of

2425
01:29:05,208 --> 01:29:08,849
deficient in this regard, because after all,

2426
01:29:08,849 --> 01:29:11,389
if you have a room object

2427
01:29:11,389 --> 01:29:13,048
and this room object has

2428
01:29:13,048 --> 01:29:17,719
an array of pointers to Bs Okay.

2429
01:29:17,719 --> 01:29:19,658
Now, we have a destructor that

2430
01:29:19,658 --> 01:29:21,679
says when a room object is going away,

2431
01:29:21,679 --> 01:29:23,319
we have to loop through the array of

2432
01:29:23,319 --> 01:29:24,979
pointers to bees for as many as

2433
01:29:24,979 --> 01:29:26,759
there are and call delete

2434
01:29:26,759 --> 01:29:27,859
on each of these pointers

2435
01:29:27,859 --> 01:29:29,038
to get rid of the bees.

2436
01:29:29,038 --> 01:29:31,078
That's fine. That deletions fine.

2437
01:29:31,078 --> 01:29:33,078
But we never wrote a copy constructor.

2438
01:29:33,078 --> 01:29:34,838
We never wrote an assignment operator.

2439
01:29:34,838 --> 01:29:36,859
We didn't need to copy or assign rooms.

2440
01:29:36,859 --> 01:29:38,958
But maybe this class can be used as part of

2441
01:29:38,958 --> 01:29:40,219
some fancier game where

2442
01:29:40,219 --> 01:29:42,479
we do need to say copy rooms.

2443
01:29:42,479 --> 01:29:43,979
If you want to be

2444
01:29:43,979 --> 01:29:45,779
careful because look what happens.

2445
01:29:45,779 --> 01:29:48,279
If we create another

2446
01:29:48,279 --> 01:29:50,099
room as a copy of this one,

2447
01:29:50,099 --> 01:29:51,719
then here's another room

2448
01:29:51,719 --> 01:29:53,998
and it has this array.

2449
01:29:54,119 --> 01:29:57,479
If we don't write a copy constructor,

2450
01:29:57,479 --> 01:29:59,158
the compiler writes one for

2451
01:29:59,158 --> 01:30:02,139
us that simply copies each member.

2452
01:30:02,139 --> 01:30:07,458
If this is a ten by 15 room,

2453
01:30:07,458 --> 01:30:09,878
say one member has the number of rows,

2454
01:30:09,878 --> 01:30:11,298
one member has the number of columns,

2455
01:30:11,298 --> 01:30:13,038
and there are other data members as well.

2456
01:30:13,038 --> 01:30:14,798
So if you don't write a copy constructor,

2457
01:30:14,798 --> 01:30:16,118
here's what will happen.

2458
01:30:16,118 --> 01:30:18,679
The one the compiler writes for us will copy

2459
01:30:18,679 --> 01:30:22,479
the integer, copy the integer,

2460
01:30:22,600 --> 01:30:27,078
and then it's got a copy the array,

2461
01:30:27,078 --> 01:30:28,698
which it does by copying each member,

2462
01:30:28,698 --> 01:30:30,279
copy the pointer, copy

2463
01:30:30,279 --> 01:30:33,109
the pointer, copy the pointer.

2464
01:30:33,109 --> 01:30:35,698
So the problem is the new room shares

2465
01:30:35,698 --> 01:30:38,399
the same bees as the old room.

2466
01:30:38,399 --> 01:30:39,399
That's going to be

2467
01:30:39,399 --> 01:30:40,418
a problem because, of course,

2468
01:30:40,418 --> 01:30:42,078
when we're done with that copied room and

2469
01:30:42,078 --> 01:30:45,179
that copied room is about to go away,

2470
01:30:45,179 --> 01:30:46,658
the destructor is going to

2471
01:30:46,658 --> 01:30:47,719
go through the array and

2472
01:30:47,719 --> 01:30:49,979
call delete on each of the pointers here,

2473
01:30:49,979 --> 01:30:51,238
and then this can go right now.

2474
01:30:51,238 --> 01:30:53,779
This can go right now. This go away now.

2475
01:30:53,779 --> 01:30:55,639
But the original room now

2476
01:30:55,639 --> 01:30:56,918
has a bunch of dangling pointers,

2477
01:30:56,918 --> 01:30:57,838
and when the destructor

2478
01:30:57,838 --> 01:30:59,139
is called in this room,

2479
01:30:59,139 --> 01:31:00,998
delete is going to be called on all these

2480
01:31:00,998 --> 01:31:04,078
dangling pointers, undefined behavior.

2481
01:31:04,078 --> 01:31:06,078
So if a room contains pointers

2482
01:31:06,078 --> 01:31:07,618
to dynamically allocated bees,

2483
01:31:07,618 --> 01:31:08,958
then we have to think carefully about

2484
01:31:08,958 --> 01:31:10,298
the copying and assignment behavior

2485
01:31:10,298 --> 01:31:11,298
of the room type.

2486
01:31:11,298 --> 01:31:12,979
So we didn't clutter

2487
01:31:12,979 --> 01:31:14,779
your mind with that in Project one,

2488
01:31:14,779 --> 01:31:16,059
and certainly we didn't clutter

2489
01:31:16,059 --> 01:31:17,759
people in CS 31 with that.

2490
01:31:17,759 --> 01:31:19,279
But realistically,

2491
01:31:19,279 --> 01:31:21,319
that's what you would want to do.

2492
01:31:21,319 --> 01:31:23,439
Right. So if you need a destructor,

2493
01:31:23,439 --> 01:31:24,819
you probably need to think

2494
01:31:24,819 --> 01:31:27,078
about copying an assignment as well.

2495
01:31:27,078 --> 01:31:29,679
Okay? So, finally, I want to

2496
01:31:29,679 --> 01:31:30,838
hit an issue that comes up when

2497
01:31:30,838 --> 01:31:32,059
you're dealing with assignment,

2498
01:31:32,059 --> 01:31:34,128
but it's actually much more general.

2499
01:31:34,128 --> 01:31:37,139
So looking back at assignment of

2500
01:31:37,139 --> 01:31:38,439
strings with the

2501
01:31:38,439 --> 01:31:40,159
old fashioned implementation,

2502
01:31:40,159 --> 01:31:41,719
remember that if I write

2503
01:31:41,719 --> 01:31:43,259
an expression U gets

2504
01:31:43,259 --> 01:31:44,899
S using the assignment operator,

2505
01:31:44,899 --> 01:31:47,238
that really means call the member function.

2506
01:31:47,238 --> 01:31:48,819
And here was

2507
01:31:48,819 --> 01:31:50,599
an implementation of the member function,

2508
01:31:50,599 --> 01:31:52,399
the old fashioned implementation,

2509
01:31:52,399 --> 01:31:53,319
look like this.

2510
01:31:53,319 --> 01:31:55,219
We clean up the left hand side,

2511
01:31:55,219 --> 01:31:56,738
and we copy over the right

2512
01:31:56,738 --> 01:31:58,378
hand side, that'll work.

2513
01:31:58,378 --> 01:32:00,078
Now, it's not going to

2514
01:32:00,078 --> 01:32:02,019
work correctly in the face of exceptions.

2515
01:32:02,019 --> 01:32:03,599
The new can't do its job,

2516
01:32:03,599 --> 01:32:04,958
that's why we tend to use

2517
01:32:04,958 --> 01:32:06,918
the modern style of copy and swap.

2518
01:32:06,918 --> 01:32:08,859
But the key point is,

2519
01:32:08,859 --> 01:32:12,203
if we don't check for self assignment here,

2520
01:32:12,203 --> 01:32:15,769
if we don't check that the object that

2521
01:32:15,769 --> 01:32:18,309
the left hand side pointer is pointing to is

2522
01:32:18,309 --> 01:32:19,708
different from the object that

2523
01:32:19,708 --> 01:32:21,948
the right hand side is a reference to,

2524
01:32:21,948 --> 01:32:23,949
this code was problematic.

2525
01:32:23,949 --> 01:32:25,248
I went through that. We'd be

2526
01:32:25,248 --> 01:32:26,109
deleting the text for

2527
01:32:26,109 --> 01:32:27,128
the left hand side value,

2528
01:32:27,128 --> 01:32:28,208
but if that's the same object

2529
01:32:28,208 --> 01:32:29,469
as the right hand side value,

2530
01:32:29,469 --> 01:32:30,668
we just lost that text

2531
01:32:30,668 --> 01:32:32,009
from the right hand side value.

2532
01:32:32,009 --> 01:32:34,448
So the problem comes if

2533
01:32:34,448 --> 01:32:35,729
the left hand side value is

2534
01:32:35,729 --> 01:32:37,389
the same object as the right hand side value.

2535
01:32:37,389 --> 01:32:39,828
For example, let's say that

2536
01:32:39,828 --> 01:32:43,788
we've got an array of strings and we

2537
01:32:43,788 --> 01:32:45,269
have some algorithm that's going through

2538
01:32:45,269 --> 01:32:47,229
and assigning the string

2539
01:32:47,229 --> 01:32:48,649
at position J of the array

2540
01:32:48,649 --> 01:32:51,118
to the string at position I of the array.

2541
01:32:51,118 --> 01:32:54,948
And what happens, of course, this means that.

2542
01:32:54,948 --> 01:32:57,689
But what happens if I happens

2543
01:32:57,689 --> 01:32:59,729
to be equal to J at some point?

2544
01:32:59,729 --> 01:33:01,948
Then that means that the left hand side,

2545
01:33:01,948 --> 01:33:04,029
SSI, well, that's what

2546
01:33:04,029 --> 01:33:05,309
the this pointer is going to point

2547
01:33:05,309 --> 01:33:07,288
to in this call here.

2548
01:33:07,288 --> 01:33:09,748
And the right hand side object,

2549
01:33:09,748 --> 01:33:11,429
SAs J, that's going to

2550
01:33:11,429 --> 01:33:13,448
be the same object as SA sabi.

2551
01:33:13,448 --> 01:33:15,868
So RHS, the parameter RHS will be

2552
01:33:15,868 --> 01:33:19,109
a reference to SACBI the same object.

2553
01:33:19,109 --> 01:33:20,708
This is called aliasing.

2554
01:33:20,708 --> 01:33:23,229
When you have two or more ways

2555
01:33:23,229 --> 01:33:25,128
of talking about the same object.

2556
01:33:25,128 --> 01:33:27,868
Coming from the normal use of the word alias,

2557
01:33:27,868 --> 01:33:29,988
typically a criminal will have an alias.

2558
01:33:29,988 --> 01:33:32,229
They will use they'll have their real name.

2559
01:33:32,229 --> 01:33:34,948
So, for example, James Bulger,

2560
01:33:34,948 --> 01:33:37,088
whose nickname was Whitey Bulger,

2561
01:33:37,088 --> 01:33:38,908
was a Boston crime boss,

2562
01:33:38,908 --> 01:33:41,909
active from being a kid in the 1940s.

2563
01:33:41,909 --> 01:33:45,470
And then he went into hiding in the 1990s

2564
01:33:45,470 --> 01:33:47,389
and ended living in

2565
01:33:47,389 --> 01:33:48,588
Santa Monica under

2566
01:33:48,588 --> 01:33:50,208
the alias of Charles Gasco.

2567
01:33:50,208 --> 01:33:52,109
So Charles Gasco is

2568
01:33:52,109 --> 01:33:53,649
an alias for the person

2569
01:33:53,649 --> 01:33:55,389
whose real name is James Bolger.

2570
01:33:55,389 --> 01:33:57,128
He was actually ultimately caught.

2571
01:33:57,128 --> 01:33:59,649
So anyway, in a computer science context,

2572
01:33:59,649 --> 01:34:02,609
this would mean if you've got two ways of

2573
01:34:02,609 --> 01:34:03,849
talking about the same object

2574
01:34:03,849 --> 01:34:06,048
perhaps as maybe you have a pointer,

2575
01:34:06,048 --> 01:34:07,929
two pointers pointing to the same object

2576
01:34:07,929 --> 01:34:09,969
or a pointer in reference to the same object,

2577
01:34:09,969 --> 01:34:11,809
then that would be an example there.

2578
01:34:11,809 --> 01:34:13,788
So this happens here

2579
01:34:13,788 --> 01:34:15,168
in this assignment operator,

2580
01:34:15,168 --> 01:34:16,929
and this function has

2581
01:34:16,929 --> 01:34:19,243
as a parameter a reference to a string.

2582
01:34:19,243 --> 01:34:20,878
And so whenever aliasing

2583
01:34:20,878 --> 01:34:22,599
occurs, you've got to ask yourself,

2584
01:34:22,599 --> 01:34:24,618
is my code correct if

2585
01:34:24,618 --> 01:34:25,899
these two ways of talking about

2586
01:34:25,899 --> 01:34:26,958
an object are actually

2587
01:34:26,958 --> 01:34:28,139
talking about the same object.

2588
01:34:28,139 --> 01:34:29,158
And so we found that

2589
01:34:29,158 --> 01:34:30,998
our original implementation was, no,

2590
01:34:30,998 --> 01:34:33,479
that was not correct if this pointer points

2591
01:34:33,479 --> 01:34:34,259
to the same object that

2592
01:34:34,259 --> 01:34:36,158
the RHS reference is referring to.

2593
01:34:36,158 --> 01:34:37,738
And that led us to realize,

2594
01:34:37,738 --> 01:34:39,179
Oh, we have to fix that here.

2595
01:34:39,179 --> 01:34:40,859
Now, this can come up in

2596
01:34:40,859 --> 01:34:42,798
all sorts of situations.

2597
01:34:42,798 --> 01:34:44,439
So let's say we have some kind

2598
01:34:44,439 --> 01:34:46,338
of financial application,

2599
01:34:46,338 --> 01:34:49,219
and we have a function

2600
01:34:49,219 --> 01:34:51,238
that we use to transfer

2601
01:34:51,238 --> 01:34:53,069
money from one account to another.

2602
01:34:53,069 --> 01:34:55,298
So here's this transfer function.

2603
01:34:55,298 --> 01:34:56,639
You give it the account

2604
01:34:56,639 --> 01:34:58,019
you're transferring thought from,

2605
01:34:58,019 --> 01:34:59,838
the account you're transferring to,

2606
01:34:59,838 --> 01:35:02,088
and the amount you want to transfer.

2607
01:35:02,088 --> 01:35:03,838
And so it seems like

2608
01:35:03,838 --> 01:35:06,618
the straightforward algorithm is, well,

2609
01:35:06,618 --> 01:35:08,418
if the amount you want to transfer is

2610
01:35:08,418 --> 01:35:09,719
more than the balance

2611
01:35:09,719 --> 01:35:11,298
of the account you're transferring from,

2612
01:35:11,298 --> 01:35:12,979
we should write an error message.

2613
01:35:12,979 --> 01:35:15,059
There's not enough money to do the transfer.

2614
01:35:15,059 --> 01:35:17,279
Otherwise, we'll debit

2615
01:35:17,279 --> 01:35:18,738
from account by that amount,

2616
01:35:18,738 --> 01:35:21,859
subtract the amount from the from account,

2617
01:35:21,859 --> 01:35:22,679
and we'll credit

2618
01:35:22,679 --> 01:35:24,198
the two account with that amount.

2619
01:35:24,198 --> 01:35:27,219
We'll add that amount to the two account.

2620
01:35:27,219 --> 01:35:29,338
Okay, this looks

2621
01:35:29,338 --> 01:35:32,019
really pretty obviously correct.

2622
01:35:32,019 --> 01:35:33,953
This seems to be the correct behavior.

2623
01:35:33,953 --> 01:35:35,708
But we have

2624
01:35:35,708 --> 01:35:38,109
a situation where aliasing occurs.

2625
01:35:38,109 --> 01:35:39,708
In this function, we

2626
01:35:39,708 --> 01:35:42,309
have two references to accounts.

2627
01:35:42,309 --> 01:35:44,248
What if they're the same account?

2628
01:35:44,248 --> 01:35:46,548
So you should always be asking yourself about

2629
01:35:46,548 --> 01:35:49,429
this when you have a function.

2630
01:35:49,429 --> 01:35:51,149
Be on the lookout for

2631
01:35:51,149 --> 01:35:54,349
two pointers or references to the same type.

2632
01:35:54,349 --> 01:35:56,288
That means aliasing might occur,

2633
01:35:56,288 --> 01:35:57,628
and you want to make sure your code is

2634
01:35:57,628 --> 01:35:59,908
correct in the case that aliasing can occur.

2635
01:35:59,908 --> 01:36:01,769
So it happens here because we have

2636
01:36:01,769 --> 01:36:04,009
two references to account.

2637
01:36:04,009 --> 01:36:06,029
It happened the assignment operator,

2638
01:36:06,029 --> 01:36:07,328
a little more subtly,

2639
01:36:07,328 --> 01:36:09,654
as a member function,

2640
01:36:09,654 --> 01:36:13,519
this pointer will be a pointer to a string,

2641
01:36:13,519 --> 01:36:15,219
and there's a parameter

2642
01:36:15,219 --> 01:36:16,958
that's a reference to a string.

2643
01:36:16,958 --> 01:36:20,559
So this function could have aliasing

2644
01:36:20,559 --> 01:36:22,779
occurring if the pointer

2645
01:36:22,779 --> 01:36:23,838
and the reference are

2646
01:36:23,838 --> 01:36:25,059
talking about the same object.

2647
01:36:25,059 --> 01:36:26,298
And, of course, we saw that

2648
01:36:26,298 --> 01:36:28,448
and we fixed it because it was incorrect.

2649
01:36:28,448 --> 01:36:30,019
So what happens here?

2650
01:36:30,019 --> 01:36:31,679
What happens if I try to

2651
01:36:31,679 --> 01:36:34,118
transfer money from an account to itself?

2652
01:36:34,118 --> 01:36:36,439
What if we end up calling transfer, say,

2653
01:36:36,439 --> 01:36:37,559
we have an array of accounts,

2654
01:36:37,559 --> 01:36:38,878
so we have some algorithm that's

2655
01:36:38,878 --> 01:36:40,958
moving money around between the arrays,

2656
01:36:40,958 --> 01:36:44,998
and this algorithm is at

2657
01:36:44,998 --> 01:36:46,939
various times transferring money

2658
01:36:46,939 --> 01:36:49,319
from A subi the account array,

2659
01:36:49,319 --> 01:36:51,338
subi to a sub J,

2660
01:36:51,338 --> 01:36:54,498
and we're transferring $20,000 around.

2661
01:36:54,498 --> 01:36:56,019
Okay, or some amount.

2662
01:36:56,019 --> 01:36:58,019
Well, again, if I is equal to J,

2663
01:36:58,019 --> 01:36:59,658
these are actually the same account,

2664
01:36:59,658 --> 01:37:01,578
and so we're transferring $20,000

2665
01:37:01,578 --> 01:37:02,918
from an account to itself.

2666
01:37:02,918 --> 01:37:04,139
Now, you might say,

2667
01:37:04,139 --> 01:37:06,708
well, that should be harmless.

2668
01:37:06,708 --> 01:37:07,788
I mean, if you're just moving

2669
01:37:07,788 --> 01:37:08,948
money from an account to itself,

2670
01:37:08,948 --> 01:37:10,708
you're not really moving money at all.

2671
01:37:10,708 --> 01:37:12,908
So let's see what happens here.

2672
01:37:12,908 --> 01:37:15,349
Well, if the account has,

2673
01:37:15,349 --> 01:37:17,009
say, $40,000 in it,

2674
01:37:17,009 --> 01:37:19,048
then we're going to subtract

2675
01:37:19,048 --> 01:37:20,588
$20,000 from the account

2676
01:37:20,588 --> 01:37:22,309
and then credit it with $20,000.

2677
01:37:22,309 --> 01:37:23,788
So it ends up with the same amount of money,

2678
01:37:23,788 --> 01:37:26,868
$40,000. So it looks harmless.

2679
01:37:26,868 --> 01:37:29,328
Well, yes and no.

2680
01:37:29,328 --> 01:37:34,519
In that case, it's harmless, but maybe not.

2681
01:37:34,519 --> 01:37:35,998
You know, what if the account only

2682
01:37:35,998 --> 01:37:37,578
has $5,000 in it?

2683
01:37:37,578 --> 01:37:38,279
Well, then we're going to

2684
01:37:38,279 --> 01:37:39,019
write an error message

2685
01:37:39,019 --> 01:37:40,198
or is it going to say, Hey, guess what?

2686
01:37:40,198 --> 01:37:41,998
You can't transfer $20,000

2687
01:37:41,998 --> 01:37:43,779
from this account to itself.

2688
01:37:43,779 --> 01:37:47,439
Well, yeah, but really, so what?

2689
01:37:47,439 --> 01:37:49,078
If it's only got $5,000,

2690
01:37:49,078 --> 01:37:50,418
that's not really a transfer.

2691
01:37:50,418 --> 01:37:51,738
So you might question whether

2692
01:37:51,738 --> 01:37:53,779
writing an error message is appropriate here.

2693
01:37:53,779 --> 01:37:55,639
Or there might be circumstances

2694
01:37:55,639 --> 01:37:57,838
where maybe debiting money

2695
01:37:57,838 --> 01:37:59,948
from an account maybe

2696
01:37:59,948 --> 01:38:02,168
the bank charges a slight fee for that.

2697
01:38:02,168 --> 01:38:05,288
So if you don't actually do a real transfer,

2698
01:38:05,288 --> 01:38:07,309
if you're actually not really transferring

2699
01:38:07,309 --> 01:38:08,948
money because it's the same account,

2700
01:38:08,948 --> 01:38:11,168
then should you be charged the fee for

2701
01:38:11,168 --> 01:38:14,469
a transfer when there really was for a debit,

2702
01:38:14,469 --> 01:38:16,309
because there really was no debit

2703
01:38:16,309 --> 01:38:18,288
because you just credited it right back.

2704
01:38:18,288 --> 01:38:20,809
And even worse, suppose

2705
01:38:20,809 --> 01:38:23,849
that there's a law that

2706
01:38:23,849 --> 01:38:25,828
says that if at least

2707
01:38:25,828 --> 01:38:27,929
$10,000 is being transferred

2708
01:38:27,929 --> 01:38:29,509
from one account to another,

2709
01:38:29,509 --> 01:38:31,548
a form has to be filed with the government,

2710
01:38:31,548 --> 01:38:32,809
maybe to help trace

2711
01:38:32,809 --> 01:38:34,609
money laundering or something like that.

2712
01:38:34,609 --> 01:38:37,328
So our code could be, Okay, we'll fix that.

2713
01:38:37,328 --> 01:38:39,588
We'll say if the amounts at least $10,000,

2714
01:38:39,588 --> 01:38:40,429
then we're going to

2715
01:38:40,429 --> 01:38:41,929
file some form with the government.

2716
01:38:41,929 --> 01:38:44,009
The problem is, again,

2717
01:38:44,009 --> 01:38:45,868
if you're not really transferring

2718
01:38:45,868 --> 01:38:46,828
money because it's from

2719
01:38:46,828 --> 01:38:48,488
an account to the same account,

2720
01:38:48,488 --> 01:38:51,208
then you really shouldn't be filing the form.

2721
01:38:51,208 --> 01:38:52,509
There is no transfer

2722
01:38:52,509 --> 01:38:53,649
of money going on, really.

2723
01:38:53,649 --> 01:38:55,288
It's staying in the same account.

2724
01:38:55,288 --> 01:38:56,788
So, you know, that's

2725
01:38:56,788 --> 01:38:58,029
an unnecessary form you're

2726
01:38:58,029 --> 01:38:59,173
filing with the government.

2727
01:38:59,173 --> 01:39:01,099
Now, you might say, so what?

2728
01:39:01,099 --> 01:39:03,998
Well, there are laws in effect that

2729
01:39:03,998 --> 01:39:05,458
say that filing too

2730
01:39:05,458 --> 01:39:07,279
many frivolous forms with the government,

2731
01:39:07,279 --> 01:39:08,979
you know, could earn you a fine.

2732
01:39:08,979 --> 01:39:10,899
For example, there's actually

2733
01:39:10,899 --> 01:39:13,298
a federal law that makes it a

2734
01:39:13,298 --> 01:39:15,559
crime subject to a fine and

2735
01:39:15,559 --> 01:39:17,519
possibly imprisonment to file

2736
01:39:17,519 --> 01:39:18,979
a frivolous tax return.

2737
01:39:18,979 --> 01:39:20,658
There are various tax protesters

2738
01:39:20,658 --> 01:39:21,719
who believe, for example,

2739
01:39:21,719 --> 01:39:23,538
the 16th Amendment, which authorizes

2740
01:39:23,538 --> 01:39:25,899
the income tax was improperly passed.

2741
01:39:25,899 --> 01:39:27,238
It's unconstitutional to have

2742
01:39:27,238 --> 01:39:29,179
an income tax, a federal income tax.

2743
01:39:29,179 --> 01:39:31,078
Therefore, they will protest this

2744
01:39:31,078 --> 01:39:33,779
by filing you know,

2745
01:39:33,779 --> 01:39:35,618
silly returns with the government

2746
01:39:35,618 --> 01:39:36,779
hoping to overload

2747
01:39:36,779 --> 01:39:38,359
them with all these

2748
01:39:38,359 --> 01:39:40,559
silly income tax returns, et cetera.

2749
01:39:40,559 --> 01:39:42,139
Well, the government says you can't do that.

2750
01:39:42,139 --> 01:39:43,198
That's a crime to file

2751
01:39:43,198 --> 01:39:44,319
a frivolous tax return.

2752
01:39:44,319 --> 01:39:44,918
So, you know,

2753
01:39:44,918 --> 01:39:46,099
maybe there's something that says,

2754
01:39:46,099 --> 01:39:47,519
if you file forms for

2755
01:39:47,519 --> 01:39:49,418
this money laundering tracing law,

2756
01:39:49,418 --> 01:39:50,939
if you file forms that aren't

2757
01:39:50,939 --> 01:39:53,038
really transfers, that's frivolous.

2758
01:39:53,038 --> 01:39:54,698
And if there's too many of those,

2759
01:39:54,698 --> 01:39:56,439
we will find your company.

2760
01:39:56,439 --> 01:39:57,198
So there could be

2761
01:39:57,198 --> 01:39:59,298
consequences for ignoring alias.

2762
01:39:59,298 --> 01:40:00,979
So at the very least,

2763
01:40:00,979 --> 01:40:02,479
you should consider the issue

2764
01:40:02,479 --> 01:40:04,618
and check your implementation and see

2765
01:40:04,618 --> 01:40:06,078
if your implementation does

2766
01:40:06,078 --> 01:40:08,679
the right thing in the event of aliasing.

2767
01:40:08,679 --> 01:40:09,918
And so I would argue that

2768
01:40:09,918 --> 01:40:11,458
while at first glance,

2769
01:40:11,458 --> 01:40:12,979
it seems harmless, if you

2770
01:40:12,979 --> 01:40:14,179
transfer money from an account

2771
01:40:14,179 --> 01:40:14,939
to itself, so what?

2772
01:40:14,939 --> 01:40:16,918
It's not a real transfer. That's fine.

2773
01:40:16,918 --> 01:40:18,979
Well, you might want to rule that out.

2774
01:40:18,979 --> 01:40:20,418
So we might just decide to

2775
01:40:20,418 --> 01:40:22,298
protect this whole thing with, say,

2776
01:40:22,298 --> 01:40:24,703
if the from account

2777
01:40:24,703 --> 01:40:27,309
is different from the two account.

2778
01:40:27,309 --> 01:40:28,948
And how do we know they're different?

2779
01:40:28,948 --> 01:40:29,529
Because they're in

2780
01:40:29,529 --> 01:40:30,828
different places in memory?

2781
01:40:30,828 --> 01:40:32,488
If the From account is

2782
01:40:32,488 --> 01:40:33,849
different from the two account,

2783
01:40:33,849 --> 01:40:34,948
then do all this work.

2784
01:40:34,948 --> 01:40:36,828
But if they're the same thing,

2785
01:40:36,828 --> 01:40:38,469
the same account, then do nothing.

2786
01:40:38,469 --> 01:40:40,003
It's not really a transfer.

2787
01:40:40,003 --> 01:40:42,279
Okay, so the bottom line

2788
01:40:42,279 --> 01:40:43,998
is you should always,

2789
01:40:43,998 --> 01:40:46,519
always be on the lookout for aliasing.

2790
01:40:46,519 --> 01:40:47,759
If a function can be

2791
01:40:47,759 --> 01:40:49,338
called with two pointers or

2792
01:40:49,338 --> 01:40:50,918
references to the same type,

2793
01:40:50,918 --> 01:40:52,399
aliasing might occur.

2794
01:40:52,399 --> 01:40:54,279
Make sure your implementation

2795
01:40:54,279 --> 01:40:56,719
takes care of that in an appropriate way.

2796
01:40:56,719 --> 01:40:58,698
There have been plenty of programs that

2797
01:40:58,698 --> 01:41:01,298
have been just fine until one day,

2798
01:41:01,298 --> 01:41:03,038
somebody did something involving

2799
01:41:03,038 --> 01:41:04,418
aliasing and oops,

2800
01:41:04,418 --> 01:41:06,179
that algorithm doesn't work correctly,

2801
01:41:06,179 --> 01:41:08,179
and so the program did bad.

2802
01:41:08,179 --> 01:41:09,878
So that wraps up what I want to

2803
01:41:09,878 --> 01:41:11,338
say about resource management,

2804
01:41:11,338 --> 01:41:13,859
and I'll end the recording here.
